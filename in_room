barter.c:        if (shop_index[i].merchant == ch->nr)
barter.c:    for (merchant = ch->in_room->people; merchant; merchant = merchant->next_in_room) {
barter.c:    if (ch->desc) {
barter.c:            page_string(ch->desc, list, 1);
barter.c:        if ((ch->specials.eco < 100) && (w_val > ch->specials.eco)) {
barter.c:        ch->specials.eco = (w_val > 100) ? 0 : ch->specials.eco - w_val;
barter.c:        if (!(trade = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
barter.c:         * if (ch->skills[SKILL_HAGGLE]) 
barter.c:     * haggle = ch->skills[SKILL_HAGGLE]->learned; 
barter.c:            || (merchant->player.race == RACE_GALITH && ch->specials.eco >= 100)) {
barter.c:    if (!ch || !ch->in_room || !obj) {
barter.c:                obj_to_room(temp_obj, ch->in_room);
barter.c:        for (tmerchant = ch->in_room->people, found = FALSE; tmerchant && !found;
barter.c:            if ((ch->specials.eco < 100)
barter.c:                && (barter->c_amount > ch->specials.eco)) {
barter.c:            ch->specials.eco = (barter->c_amount > 100) ? 0 : ch->specials.eco - barter->c_amount;
barter.c:            ch->points.obsidian -= barter->c_amount;
barter.c:            ch->specials.eco =
barter.c:                (ch->specials.eco + barter->m_amount >
barter.c:                 100) ? 100 : ch->specials.eco + barter->m_amount;
barter.c:            ch->points.obsidian += barter->m_amount;
barter.c:        page_string(ch->desc, OSTR(obj, description), 1);
biography.c:     ch->account, ch->name );
biography.c:       ch->name, ch->account, sql);
biography.c:    ch->account, ch->name, idx );
biography.c:       idx, ch->name, ch->account, sql);
biography.c:   entry->author = strdup(ch->name);
biography.c:   entry->account = strdup(ch->account);
board.c:                if (get_clan_rank(ch->clan, guild_num) < rank_num) {
board.c:    if (!(obj = get_obj_in_list_vis(ch, tmp, ch->in_room->contents)))
board.c:    if (!ch->desc)
board.c:    if (ch->lifting) {
board.c:        if (!drop_lifting(ch, ch->lifting))
board.c:    char *authname = GET_NAME(ch), *authacct = ch->account;
board.c:            && !has_extra_cmd(ch->granted_commands, CMD_DELETE, HIGHLORD, TRUE)))
board.c:      (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)))
board.c:    page_string(ch->desc, buffer, 1);
board.c:    page_string(ch->desc, buf, 1);
character.c:    if (!load_character_file(name, ch->account, cd)) {
character.c:    if (ch->name)
character.c:        cd->name = strdup(ch->name);
character.c:    if (ch->account)
character.c:        cd->account = strdup(ch->account);
character.c:    if (ch->short_descr)
character.c:        cd->short_description = strdup(ch->short_descr);
character.c:    if (ch->description)
character.c:        cd->description = strdup(ch->description);
character.c:    if (ch->player.extkwds)
character.c:        cd->keywords = strdup(ch->player.extkwds);
character.c:    if (ch->player.info[1] && strlen(ch->player.info[1]) > 0)
character.c:        cd->objective = strdup(ch->player.info[1]);
clans.c:    if (!ch->clan) {
clans.c:        pClan->next = ch->clan;
clans.c:        ch->clan = pClan;
clans.c:        for (tmp = ch->clan; tmp->next; tmp = tmp->next);
clans.c:    if (!ch->clan) {
clans.c:        pClan->next = ch->clan;
clans.c:        ch->clan = pClan;
clans.c:        for (tmp = ch->clan; tmp->next; tmp = tmp->next);
clans.c:    if (!ch->clan)
clans.c:    if (ch->clan->clan == clan) {
clans.c:        pClan = ch->clan;
clans.c:        ch->clan = ch->clan->next;
clans.c:    for (pClan = ch->clan; pClan; pClan = pClan->next) {
clans.c:    rank = get_clan_rank(ch->clan, clan);
clans.c:    for (cclan = ch->clan; cclan; cclan = cclan->next)
clans.c:        for (pClan = ch->clan; pClan; pClan = pClan->next) {
clans.c:    if (!is_set_clan_flag(ch->clan, clan, CJOB_RECRUITER)
clans.c:        && !is_set_clan_flag(ch->clan, clan, CJOB_LEADER)
clans.c:    if (!vch->clan)
clans.c:        vch->player.tribe = clan;
clans.c:        if (ch->clan)
clans.c:            clan = ch->clan->clan;
clans.c:    if (is_set_clan_flag(ch->clan, clan, CJOB_LEADER)) {
clans.c:    if (clan == ch->player.tribe) {
clans.c:        if (ch->clan)
clans.c:            ch->player.tribe = ch->clan->clan;
clans.c:            ch->player.tribe = 0;
clans.c:        for (pClan = ch->clan; pClan; pClan = pClan->next) {
clans.c:            for (vClan = vch->clan; vClan; vClan = vClan->next) {
clans.c:    if (!is_set_clan_flag(ch->clan, clan, CJOB_RECRUITER)
clans.c:        && !is_set_clan_flag(ch->clan, clan, CJOB_LEADER)
clans.c:    if (clan == vch->player.tribe) {
clans.c:        if (vch->clan)
clans.c:            vch->player.tribe = vch->clan->clan;
clans.c:            vch->player.tribe = 0;
clans.c:        for (pClan = vch->clan; pClan; pClan = pClan->next)
clans.c:            if (!IS_SET(vch->clan->flags, CJOB_LEADER))
clans.c:    if (is_set_clan_flag(vch->clan, clan, CJOB_LEADER)) {
clans.c:        remove_clan_flag(vch->clan, clan, CJOB_LEADER);
clans.c:        if (clan == vch->player.tribe)
clans.c:            REMOVE_BIT(vch->specials.act, CFL_CLANLEADER);
clans.c:        set_clan_flag(vch->clan, clan, CJOB_LEADER);
clans.c:        if (clan == vch->player.tribe)
clans.c:            MUD_SET_BIT(vch->specials.act, CFL_CLANLEADER);
clans.c:        for (pClan = vch->clan; pClan; pClan = pClan->next) {
clans.c:    if (!is_clan_member(ch->clan, clan) && !IS_IMMORTAL(ch)) {
clans.c:    if (!is_set_clan_flag(ch->clan, clan, CJOB_LEADER)
clans.c:        if (get_clan_rank(ch->clan, clan) < rank && !IS_IMMORTAL(ch)) {
clans.c:        if (get_clan_rank(vch->clan, clan) > rank) {
clans.c:        set_clan_rank(vch->clan, clan, rank);
clans.c:        if (get_clan_rank(ch->clan, clan) < rank && !IS_IMMORTAL(ch)) {
clans.c:        if (get_clan_rank(vch->clan, clan) > rank) {
clans.c:        set_clan_rank(vch->clan, clan, rank);
clans.c:    if (is_set_clan_flag(vch->clan, clan, flag)) {
clans.c:    set_clan_flag(vch->clan, clan, flag);
clans.c:    if (clan == vch->player.tribe && flag == CJOB_LEADER)
clans.c:        MUD_SET_BIT(vch->specials.act, CFL_CLANLEADER);
clans.c:        for (pClan = vch->clan; pClan; pClan = pClan->next) {
clans.c:    if (!is_clan_member(ch->clan, clan) && !IS_IMMORTAL(ch)) {
clans.c:    if (!is_clan_member(vch->clan, clan)) {
clans.c:    if (!is_set_clan_flag(ch->clan, clan, CJOB_LEADER)
clans.c:        if (get_clan_rank(ch->clan, clan) < rank && !IS_IMMORTAL(ch)) {
clans.c:        if (get_clan_rank(vch->clan, clan) <= rank) {
clans.c:        set_clan_rank(vch->clan, clan, rank);
clans.c:        if (get_clan_rank(ch->clan, clan) < rank && !IS_IMMORTAL(ch)) {
clans.c:        if (get_clan_rank(vch->clan, clan) <= rank) {
clans.c:        set_clan_rank(vch->clan, clan, rank);
clans.c:    if (!is_set_clan_flag(vch->clan, clan, flag)) {
clans.c:    remove_clan_flag(vch->clan, clan, flag);
clans.c:    if (clan == vch->player.tribe && flag == CJOB_LEADER)
clans.c:        REMOVE_BIT(vch->specials.act, CFL_CLANLEADER);
cmd_getopt.c:    page_string(ch->desc, helpstr, 1);
combat.c:    REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_INVISIBLE);
combat.c:    return find_ex_description("[DISENGAGE_REQUEST]", ch->ex_description, TRUE) != NULL;
combat.c:    //roomlogf( ch->in_room, "hp: %d lost of %d (%d curr): %f minthreshold, %f maxthrehold", lost_health, GET_MAX_HIT(ch), prev_health, hp_percent_of_curr, hp_percent_of_max);
combat.c:    //roomlogf( ch->in_room, "stun: %d lost of %d (%d curr): %f minthreshold, %f maxthrehold", lost_stun, GET_MAX_STUN(ch), prev_stun, sp_percent_of_curr, sp_percent_of_max);
combat.c:    //roomlogf( ch->in_room, "tol: %d, maxthreshold: %f, minthreshold: %f", tol, max_threshold, min_threshold );
combat.c:    //roomlogf( ch->in_room, "maxthreshold: %f, minthreshold: %f", max_threshold, min_threshold );
combat.c:        // roomlogf( ch->in_room, "health tol penalty: %d", tol_penalty);
combat.c:        // roomlogf( ch->in_room, "stun tol penalty: %d", tol_penalty);
combat.c:    return find_ex_description("[DAZED]", ch->ex_description, TRUE) != NULL;
combat.c:        combat_next = ch->next_fighting;
combat.c:           if( ch->specials.combat_wait <= 1 ) {
combat.c:               ch->specials.combat_wait += number(1, 5);
combat.c:               ch->specials.combat_wait--;
combat.c:        if (ch->specials.fighting && ch->in_room == ch->specials.fighting->in_room) {
combat.c:            if (ch->specials.combat_wait-- < 1) {
combat.c:                if ((alive = hit(ch, ch->specials.fighting, TYPE_UNDEFINED)))
combat.c:        } else if (ch->specials.alt_fighting && ch->in_room == ch->specials.alt_fighting->in_room) {
combat.c:            ch->specials.fighting = ch->specials.alt_fighting;
combat.c:            ch->specials.alt_fighting = 0;
combat.c:            if (ch->specials.combat_wait-- < 1) {
combat.c:                if ((alive = hit(ch, ch->specials.fighting, TYPE_UNDEFINED)))
combat.c:  if (ch->specials.fighting) {
combat.c:  ch->next_fighting = combat_list;
combat.c:  ch->specials.fighting = vict;
combat.c:  if( IS_SET(ch->specials.nosave, NOSAVE_COMBAT)) {
combat.c:    if (ch->specials.fighting == victim) {
combat.c:        if (ch->specials.alt_fighting) {        // Switch to the other opponent
combat.c:            ch->specials.fighting = ch->specials.alt_fighting;
combat.c:            ch->specials.alt_fighting = NULL;
combat.c:    if (ch->specials.alt_fighting == victim) {
combat.c:        ch->specials.alt_fighting = NULL;
combat.c:        if (!ch->specials.fighting)
combat.c:        combat_next = ch->next_fighting;
combat.c:        combat_list = ch->next_fighting;
combat.c:            tmp->next_fighting = ch->next_fighting;
combat.c:    ch->next_fighting = 0;
combat.c:    ch->specials.fighting = 0;
combat.c:    ch->specials.alt_fighting = 0;
combat.c:    CHAR_DATA *vict = ch->specials.fighting;
combat.c:    if (!ch->in_room)
combat.c:             MSTR(ch->specials.fighting, name));
combat.c:    send_to_monitors(ch, ch->specials.fighting, buf, MONITOR_FIGHT);
combat.c:        sprintf(buf, "%d", (npc_index + ch->nr)->vnum);
combat.c:        if (ch->player.extkwds) {
combat.c:            strcat(corpse_name, ch->player.extkwds);
combat.c:            set_obj_extra_desc_value(corpse, "[ACCOUNT_info]", ch->account);
combat.c:    custom_skin = find_ex_description("[SKIN_INFO]", ch->ex_description, TRUE);
combat.c:    custom_skin = find_ex_description("[SKIN_INFO_OVERRIDE]", ch->ex_description, TRUE);
combat.c:    sector = ch->in_room->sector_type;
combat.c:    corpse->contains = ch->carrying;
combat.c:        if (ch->equipment[i])
combat.c:    ch->carrying = 0;
combat.c:    if (ch->on_obj 
combat.c:     && (IS_SET(ch->on_obj->obj_flags.value[1], FURN_SKIMMER)
combat.c:      || IS_SET(ch->on_obj->obj_flags.value[1], FURN_WAGON))) {
combat.c:        obj_to_obj(corpse, ch->on_obj);
combat.c:        obj_to_room(corpse, ch->in_room);
combat.c:    wn = find_weather_node(ch->in_room);
combat.c:     * && ( ch->in_room != ch->in_room->direction[door]->to_room))
combat.c:     * ch->in_room->direction[door]->to_room);
combat.c:        for( rch = ch->in_room->people; rch; rch = rch->next_in_room ) {
combat.c:            && (ch->in_room != ch->in_room->direction[door]->to_room))
combat.c:            send_to_room(msg, ch->in_room->direction[door]->to_room);
combat.c:    if (IS_SET(ch->specials.affected_by, CHAR_AFF_HIDE)) {
combat.c:      REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
combat.c:    for (af = ch->affected; af; af = af->next)
combat.c:            if (IS_SET(ch->specials.act, CFL_UNDEAD)) {
combat.c:                for (tmp_object = ch->carrying; tmp_object; tmp_object = next_obj) {
combat.c:                        obj_to_room(tmp_object, ch->in_room);
combat.c:                    if (ch->equipment && ch->equipment[pos]) {
combat.c:                            obj_to_room(tmp_object, ch->in_room);
combat.c:    if (IS_NPC(ch) || IS_SET(ch->specials.act, CFL_DEAD)) {
combat.c:        if (ch->player.dead)
combat.c:            free(ch->player.dead);
combat.c:        ch->player.dead = strdup("rebirth");
combat.c:        gamelogf("%s (%s) has been newbie repopped.", GET_NAME(ch), ch->account);
combat.c:    if (has_special_on_cmd(ch->specials.programs, 0, CMD_DIE)) {
combat.c:        for (tch = character_list; tch && tch != ch; tch = tch->next) ;
combat.c:    if (!IS_NPC(ch) && ch->account && !IS_IMMORTAL(ch) 
combat.c:        if (ch->desc && ch->desc->player_info)
combat.c:            pPInfo = ch->desc->player_info;
combat.c:            if (ch->account
combat.c:             && (pPInfo = find_player_info(ch->account)) == NULL) {
combat.c:                if ((fOld = load_player_info(&d, ch->account)) == FALSE) {
combat.c:                    gamelogf("%s died with invalid account '%s'.", ch->name, ch->account);
combat.c:            real_time_passed((time(0) - ch->player.time.logon) + ch->player.time.played, 0);
combat.c:          (ch->player.dead && !strcmp(ch->player.dead, "rebirth"))) {
combat.c:            if (IS_SET(ch->specials.act, CFL_NO_DEATH)) {
combat.c:                REMOVE_BIT(ch->specials.act, CFL_NO_DEATH);
combat.c:                ch->application_status = APPLICATION_DEATH;
combat.c:                update_char_info(pPInfo, lowercase(ch->name), APPLICATION_DEATH);
combat.c:                MUD_SET_BIT(ch->specials.act, CFL_DEAD);
combat.c:    wield = ch->equipment[EP];
combat.c:        if (!miss || !IS_SET(ch->specials.brief, BRIEF_COMBAT)) {
combat.c:    return (room_in_city(ch->in_room));
combat.c:    return room_in_city(ch->in_room);
combat.c:    if (!(ch->in_room))
combat.c:    if (!(ct = room_in_city(ch->in_room))
combat.c:        || IS_SET(ch->specials.act, city[ct].c_flag))
combat.c:     * !is_greater_vassal( GET_TRIBE( victim ), ch->player.tribe,
combat.c:    if (!IS_SET(ch->in_room->room_flags, RFL_POPULATED)
combat.c:     || room_visibility(ch->in_room) < 0
combat.c:     || (IS_SET(ch->in_room->room_flags, RFL_POPULATED) 
combat.c:      && !IS_SET(ch->in_room->room_flags, RFL_INDOORS)
combat.c:        for (tch = ch->in_room->people; tch; tch = tch->next_in_room)
combat.c:            if (ch->in_room->direction[dir]
combat.c:                && (rm = ch->in_room->direction[dir]->to_room) != NULL)
combat.c:                for (tch = rm->people; tch; tch = tch->next_in_room)
combat.c:    if (TRUE == get_room_extra_desc_value(ch->in_room, "[NO_CRIM_CLANS]", buf, MAX_STRING_LENGTH)) {
combat.c:            /*      if (!(ch->skills[skill_weap_rtype[ rtype][wtype]] )) */
combat.c:    if (ch->specials.fighting) {
combat.c:    if (!merch->in_room)
combat.c:    if (merch->specials.fighting)
combat.c:                MSTR(merch->specials.fighting, name), MSTR(merch, name), merch->in_room->number);
combat.c:                merch->in_room->number);
combat.c:                (IS_SET(ch->in_room->direction[direction]->exit_info, EX_SPL_FIRE_WALL)) ?
combat.c:        if (tar_room != ch->in_room)
combat.c:                (IS_SET(ch->in_room->direction[direction]->exit_info, EX_SPL_FIRE_WALL)) ?
combat.c:        if (tar_room != ch->in_room)
combat.c:            wagobj = find_wagon_for_room(ch->in_room);
combat.c:            wagobj = find_wagon_for_room(ch->in_room);
combat.c:                            !IS_NPC(ch) ? "(" : "", !IS_NPC(ch) ? ch->account : "",
combat.c:                            !IS_NPC(ch) ? ") " : "", ch->in_room->number);
combat.c:                            !IS_NPC(ch) ? "(" : "", !IS_NPC(ch) ? ch->account : "",
combat.c:                            !IS_NPC(ch) ? ") " : "", ch->in_room->number);
combat.c:                            !IS_NPC(ch) ? "(" : "", !IS_NPC(ch) ? ch->account : "",
combat.c:                            !IS_NPC(ch) ? ") " : "", ch->in_room->number);
combat.c:                real_time_passed((time(0) - ch->player.time.logon) + ch->player.time.played,
combat.c:                    || (ch->player.dead && !strcmp(ch->player.dead, "rebirth")))
combat.c:                && !IS_SET(ch->specials.act, CFL_NO_DEATH)) {
combat.c:                if (ch->player.info[1])
combat.c:                    free(ch->player.info[1]);
combat.c:                ch->player.info[1] = strdup(buf);
combat.c:                 ch->equipment[EP], victim, TO_CHAR);
combat.c:                 ch->equipment[EP], victim, TO_VICT);
combat.c:                act(messages->god_msg.room_msg, FALSE, ch, ch->equipment[EP],
combat.c:                     ch->equipment[EP], victim, TO_CHAR);
combat.c:                     ch->equipment[EP], victim, TO_VICT);
combat.c:                     ch->equipment[EP], victim, TO_NOTVICT);
combat.c:                     ch->equipment[EP], victim, TO_CHAR);
combat.c:                     ch->equipment[EP], victim, TO_VICT);
combat.c:                     ch->equipment[EP], victim, TO_NOTVICT);
combat.c:                 ch->equipment[EP], victim, TO_CHAR);
combat.c:                 ch->equipment[EP], victim, TO_VICT);
combat.c:                 ch->equipment[EP], victim, TO_NOTVICT);
combat.c:    if (ch->specials.riding == victim) {
combat.c:    if (ch->specials.riding) {
combat.c:            /*      if( !ch->skills[SKILL_RIDE]  */
combat.c:                /*       || ( ch->skills[SKILL_RIDE] */
combat.c:                    /* && ( ( number( 1, 50 ) > ch->skills[SKILL_RIDE]->learned ) */
combat.c:                        && (number(1, 60) > ch->skills[SKILL_RIDE]->learned))))) {
combat.c:            act("$N throws you from $S back!", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
combat.c:            act("You throw $n from your back.", FALSE, ch, 0, ch->specials.riding, TO_VICT);
combat.c:            act("$N throws $n from $S back.", FALSE, ch, 0, ch->specials.riding, TO_NOTVICT);
combat.c:            ch->specials.riding = (CHAR_DATA *) 0;
combat.c:    if (ch->specials.guarding && (GET_GUILD(ch) != GUILD_WARRIOR))
combat.c:            if (!ch->specials.fighting && !is_char_ethereal(ch)
combat.c:        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
combat.c:        for (tch = victim->in_room->people; tch; tch = tch->next_in_room)
combat.c:            if (tch->specials.subduing == victim)
combat.c:            ch->specials.subduing = (CHAR_DATA *) 0;
combat.c:                tch->specials.subduing = (CHAR_DATA *) 0;
combat.c:    if ((victim != ch) && ch->in_room && victim->in_room) {
combat.c:        for (tch = victim->in_room->people; tch; tch = tch->next_in_room)
combat.c:            if (ch->specials.riding) {
combat.c:                && check_combat_gain_wait(ch, ch->abilities.off, ch->abilities.off_last_gain)) {
combat.c:                int oldsk = ch->abilities.off;
combat.c:                ch->abilities.off += 1;
combat.c:                ch->abilities.off_last_gain = time(0);
combat.c:                ch->abilities.off = MIN(ch->abilities.off, find_max_offense_for_char(ch));
combat.c:                   shhlogf("gain_skill: %s (%s) gained 1 points of skill in 'offense' (%d => %d)", MSTR(ch, name), ch->account, oldsk, ch->abilities.off);
combat.c:                ch->tmpabilities.off += 1;
combat.c:                ch->tmpabilities.off_last_gain = time(0);
combat.c:                ch->tmpabilities.off = MIN(ch->tmpabilities.off, find_max_offense_for_char(ch));
combat.c:    merciful = IS_SET(ch->specials.mercy, MERCY_KILL);
combat.c:                    if ((burnit = ch->equipment[EP])
combat.c:                    if ((burnit = ch->equipment[ES])
combat.c:                    if ((burnit = ch->equipment[ETWO])
combat.c:    if (ch->in_room != victim->in_room)
combat.c:    merciful = IS_SET(ch->specials.mercy, MERCY_KILL);
combat.c:                    !IS_NPC(ch) ? ch->account : "",
combat.c:                    ch->in_room->number);
combat.c:         && f->in_room == ch->in_room)
combat.c:    if (alive && has_special_on_cmd(ch->specials.programs, NULL, CMD_ON_DAMAGE)) {
combat.c:        for (tch = character_list; tch && tch != ch; tch = tch->next);
combat.c:        for (tch = character_list; tch && tch != victim; tch = tch->next);
combat.c:        for (tch = character_list; tch && tch != ch; tch = tch->next);
combat.c:        for (tch = character_list; tch && tch != victim; tch = tch->next);
combat.c:        for (tch = character_list; tch && tch != ch; tch = tch->next);
combat.c:        for (tch = character_list; tch && tch != victim; tch = tch->next);
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  "base: off = %d, def = %d", off, def);
combat.c:            off += ch->skills[SKILL_TWO_HANDED]->learned;
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:       || (ch->specials.subduing && (ch->specials.subduing == victim)))
combat.c:            qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:    if (ch->specials.riding) {
combat.c:         && get_char_size(victim) <= get_char_size(ch->specials.riding)
combat.c:        if (!ch->specials.riding 
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:            qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room, 
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:    if (ch->in_room != victim->in_room) {
combat.c:    if (!CAN_FIGHT(ch) && ch->specials.fighting && !CAN_FIGHT(victim)
combat.c:    if (IS_SET(ch->specials.act, CFL_FROZEN))
combat.c:    if (ch && victim && ch->in_room)
combat.c:        set_combat_tracks_in_room(ch, victim, ch->in_room);
combat.c:        qroomlogf( QUIET_COMBAT, ch->in_room, 
combat.c:    //roomlogf(ch->in_room, "%s vs %s: off %d, def %d", MSTR(ch, name), MSTR(victim, name), off, def);
combat.c:        merciful = IS_SET(ch->specials.mercy, MERCY_KILL);
combat.c:            ch->specials.combat_wait += agl_app[GET_AGL(ch)].c_delay + number(-2, 2);
combat.c:                ch->specials.combat_wait *= 2;
combat.c:            ch->specials.combat_wait = MAX(ch->specials.combat_wait, 1);
combat.c:            ch->specials.combat_wait += agl_app[GET_AGL(ch)].c_delay + number(-2, 2);
combat.c:                ch->specials.combat_wait *= 2;
combat.c:            ch->specials.combat_wait = MAX(ch->specials.combat_wait, 1);
combat.c:                qroomlogf(QUIET_COMBAT, ch->in_room, "Rolled damage: %d", dam);
combat.c:                qroomlogf(QUIET_COMBAT, ch->in_room, "Plus strength: %d", dam);
combat.c:                qroomlogf(QUIET_COMBAT, ch->in_room, "Plus Etwo: %d", dam);
combat.c:                qroomlogf(QUIET_COMBAT, ch->in_room, "Plus Two Handed: %d", dam);
combat.c:                qroomlogf(QUIET_COMBAT, ch->in_room, "Plus race: %d", dam);
combat.c:                    qroomlogf(QUIET_COMBAT, ch->in_room, "Posistion: %d", dam);
combat.c:                qroomlogf(QUIET_COMBAT, ch->in_room, 
combat.c:                qroomlogf(QUIET_COMBAT, ch->in_room, 
combat.c:                    qroomlogf( QUIET_COMBAT, ch->in_room, "mul rage: %d", dam );
combat.c:                                        ch->in_room->number, MSTR(ch, short_descr));
combat.c:                    if (((number(1, 3)) > 2) && IS_SET(ch->specials.act, CFL_CAN_POISON)) {
combat.c:    if (!alive && ch->specials.alt_fighting) {
combat.c:        victim = ch->specials.fighting = ch->specials.alt_fighting;
combat.c:        ch->specials.alt_fighting = 0;
combat.c:    } else if (ch->specials.alt_fighting) {
combat.c:        victim = ch->specials.alt_fighting;
combat.c:     && (wp_sec || (!ch->equipment[EP] && !ch->equipment[ES]
combat.c:                    && !ch->equipment[ETWO]
combat.c:            qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:            qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:                qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:            qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:            qroomlogf(QUIET_COMBAT, ch->in_room,  "vict not conscious: off = %d, def = %d", off, def);
combat.c:                qroomlogf(QUIET_COMBAT, ch->in_room,  
combat.c:        qroomlogf(QUIET_COMBAT, ch->in_room, 
combat.c:                ch->specials.combat_wait += agl_app[GET_AGL(ch)].c_delay + number(-2, 2);
combat.c:                    ch->specials.combat_wait *= 2;
combat.c:                ch->specials.combat_wait = MAX(ch->specials.combat_wait, 1);
combat.c:                ch->specials.combat_wait += agl_app[GET_AGL(ch)].c_delay + number(-5, 5);
combat.c:                    ch->specials.combat_wait *= 2;
combat.c:                    qroomlogf( QUIET_COMBAT, ch->in_room, 
combat.c:                    qroomlogf( QUIET_COMBAT, ch->in_room, 
combat.c:                    qroomlogf( QUIET_COMBAT, ch->in_room, 
combat.c:                        qroomlogf( QUIET_COMBAT, ch->in_room, 
combat.c:                    qroomlogf( QUIET_COMBAT, ch->in_room, 
combat.c:                    qroomlogf( QUIET_COMBAT, ch->in_room, 
combat.c:                            ch->in_room->number, MSTR(ch, short_descr));
combat.c:        ch->specials.combat_wait += agl_app[GET_AGL(ch)].c_delay + number(-5, 5);
combat.c:            ch->specials.combat_wait *= 2;
combat.c:        if (has_skill(ch, SKILL_TWO_HANDED) && ch->equipment[ETWO]) {
combat.c:            if (number(1, 100) <= ch->skills[SKILL_TWO_HANDED]->learned)
combat.c:                ch->specials.combat_wait -= (ch->specials.combat_wait * MIN(60, number(0, ch->skills[SKILL_TWO_HANDED]->learned)) / 100);  
combat.c:                        int wait = ch->specials.act_wait;
combat.c:                            ch->specials.act_wait = wait;
combat.c:                    && IS_SET(ch->specials.affected_by, CHAR_AFF_FLYING)
combat.c:    if (-1 == generic_searcher(ch->in_room, find_closest_hates_fun, &fc, max_dist, FALSE, ch))
combat.c:    if (is_shield(ch->equipment[EP]))
combat.c:    else if (is_shield(ch->equipment[ES]))
combat.c:    else if (is_shield(ch->equipment[ETWO]))
combat.c:        if (is_shield(ch->equipment[EP]))
combat.c:        else if (is_shield(ch->equipment[ES]))
combat.c:        else if (is_shield(ch->equipment[ETWO]))
combat.c:    if (!AWAKE(ch) || IS_SET(ch->specials.act, CFL_FROZEN)) {
combat.c:                      (ch->master == victim)) {
combat.c:                    if ((ch->specials.riding) && (ch->specials.riding == victim)) {
combat.c:                        && !ch->specials.fighting && (victim != ch->specials.fighting)) {
combat.c:                            && ch->specials.fighting == victim) {
combat.c:        org_room = ch->in_room;
combat.c:        for (k = ch->followers; k; k = k->next) {
combat.c:  if (ch->specials.subduing) {
combat.c:    for (tch = ch->in_room->people; tch; tch = tch->next_in_room) {
combat.c:      if (tch == ch->specials.subduing) {
combat.c:      ch->specials.subduing = (CHAR_DATA *) 0;
combat.c:      REMOVE_BIT(tch->specials.affected_by, CHAR_AFF_SUBDUED);
combat.c:  for (tch = ch->in_room->people; tch; tch = tch->next_in_room) {
combat.c:    if (tch->specials.subduing == ch) {
combat.c:        ct = room_in_city(tch->in_room);
combat.c:            IS_SET(ch->specials.act, city[ct].c_flag)) {
combat.c:          for (af = ch->affected; af; af = af->next) {
combat.c:          if (IS_SET(ch->specials.nosave, NOSAVE_ARREST)) {
combat.c:        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_SUBDUED);
combat.c:        tch->specials.subduing = (CHAR_DATA *) 0;
combat.c:        ct = room_in_city(tch->in_room);
combat.c:            IS_SET(ch->specials.act, city[ct].c_flag)) {
combat.c:          for (af = ch->affected; af; af = af->next) {
combat.c:          if (IS_SET(ch->specials.nosave, NOSAVE_ARREST)) {
combat.c:  if (ch->in_room->sector_type != SECT_SILT) {
combat.c:  if ((!(ch->specials.fighting) || GET_POS(ch) != POSITION_FIGHTING) && 
combat.c:  if (ch->specials.riding) {
combat.c:    if ((number(1, 100) > ch->skills[SKILL_RIDE]->learned) ||
combat.c:         (number(1, 70) > ch->skills[SKILL_RIDE]->learned))) {
combat.c:    GET_SPEED(ch->specials.riding) = SPEED_RUNNING;
combat.c:  wagon = find_exitable_wagon_for_room(ch->in_room);
combat.c:      for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
combat.c:        if ((rch->specials.fighting != ch &&
combat.c:             rch->specials.alt_fighting != ch) ||
combat.c:            IS_SET(rch->specials.mercy, MERCY_FLEE)) {
combat.c:      old_room = ch->in_room;
combat.c:        if (ch && ch->specials.fighting)
combat.c:          if (ch->specials.fighting || GET_POS(ch) == POSITION_FIGHTING) {
combat.c:            for (tch = ch->in_room->people; tch; tch = tch->next_in_room) {
combat.c:              if (tch->specials.fighting == ch ||
combat.c:                  tch->specials.alt_fighting == ch) {
combat.c:        if (ch->skills[SKILL_FLEE]) {
combat.c:        if (ch && ch->specials.fighting)
combat.c:          if (ch->specials.fighting || GET_POS(ch) == POSITION_FIGHTING) {
combat.c:            for (tch = old_room->people; tch; tch = tch->next_in_room) {
combat.c:              if (tch->specials.fighting == ch ||
combat.c:                  tch->specials.alt_fighting == ch) {
combat.c:    if (ch->master)
combat.c:    for (k = ch->followers; k; k = j) {
comm.c:            /*      if (ch->skills[spoken_language]) */
comm.c:            j = ch->skills[spoken_language]->learned;
comm.c:    if ((has_skill(tar_ch, spoken_language)) && (tar_ch->skills[spoken_language]->learned > 0))
comm.c:        j = (tar_ch->skills[spoken_language]->learned);
comm.c:            /*      if (ch->skills[PSI_CONTACT]) */
comm.c:            j = ch->skills[PSI_CONTACT]->learned;
comm.c:            /*      if (tar_ch->skills[PSI_CONTACT]) */
comm.c:            j = tar_ch->skills[PSI_CONTACT]->learned;
comm.c:    send_to_room_ex_parsed(ch, vict, ch->in_room, message, FALSE, FALSE, 0, 0);
comm.c:    send_to_room_ex_parsed(ch, vict, ch->in_room, message, FALSE, TRUE, skillMod, opposingSkill);
comm.c:    send_hidden_to_room_parsed(ch, ch->in_room, message, FALSE, skillmod, opposingSkill);
comm.c:    send_to_room_parsed(ch, ch->in_room, message, FALSE);
comm.c:    for (rch = room->people; rch; rch = rch->next_in_room) {
comm.c:        gprintf(NULL, ch->in_room, "$csc attempt$cy to mumble something.\n", ch, ch);
comm.c:        gprintf(NULL, ch->in_room, "$csc babble$cy incoherently.\n", ch, ch);
comm.c:        for (lis = ch->in_room->people; lis; lis = lis->next_in_room) {
comm.c:            if (ch->in_room->direction[j] && (room = ch->in_room->direction[j]->to_room)
comm.c:        for (tmp_wlist = ch->in_room->watched_by; tmp_wlist; tmp_wlist = tmp_wlist->next_watched_by) {
comm.c:        gprintf(NULL, ch->in_room, "$csc attempt$cy to mumble something.\n", ch, ch);
comm.c:        gprintf(NULL, ch->in_room, "$csc babble$cy incoherently.\n", ch, ch);
comm.c:             !IS_SET( ch->specials.brief, BRIEF_SONGS ) ? out_parsed : out );
comm.c:        for (lis = ch->in_room->people; lis; lis = lis->next_in_room) {
comm.c:            if (ch->in_room->direction[j] && (room = ch->in_room->direction[j]->to_room)
comm.c:        for (tmp_wlist = ch->in_room->watched_by; tmp_wlist; tmp_wlist = tmp_wlist->next_watched_by) {
comm.c:        gprintf(NULL, ch->in_room, "$csc attempt$cy to mumble something.\n", ch, ch);
comm.c:        gprintf(NULL, ch->in_room, "$csc babble$cy incoherently.\n", ch, ch);
comm.c:             !IS_SET( ch->specials.brief, BRIEF_SONGS ) ? out_parsed : out );
comm.c:        for (lis = ch->in_room->people; lis; lis = lis->next_in_room) {
comm.c:            if (ch->in_room->direction[j] && (room = ch->in_room->direction[j]->to_room)
comm.c:        for (tmp_wlist = ch->in_room->watched_by; tmp_wlist; tmp_wlist = tmp_wlist->next_watched_by) {
comm.c:    for (lis = ch->in_room->people; lis; lis = lis->next_in_room) {
comm.c:        if (ch->in_room->direction[j] && (room = ch->in_room->direction[j]->to_room)
comm.c:        for (tmp_wlist = ch->in_room->watched_by; tmp_wlist; tmp_wlist = tmp_wlist->next_watched_by) {
comm.c:        gprintf(NULL, ch->in_room, "$csc babble$cy incoherently.\n", ch, ch);
comm.c:        if( !IS_SET(ch->specials.brief, BRIEF_OOC) ) {
comm.c:        for (lis = ch->in_room->people; lis; lis = lis->next_in_room) {
comm.c:    for (tmp_obj = ch->in_room->contents; tmp_obj; tmp_obj = tmp_obj->next_content) {
comm.c:    tmp_obj = object_list_find_by_func(is_wagon_with_audible_room, (void *)(long)ch->in_room->number);
comm.c:        if (ch->in_room->direction[exit]) {
comm.c:            for (listener = ch->in_room->direction[exit]->to_room->people; listener;
comm.c:    for (listener = ch->in_room->people; listener; listener = listener->next_in_room) {
comm.c:        for (tmp_wlist = ch->in_room->watched_by; tmp_wlist; tmp_wlist = tmp_wlist->next_watched_by) {
comm.c:        gprintf(NULL, ch->in_room, "$csc babble$cy incoherently.\n", ch, ch);
comm.c:        gprintf(NULL, ch->in_room, "$csc babble$cy incoherently.\n", ch, ch);
comm.c:        for (tch = ch->in_room->people; tch; tch = tch->next_in_room) {
comm.c:                && !tch->specials.fighting
comm.c:                        if (tch->master && has_skill(tch, SKILL_LISTEN)
comm.c:                            && ((ch == tch->master) || (vict == tch->master)))
comm.c:                            percent -= tch->skills[SKILL_LISTEN]->learned / 10;
comm.c:                        && (percent <= (tch->skills[SKILL_LISTEN]->learned / 3))) {
comm.c:        for (tmp_wlist = ch->in_room->watched_by; tmp_wlist; tmp_wlist = tmp_wlist->next_watched_by) {
comm.c:    for (lis = ch->in_room->people; lis; lis = lis->next_in_room) {
comm.c:    if (!ch->desc)
comm.c:    if (!(paper = get_obj_in_list_vis(ch, papername, ch->carrying))) {
comm.c:    if (!(pen = ch->equipment[ES])) {
comm.c:    if (!ch->desc)
comm.c:    if ((!IS_IMMORTAL(ch) && !ch->desc->original)
comm.c:        || (ch->desc && ch->desc->original && !IS_IMMORTAL(ch->desc->original))) {
comm.c:        pCh = (ch->desc->original && IS_IMMORTAL(ch->desc->original)) ? ch->desc->original : ch;
comm.c:    if (ch->specials.il > 3 && invis_warn)
comm.c:            if (room_limited && d->character->in_room != ch->in_room )
comm.c:                            npc_index[ch->nr].vnum,
comm.c:    if (IS_SET(ch->specials.act, CFL_NOWISH)) {
comm.c:        if (!ch->account) {
comm.c:            GET_NAME(ch), ch->in_room->number, ch->in_room->name, mesg);
comm.c:            GET_NAME(ch), ch->account, ch->in_room->number, ch->in_room->name, mesg);
comm.c:        if (!ch->account) {
comm.c:                GET_NAME(ch), ch->in_room->number, ch->in_room->name, mesg);
comm.c:                GET_NAME(ch), ch->account, ch->in_room->number, ch->in_room->name, mesg);
comm.c:    if (IS_SET(ch->specials.act, CFL_NOWISH)) {
comm.c:    for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room) {
comm.c:	        ts_num = tar_ch->skills[PSI_THOUGHTSENSE]->learned;
comm.c:                emp_num = tar_ch->skills[PSI_EMPATHY]->learned;
comm.c:	    for (psi = tar_ch->in_room->people; psi; psi = psi->next_in_room) {
comm.c:    for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room) {
comm.c:            if (tar_ch->specials.contact == ch)
comm.c:                emp_num = tar_ch->skills[PSI_EMPATHY]->learned;
comm.c:	    for (psi = tar_ch->in_room->people; psi; psi = psi->next_in_room) {
comm.c:            && ch->skills[accent_table[i].skillnum]->learned >= MIN_ACCENT_LEVEL) {
comm.c:    if ((has_skill(ch, j) && ch->skills[j]->learned >= MIN_LANG_LEVEL)
comm.c:        && (ch->skills[language]->learned >= MIN_LANG_LEVEL)
comm.c:        && (ch->skills[language]->learned > lis->skills[language]->learned)
comm.c:        && has_skill(ch, accent) && ch->skills[accent]->learned >= MIN_ACCENT_LEVEL) {
comm.c:            && (ch->skills[accent]->learned > lis->skills[accent]->learned)
comm.c:                 arg2, counter, npc_index[ch->nr].vnum);
constants.c:    "petoch-wine",
db.c:    ch->prev = (CHAR_DATA *) 0;
db.c:    ch->next = character_list;
db.c:    if (ch->next)
db.c:        ch->next->prev = ch;
db.c:    if (ch->prev)
db.c:        ch->prev->next = ch->next;
db.c:    if (ch->next)
db.c:        ch->next->prev = ch->prev;
db.c:        character_list = ch->next;
db.c:    if (lookup_char_info(ch->desc->player_info, ch->name))
db.c:        update_char_info(ch->desc->player_info, ch->name, APPLICATION_ACCEPT);
db.c:        add_new_char_info(ch->desc->player_info, ch->name, APPLICATION_ACCEPT);
db.c:    ch->application_status = APPLICATION_ACCEPT;
db.c:    save_player_info(ch->desc->player_info);
db.c:    if (ch->account) free(ch->account);
db.c:    ch->account = strdup(ch->desc->player_info->name);
db.c:    sprintf(fn, "%s %s\n", ch->desc->player_info->name, buf);
db.c:        if (ch->prev)
db.c:            ch->prev->next = ch->next;
db.c:        if (ch->next)
db.c:            ch->next->prev = ch->prev;
db.c:            character_list = ch->next;
db.c:    free(ch->name);
db.c:    free(ch->short_descr);
db.c:    free(ch->long_descr);
db.c:    free(ch->player.extkwds);
db.c:    free(ch->description);
db.c:    free(ch->last_prompt);
db.c:    if( ch->temp_description)
db.c:        free(ch->temp_description);
db.c:        if (ch->player.info[i])
db.c:            free(ch->player.info[i]);
db.c:    for (clan = ch->clan; clan; clan = nextclan) {
db.c:    free(ch->account);
db.c:    free(ch->player.poofin);
db.c:    free(ch->player.poofout);
db.c:    free(ch->player.prompt);
db.c:    if ((ch->background)
db.c:            || ((ch->nr >= 0) && (ch->nr < top_of_npc_t)
db.c:                && (ch->background != npc_default[ch->nr].background)))) {
db.c:        free(ch->background);
db.c:    free(ch->player.dead);
db.c:    free(ch->player.deny);
db.c:        if (ch->skills[i])
db.c:            free(ch->skills[i]);
db.c:    for (pCmd = ch->granted_commands; pCmd; pCmd = pCmdNext) {
db.c:    for (pCmd = ch->revoked_commands; pCmd; pCmd = pCmdNext) {
db.c:    free_specials(ch->specials.programs);
db.c:    free_edesc_list(ch->ex_description);
db.c:        ch->equipment[i] = 0;
db.c:    ch->followers = 0;
db.c:    ch->guards = 0;
db.c:    ch->master = 0;
db.c:    ch->obj_master = 0;
db.c:    ch->carrying = 0;
db.c:    ch->next = 0;
db.c:    ch->next_fighting = 0;
db.c:    ch->next_in_room = 0;
db.c:    ch->specials.fighting = 0;
db.c:    ch->queued_commands = 0;
db.c:    ch->specials.default_pos = POSITION_STANDING;
db.c:    ch->specials.carry_items = 0;
db.c:    ch->old.hp = GET_HIT(ch);
db.c:    ch->old.max_hp = GET_MAX_HIT(ch);
db.c:    ch->old.stun = GET_STUN(ch);
db.c:    ch->old.max_stun = GET_MAX_STUN(ch);
db.c:    ch->old.mana = GET_MANA(ch);
db.c:    ch->old.max_mana = GET_MAX_MANA(ch);
db.c:    ch->old.move = GET_MOVE(ch);
db.c:    ch->old.max_move = GET_MAX_MOVE(ch);
db.c:    ch->logged_in = FALSE;
db.c:    ch->in_room = (ROOM_DATA *) 0;
db.c:    ch->saved_room = -1;
db.c:    ch->logged_in = FALSE;
db.c:    ch->queued_commands = NULL;
db.c:    ch->specials.was_in_room = (ROOM_DATA *) 0;
db.c:    ch->specials.default_pos = POSITION_STANDING;
db.c:    ch->points.max_hit = 75 + GET_END(ch) + number(1, 10);
db.c:        ch->points.max_hit += dice(2, 4);
db.c:        ch->points.max_hit += 20 + number(1, 8);
db.c:    ch->points.max_stun = 75 + GET_END(ch) + number(1, 10);
db.c:        ch->points.max_stun += dice(2, 4);
db.c:        ch->points.max_stun += 20 + number(1, 8);
db.c:    ch->player.time.starting_time = time(0);
db.c:    ch->player.time.played = 0;
db.c:    ch->player.time.logon = time(0);
db.c:    if (ch->player.hometown != CITY_NONE
db.c:        ch->player.hometown = CITY_NONE;
db.c:    ch->abilities.armor = race[(int) GET_RACE(ch)].natural_armor;
db.c:        ch->abilities.off = guild[(int) GET_GUILD(ch)].off_bonus;
db.c:        ch->abilities.off_last_gain = time(0);
db.c:        ch->abilities.def = guild[(int) GET_GUILD(ch)].def_bonus;
db.c:        ch->abilities.def_last_gain = time(0);
db.c:    ch->specials.eco = 0;
db.c:    if ((ch->player.tribe < 0) || (ch->player.tribe >= MAX_CLAN))
db.c:        ch->player.tribe = 0;
db.c:    ch->player.luck = 0;
db.c:    ch->specials.affected_by = 0;
db.c:    ch->specials.to_process = FALSE;
db.c:        ch->specials.apply_saving_throw[i] = 0;
db.c:        head_object = ch->carrying;
db.c:            char_to_room(npc, ch->in_room);
db.c:            ch->specials.riding = npc;
db.c:            && !ch->equipment[object.eq_pos]) {
db.c:    if (!recursive_char_objs_to_store(ch->carrying, ch, fp, -1)) {
db.c:        if (ch->equipment[j])
db.c:            if (!recursive_char_objs_to_store(ch->equipment[j], ch, fp, j)) {
db.c:    if( IS_NPC(ch) || ch->logged_in == TRUE || !ch->desc) return;
db.c:    save_login_information( GET_NAME(ch), ch->account, ch->desc->host);
db.c:    ch->logged_in = TRUE;
db.c:    if(IS_NPC(ch) || ch->logged_in == FALSE) return;
db.c:    save_logout_information(GET_NAME(ch), ch->account);
db.c:    ch->logged_in = FALSE;
delay.c:            ch->specials.to_process = TRUE;
delay.c:            ch->specials.to_process = FALSE;
delay.c:            ch->specials.to_process = FALSE;
delay.c:        d->timeout = MAX(1, (75 - ch->abilities.off) / 5);
delay.c:        if (find_ex_description("[NO_CAST_MESSAGE]", ch->ex_description, TRUE)) {
delay.c:       cast_msg_self = find_ex_description("[CAST_MESSAGE_SELF]", ch->ex_description, TRUE);
delay.c:       cast_msg_room = find_ex_description("[CAST_MESSAGE_ROOM]", ch->ex_description, TRUE);
delay.c:       cast_msg_ldesc = find_ex_description("[CAST_MESSAGE_LDESC]", ch->ex_description, TRUE);
delay.c:            if (ch->player.hometown == CITY_ALLANAK) {
delay.c:            } else if (ch->player.hometown == CITY_TULUK) {
delay.c:            } else if (ch->player.hometown == CITY_MAL_KRIAN) {
delay.c:            if (ch->player.hometown == CITY_ALLANAK) {
delay.c:            } else if (ch->player.hometown == CITY_TULUK) {
delay.c:            } else if (ch->player.hometown == CITY_MAL_KRIAN) {
delay.c:             room_in_city(ch->in_room) == CITY_TULUK) {
delay.c:           int delay = MAX(skill_delay(ch->skills[spell]->learned), 3);
delay.c:           d->timeout = skill_delay(ch->skills[spell]->learned);
delay.c:              room_in_city(ch->in_room) == CITY_TULUK) {
delay.c:            int delay = MAX(skill_delay(ch->skills[spell]->learned), 3);
delay.c:            d->timeout = skill_delay(ch->skills[spell]->learned);
delay.c:        if (!ch->specials.alt_fighting)
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_SPLIT_OPPONENTS]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[PSI_REJUVENATE]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_HIDE]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_BACKSTAB]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_SAP]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_PICK_LOCK]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_SLEIGHT_OF_HAND]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_SLEIGHT_OF_HAND]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_SLEIGHT_OF_HAND]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_SLEIGHT_OF_HAND]->learned);
delay.c:        d->timeout = skill_delay(ch->skills[SKILL_SLEIGHT_OF_HAND]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_SLEIGHT_OF_HAND]->learned);
delay.c:                d->timeout = skill_delay(ch->skills[SKILL_STEAL]->learned);
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_HUNT]->learned);
delay.c:            /* if (ch->skills[SKILL_ARCHERY]) */
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_ARCHERY]->learned);
delay.c:        if (ch->specials.subduing) {
delay.c:            /* if (ch->skills[SKILL_THROW]) */
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_THROW]->learned);
delay.c:            /* if (ch->skills[SKILL_SEARCH]) */
delay.c:            d->timeout = skill_delay(ch->skills[SKILL_SEARCH]->learned);
delay.c:        d->timeout = ch->specials.act_wait / WAIT_SEC;
delay.c:        ch->specials.act_wait = 0;
delay.c:                /* if (ch->skills[SKILL_FORAGE]) */
delay.c:                d->timeout = skill_delay(ch->skills[SKILL_FORAGE]->learned);
disease.c:    if (ch->affected)
disease.c:        for (aff_node = ch->affected; aff_node; aff_node = aff_node->next)
disease.c:        resist_chance += ch->specials.eco / 2;
disease.c:        resist_chance += ch->specials.eco / 2;
disease.c:        || (IS_SET(ch->specials.act, CFL_UNDEAD))
disease.c:    switch (ch->in_room->sector_type) {
disease.c:    switch (ch->in_room->sector_type) {
disease.c:    if (!ch || !ch->in_room)
disease.c:    struct weather_node *wn = find_weather_node(ch->in_room);
disease.c:        && (!IS_SET(ch->in_room->room_flags, RFL_INDOORS))
disease.c:        && (!IS_SET(ch->in_room->room_flags, RFL_RESTFUL_SHADE))
disease.c:        && (!IS_SET(ch->in_room->room_flags, RFL_DARK))
disease.c:            && ((ch->in_room->sector_type == SECT_GRASSLANDS)
disease.c:                || (ch->in_room->sector_type == SECT_LIGHT_FOREST)
disease.c:                || (ch->in_room->sector_type == SECT_HEAVY_FOREST))) {
disease.c:        if (IS_SET(ch->in_room->room_flags, RFL_INDOORS)) {
disease.c:        if (IS_SET(ch->in_room->room_flags, RFL_RESTFUL_SHADE)) {
dmpl.c:    dist = choose_exit_name_for(ch->in_room, (ROOM_DATA *) val[1]->ptr, command, 100, ch);
dmpl.c:    for (af = ch->affected; af; af = af->next) {
dmpl.c:    sprint_flag(ch->specials.affected_by, affect_flag, buf);
dmpl.c:    if ((n < 32) && IS_SET(ch->specials.act, char_flag[n].bit))
dmpl.c:    for (rch = rm->people; rch; rch = rch->next_in_room) {
dmpl.c:    rm = ch->in_room;
dmpl.c:    for (rch = rm->people; rch; rch = rch->next_in_room) {
dmpl.c:    for (rch = ch1->in_room->people; rch; rch = rch->next_in_room) {
dmpl.c:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
dmpl.c:    for (rch = ch1->in_room->people; rch; rch = rch->next_in_room) {
dmpl.c:    if (!ch->desc || var_list)
dmpl.c:    chdir(ch->desc->path);
event.c:        path_from_to_for(ev->ch->in_room, ev->room, ev->extra, MAX_INPUT_LENGTH, buffer, ev->ch)) {
event.c:                next_ch = tar_ch->next_in_room;
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:            next = tar_ch->next_in_room;
event.c:                        !IS_NPC(tar_ch) ? tar_ch->account : "", !IS_NPC(tar_ch) ? ") " : "",
event.c:                        tar_ch->in_room->number);
event.c:                        real_time_passed((time(0) - tar_ch->player.time.logon) +
event.c:                                         tar_ch->player.time.played, 0);
event.c:                         || (tar_ch->player.dead && !strcmp(tar_ch->player.dead, "rebirth")))
event.c:                        && !IS_SET(tar_ch->specials.act, CFL_NO_DEATH)) {
event.c:                        if (tar_ch->player.info[1])
event.c:                            free(tar_ch->player.info[1]);
event.c:                        tar_ch->player.info[1] = strdup(buf);
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:            for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:        for (tar_ch = ev->tar_obj->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:    for (ch = character_list; ch; ch = ch->next) {
event.c:                    for (tar_ch = ev->room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:                    for (tar_ch = ev->room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:                    for (tar_ch = ev->room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:                    for (tar_ch = ev->room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:                    for (tar_ch = ev->room->people; tar_ch; tar_ch = tar_ch->next_in_room)
event.c:    if (!ev->ch || !has_special_on_cmd(ev->ch->specials.programs, NULL, CMD_PULSE))
event.c:    if (!ev->ch || !IS_NPC(ev->ch) || (ev->ch->master) || (ev->ch->desc)
event.c:        || IS_SET(ev->ch->specials.act, CFL_SENTINEL))
event.c:    if ((in_room = ev->ch->in_room) == NULL) {
event.c:        gamelogf("Tried to move character not in a room: %d - %s", ev->ch->nr, MSTR(ev->ch, name));
event.c:    if (IS_DARK(ev->ch->in_room))
event.c:        && (!IS_SET(ev->ch->specials.act, CFL_STAY_ZONE)
event.c:    if (ch->points.in_bank <= 0) {
event.c:        ch->points.in_bank = 0;
event.c:    rate = 0.0125 * (MAX(0, ch->points.in_bank - 10000) * 0.0002);
event.c:    amount = (ch->points.in_bank * rate);
event.c:    ch->points.in_bank -= amount;
event.c:    for (fch = ch->followers; fch; fch = fch->next) {
event.c:        if (!IS_NPC(fch->follower) && fch->follower->in_room == ch->in_room)
event.c:            follower_save(fch->follower);
event.c:    if (!ev->ch || IS_NPC(ev->ch) || !ev->ch->account || !ev->ch->in_room || ev->ch->specials.was_in_room ||        /* don't save voided ppl */
event.c:        (ev->ch->desc && ev->ch->desc->connected))
event.c:    sprintf(buf, "Saving %s from event.c, #%d.", MSTR(ev->ch, name), ev->ch->in_room->number);
event.c:    if (!ev->ch->master || (ev->ch->master && ev->ch->master->in_room != ev->ch->in_room))
event.c:        for (fch = ev->ch->followers; fch; fch = fch->next)
event.c:            if (!IS_NPC(fch->follower)
event.c:                && fch->follower->in_room == ev->ch->in_room)
event.c:                follower_save(fch->follower);
event.c:    if (IS_SET(ch->specials.act, CFL_MOUNT))
event.c:    if (ch->specials.fighting)
event.c:     * if (!ev->ch || !IS_SET(ev->ch->specials.act, CFL_MOUNT)) 
event.c:        ev->ch->specials.regenerating = 1;
event.c:        ev->ch->specials.regenerating = 0;
event.c:    if (npc_default[ev->ch->nr].obsidian > GET_OBSIDIAN(ev->ch)) {
event.c:            MIN(npc_default[ev->ch->nr].obsidian, GET_OBSIDIAN(ev->ch) + ev->extra);
event.c:        if ((event_random_moving) || (ch->specials.regenerating))
event.c:            //      if (ch->specials.regenerating)
event.c:            ch->specials.regenerating = 1;
event.c:                        path_from_to_for(ev->ch->in_room, ev->room, ev->extra, 256, tmp2, ev->ch));
files.c:   if (!strcmp(ch->desc->path, MUD_DIR) && !strcmp(dname, ".."))
files.c:   if (!strcmp(ch->desc->path, IMMORT_DIR) && !strcmp(dname, ".."))
files.c:    if (-1 == stat(ch->desc->path, &buf)) {
files.c:    if (ch->player.level == OVERLORD)
files.c:    if (get_file_owner_name(owner, ch->desc->path, file))
files.c:/* returns true if ch->desc->path is under 
files.c:    char new_path[256];         /* resolved ch->desc->path */
files.c:    if (!ch->desc->path) {
files.c:        strcpy(ch->desc->path, default_path());
files.c:    if (!is_safe_path(ch->desc->path)) {
files.c:        warning_logf("%s tried to %s unsafe path %s", MSTR(ch, name), ch->desc->path,
files.c:        strcpy(old_path, ch->desc->path);
files.c:        sprintf(new_path, "%s/%s", ch->desc->path, file);
files.c:                         ch->desc->path, fn);
files.c:    if (!ch->desc)
files.c:    sprintf(fn, "%s/%s", ch->desc->path, buf);
files.c:    if (!(ch->desc->editing = fopen(fn, "w"))) {
files.c:    fprintf(ch->desc->editing, "\"%s %d %d %d\"\n\r\n\r", MSTR(ch, name), ch->player.level,
files.c:            ch->specials.uid, ch->specials.group);
files.c:    if (!ch->desc)
files.c:    sprintf(fn, "%s/%s", ch->desc->path, buf);
files.c:    if (!ch->desc)
files.c:    sprintf(buf, "Directory: %s\n\r", ch->desc->path);
files.c:    if (!(dp = opendir(ch->desc->path))) {
files.c:    if (!ch->desc)
files.c:    sprintf(fn, "%s/%s", ch->desc->path, buf);
files.c:    page_string(ch->desc, list, 1);
files.c:        strcpy(ch->desc->path, default_path());
files.c:        cprintf(ch, "Changing to users directory.\n\rpath = %s\n\r", ch->desc->path);
files.c:    sprintf(dir, "%s/%s", ch->desc->path, buf);
files.c:        sprintf(ch->desc->path, "%s", default_path());
files.c:    strcpy(ch->desc->path, dir);
forage.c:    if (forage_items[i].sector == ch->in_room->sector_type) {
forage.c:  if (get_room_extra_desc_value(ch->in_room, "[CUSTOM_FORAGE]", forage_edesc, sizeof(forage_edesc))) {
forage.c:  if (ch->in_room)
forage.c:      switch (ch->in_room->sector_type)
forage.c:      for (obj_object = ch->carrying; obj_object; obj_object = next_obj) {
forage.c:	      obj_to_artifact_cache (obj_object, ch->in_room);
forage.c:	      sprintf(msg, "%s buries %s in room #%d.\n\r", MSTR(ch, name), OSTR(obj_object, short_descr), ch->in_room->number);
forage.c:      obj_to_artifact_cache(obj_object, ch->in_room);
forage.c:      sprintf(msg, "%s buries %s in room #%d.\n\r", MSTR(ch, name), OSTR(obj_object, short_descr), ch->in_room->number);
forage.c:    if (!ch->in_room)
forage.c:    if (ch->specials.riding) {
forage.c:    if (((IS_DARK(ch->in_room)) || (visibility(ch) <= 0))
forage.c:    if (ch->specials.fighting) {
forage.c:    if (IS_SET(ch->in_room->room_flags, RFL_NO_FORAGE)) {
forage.c:    artifact_cache = find_artifact_cache(ch->in_room);
forage.c:    if (count_forage_matches(type, ch->in_room->sector_type) == 0 &&
forage.c:    chance += get_forage_bonus(type, ch->in_room->sector_type);
forage.c:    roomlogf(ch->in_room, "forage_flags: %s, roll: %d", get_forage_flagname(forage_flags), roll);
forage.c:      qgamelogf(QUIET_DEBUG, "skill_forage: extracting %s for %s in room %d.\n\r", OSTR(found, short_descr), MSTR(ch, name), ch->in_room->number);
forage.c:    vnum = get_forage_item(type, ch->in_room->sector_type, forage_flags, ch->in_room);
forage.c:      obj_to_room(found, ch->in_room);
gmenu.c:        if (ch->description && strlen(ch->description) > 0) {
gmenu.c:            if (ch->description)
gmenu.c:                ch->description[0] = '\0';
gmenu.c:                ch->description = strdup("");
gmenu.c:        if (ch->short_descr)
gmenu.c:            ch->short_descr[0] = '\0';
gmenu.c:        if (!ch->clan || GET_RACE(ch) != RACE_MUL) {
gmenu.c:        remove_clan(ch, ch->clan->clan);
gmenu.c:        if (ch->short_descr == NULL || ch->short_descr[0] == '\0') {
gmenu.c:        } else if (ch->name == NULL || ch->name[0] == '\0') {
gmenu.c:        } else if (ch->description == NULL || ch->description[0] == '\0') {
gmenu.c:        } else if (ch->player.race == -1) {
gmenu.c:        } else if (ch->player.sex == 0) {
gmenu.c:        } else if (GET_RACE(ch) == RACE_DWARF && ch->player.info[1] == '\0') {
gmenu.c:    sprintf(buf, "\n\rName: %-32s\n\r", ch->name);
gmenu.c:            ch->player.race == -1 ? "(none given)" : race[ch->player.race].name,
gmenu.c:            ch->player.sex == SEX_FEMALE ? "Female" : ch->player.sex ==
gmenu.c:            ch->player.guild <= GUILD_NONE ? "(none given)" : guild[(int) ch->player.guild].name);
gmenu.c:    if (ch->player.sub_guild > 0) {
gmenu.c:                ch->player.sub_guild <= SUB_GUILD_NONE ? "(none given)" : sub_guild[(int) ch->player.sub_guild].name);
gmenu.c:    if (ch->clan) {
gmenu.c:        sprintf(buf2, "Tribe: %-15s\n\r", clan_table[ch->clan->clan].name);
gmenu.c:    sprintf(buf2, "Height: %d (inches)  Weight: %d (ten-stone)  Age: %d\n\r", ch->player.height,
gmenu.c:            ch->player.weight, ch->player.time.starting_age);
gmenu.c:    sprintf(buf2, "Origin City: %s\n\r", city[ch->player.hometown].name);
gmenu.c:    if (ch->player.hometown == CITY_TULUK) {
gmenu.c:    sprintf(buf2, "Short Description: %s\n\r", ch->short_descr == NULL
gmenu.c:            || ch->short_descr[0] == '\0' ? "(none given)" : ch->short_descr);
gmenu.c:    sprintf(buf2, "Main Description:\n\r%s\n\r", ch->description == NULL
gmenu.c:            || ch->description[0] == '\0' ? "(none given)" : ch->description);
gmenu.c:        sprintf(buf2, "Objective:\n\r%s\n\r", ch->player.info[1]);
gmenu.c:    if (ch->player.hometown == CITY_TULUK) {
gmenu.c:    if (ch->short_descr == NULL || ch->short_descr[0] == '\0' || ch->description == NULL
gmenu.c:        || ch->description[0] == '\0' || ch->name == NULL || ch->name[0] == '\0'
gmenu.c:        || ch->player.race == -1 || ch->player.sex == 0) {
gmenu.c:        else if (ch->player.hometown == CITY_TULUK)
gmenu.c:        else if (ch->player.hometown == CITY_TULUK)
handler.c:        obj_to_room(coins, ch->in_room);
handler.c:    if (IS_SET(ch->specials.nosave, NOSAVE_MAGICK))
handler.c:    save_target = ch->specials.apply_saving_throw[save_type];
handler.c:        if (IS_SET(tar_ch->specials.nosave, NOSAVE_SKILLS))
handler.c:    if (isname(arg, tar_ch->player.extkwds))
handler.c:    if (isname(arg, MSTR(tar_ch, name)) || isname(arg, tar_ch->player.extkwds)
handler.c:        || isallname(arg, tar_ch->player.extkwds)
handler.c:        MUD_SET_BIT(ch->specials.affected_by, bitv);
handler.c:        REMOVE_BIT(ch->specials.affected_by, bitv);
handler.c:        ch->points.mana_bonus += mod;
handler.c:        ch->points.max_hit += mod;
handler.c:        ch->points.max_stun += mod;
handler.c:        ch->points.move_bonus += mod;
handler.c:        ch->specials.apply_saving_throw[0] += mod;
handler.c:        ch->specials.apply_saving_throw[1] += mod;
handler.c:        ch->specials.apply_saving_throw[2] += mod;
handler.c:        ch->specials.apply_saving_throw[3] += mod;
handler.c:        ch->specials.apply_saving_throw[4] += mod;
handler.c:            MUD_SET_BIT(ch->specials.act, mod);
handler.c:            REMOVE_BIT(ch->specials.act, -mod);
handler.c:        if (ch->equipment[i] 
handler.c:                ch->equipment[i]->affected[j].location, 
handler.c:                ch->equipment[i]->affected[j].modifier );
handler.c:    for (af = ch->affected; af; af = af->next)
handler.c:        if ((ch->equipment[i]) && (i != WEAR_ON_BACK) && (i != WEAR_BACK) && (i != WEAR_ON_BELT_1)
handler.c:                affect_modify(ch, ch->equipment[i]->affected[j].location,
handler.c:                              ch->equipment[i]->affected[j].modifier,
handler.c:                              ch->equipment[i]->obj_flags.bitvector, FALSE);
handler.c:    for (af = ch->affected; af; af = af->next)
handler.c:    ch->tmpabilities = ch->abilities;
handler.c:        if ((ch->equipment[i]) && (i != WEAR_ON_BACK) && (i != WEAR_BACK) && (i != WEAR_ON_BELT_1)
handler.c:                affect_modify(ch, ch->equipment[i]->affected[j].location,
handler.c:                              ch->equipment[i]->affected[j].modifier,
handler.c:                              ch->equipment[i]->obj_flags.bitvector, TRUE);
handler.c:    for (af = ch->affected; af; af = af->next)
handler.c:    affected_alloc->next = ch->affected;
handler.c:    ch->affected = affected_alloc;
handler.c:    assert(ch->affected);
handler.c:    if (ch->affected == af)     /* remove head of list */
handler.c:        ch->affected = af->next;
handler.c:        for (hjp = ch->affected; (hjp->next) && (hjp->next != af); hjp = hjp->next);
handler.c:                ("FATAL : Could not locate affected_type in ch->affected. (handler.c, affect_remove)");
handler.c:    while ((hjp = ch->affected))
handler.c:    hjp = ch->affected;
handler.c:    for (hjp = ch->affected; hjp; hjp = next_hjp) {
handler.c:    if (ch->affected)
handler.c:        for (aff_node = ch->affected; aff_node; aff_node = aff_node->next)
handler.c:    for (af = ch->affected; af; af = af->next) {
handler.c:    for (af = ch->affected; af; af = af->next) {
handler.c:    for (af = ch->affected; af; af = af->next) {
handler.c:    for (af = ch->affected; af; af = af->next) {
handler.c:    for (af = ch->affected; af; af = af->next) {
handler.c:    for (af = ch->affected; af; af = af->next) {
handler.c:    for (hjp = ch->affected; !found && hjp; hjp = next) {
handler.c:    for (ch = rm->people; ch; ch = ch->next_in_room) {
handler.c:        if (((obj = ch->equipment[EP]) || (obj = ch->equipment[ES])
handler.c:             || (obj = ch->equipment[WEAR_ABOUT_HEAD])) && obj->obj_flags.type == ITEM_LIGHT) {
handler.c:    if (!ch || !ch->in_room)
handler.c:    if (ch->prev_in_room)
handler.c:        ch->prev_in_room->next_in_room = ch->next_in_room;
handler.c:    if (ch->next_in_room)
handler.c:        ch->next_in_room->prev_in_room = ch->prev_in_room;
handler.c:    if (ch == ch->in_room->people)
handler.c:        ch->in_room->people = ch->next_in_room;
handler.c:    ch->in_room = NULL;
handler.c:    ch->prev_in_room = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:    if (!ch || !ch->in_room)
handler.c:    rm = ch->in_room;
handler.c:    if (ch->on_obj) {
handler.c:    if (!ch->in_room)
handler.c:    rm = ch->in_room;
handler.c:    for (i = ch->in_room->people; i; i = i->next_in_room)
handler.c:        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_SUBDUED);
handler.c:    if (ch->specials.subduing) {
handler.c:        REMOVE_BIT(ch->specials.subduing->specials.affected_by, CHAR_AFF_SUBDUED);
handler.c:        ch->specials.subduing = NULL;
handler.c:    for (i = ch->in_room->people; i; i = i->next_in_room)
handler.c:    if (ch->specials.riding)
handler.c:        ch->specials.riding = NULL;
handler.c:    ch->prev_in_room = NULL;
handler.c:    ch->next_in_room = room->people;
handler.c:    if (ch->next_in_room)
handler.c:        ch->next_in_room->prev_in_room = ch;
handler.c:    ch->in_room = room;
handler.c:    if (room_in_city(ch->in_room) == CITY_TULUK) {
handler.c:    if (!ch || !ch->in_room)
handler.c:        if (IS_SET(ch->in_room->room_flags, RFL_NO_FLYING) && IS_AFFECTED(ch, CHAR_AFF_FLYING)) {
handler.c:            REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_FLYING);
handler.c:    if (ch->on_obj && ch->on_obj->in_room != ch->in_room)
handler.c:        remove_occupant(ch->on_obj, ch);
handler.c:            && (GET_GUILD(ch) != GUILD_ASSASSIN) && (ch->in_room->sector_type <= SECT_CITY))
handler.c:                if (ch->equipment[j] && (ch->equipment[j]->obj_flags.type == ITEM_ARMOR)
handler.c:                    && (ch->equipment[j]->obj_flags.material != MATERIAL_CLOTH)
handler.c:                    && (ch->equipment[j]->obj_flags.material != MATERIAL_SKIN))
handler.c:    for (tch = ch->in_room->people; tch; tch = tch->next_in_room)
handler.c:        if ((IS_SET(tch->specials.act, CFL_FLEE))
handler.c:                if (ch->in_room == tch->in_room)
handler.c:    /*  if (ch->in_room)
handler.c:     * num_room_lights(ch->in_room); */
handler.c:    CHAR_DATA *victim = ch->specials.subduing;
handler.c:    if (victim != NULL && victim->in_room == ch->in_room) {
handler.c:    for (o = ch->carrying; o; o = o->next_content)
handler.c:        if (ch->equipment[j]) {
handler.c:                wt += (int) (calc_object_weight(ch->equipment[j]) * 0.55);
handler.c:                wt += (int) (calc_object_weight(ch->equipment[j]) * 0.65);
handler.c:    if (ch->in_room)
handler.c:        for (rider = ch->in_room->people; rider; rider = rider->next_in_room)
handler.c:    if (ch->lifting) {
handler.c:        wt += MIN(GET_OBJ_WEIGHT(ch->lifting), (CAN_CARRY_W(ch) - wt));
handler.c:  for (o = ch->carrying; o; o = o->next_content) {
handler.c:    if (ch->equipment[j]) {
handler.c:        wt += (int) (calc_object_weight(ch->equipment[j]) * 0.55);
handler.c:        wt += (int) (calc_object_weight(ch->equipment[j]) * 0.65);
handler.c:  if (ch->in_room)
handler.c:    for (rider = ch->in_room->people; rider; rider = rider->next_in_room)
handler.c:    for (nc = 0, i = ch->carrying; i; i = i->next_content, nc++);
handler.c:    if ((!(ch->carrying)) || (!(strcmp("", OSTR(ch->carrying, short_descr))))
handler.c:        || (!(strcmp(OSTR(object, short_descr), OSTR(ch->carrying, short_descr))))) {
handler.c:        object->next_content = ch->carrying;
handler.c:        ch->carrying = object;
handler.c:        for (temp_obj = ch->carrying; ((temp_obj) && (temp_obj->next_content)
handler.c:            object->next_content = ch->carrying;
handler.c:            ch->carrying = object;
handler.c:    assert(ch->equipment[pos] == NULL);
handler.c:            obj_to_room(obj, ch->in_room);
handler.c:    ch->equipment[pos] = obj;
handler.c:    if (!ch->equipment[pos])
handler.c:    obj = ch->equipment[pos];
handler.c:    ch->equipment[pos] = 0;
handler.c:        if (ch->equipment[EP] && (ch->equipment[EP]->obj_flags.type == ITEM_WEAPON))
handler.c:            return (ch->equipment[EP]);
handler.c:        if (ch->equipment[ES] && (ch->equipment[ES]->obj_flags.type == ITEM_WEAPON))
handler.c:            return (ch->equipment[ES]);
handler.c:        if (ch->equipment[ETWO] && (ch->equipment[ETWO]->obj_flags.type == ITEM_WEAPON))
handler.c:            return (ch->equipment[ETWO]);
handler.c:        if (ch->equipment[WEAR_WRIST_R]
handler.c:            && (ch->equipment[WEAR_WRIST_R]->obj_flags.type == ITEM_WEAPON))
handler.c:            return (ch->equipment[WEAR_WRIST_R]);
handler.c:        if (ch->equipment[WEAR_WRIST_L]
handler.c:            && (ch->equipment[WEAR_WRIST_L]->obj_flags.type == ITEM_WEAPON))
handler.c:            return (ch->equipment[WEAR_WRIST_L]);
handler.c:        if (ch->equipment[EP] && (ch->equipment[EP]->obj_flags.type == ITEM_WEAPON)) {
handler.c:            return (ch->equipment[EP]);
handler.c:        } else if (ch->equipment[ETWO] && (ch->equipment[ETWO]->obj_flags.type == ITEM_WEAPON)) {
handler.c:            return (ch->equipment[ETWO]);
handler.c:        } else if (ch->equipment[WEAR_WRIST_R]
handler.c:                   && (ch->equipment[WEAR_WRIST_R]->obj_flags.type == ITEM_WEAPON)) {
handler.c:            return (ch->equipment[WEAR_WRIST_R]);
handler.c:        } else if (ch->equipment[ES] && (ch->equipment[ES]->obj_flags.type == ITEM_WEAPON)) {
handler.c:            return (ch->equipment[ES]);
handler.c:        } else if (ch->equipment[WEAR_WRIST_L]
handler.c:                   && (ch->equipment[WEAR_WRIST_L]->obj_flags.type == ITEM_WEAPON)) {
handler.c:            return (ch->equipment[WEAR_WRIST_L]);
handler.c:        if ((i = ch->equipment[loc])
handler.c:            if (obj == ch->equipment[loc])
handler.c:    if (!(r = ch->in_room))
handler.c:        return (ch->in_room);
handler.c:        if (ch->in_room->wagon_exit)
handler.c:            return ch->in_room->wagon_exit;
handler.c:    if (r == ch->in_room) {
handler.c:        if (ch->equipment[i])
handler.c:            update_object(ch->equipment[i], 2);
handler.c:    if (ch->carrying)
handler.c:        update_object(ch->carrying, 1);
handler.c:        if (ch->equipment[l])
handler.c:            extract_obj(ch->equipment[l]);
handler.c:    while (ch->carrying)
handler.c:        extract_obj(ch->carrying);
handler.c:    if (ch->specials.riding) {
handler.c:            if (ch->specials.riding->equipment[l])
handler.c:                extract_obj(ch->specials.riding->equipment[l]);
handler.c:        while (ch->specials.riding->carrying)
handler.c:            extract_obj(ch->specials.riding->carrying);
handler.c:        for (hitch = ch->specials.riding->followers; hitch;)
handler.c:            if (IS_SET(hitch->follower->specials.act, CFL_MOUNT) && ch->in_room
handler.c:                && hitch->follower->in_room && (ch->in_room == hitch->follower->in_room)
handler.c:                && !IS_AFFECTED(hitch->follower, CHAR_AFF_SUMMONED)) {
handler.c:                hitch = hitch->next;
handler.c:                hitch = hitch->next;
handler.c:        extract_char(ch->specials.riding);
handler.c:    for (hitch = ch->followers; hitch;)
handler.c:        if (IS_SET(hitch->follower->specials.act, CFL_MOUNT) && ch->in_room
handler.c:            && hitch->follower->in_room && (ch->in_room == hitch->follower->in_room)
handler.c:            && !IS_AFFECTED(hitch->follower, CHAR_AFF_SUMMONED)) {
handler.c:            hitch = hitch->next;
handler.c:            hitch = hitch->next;
handler.c:    if (ch->specials.contact && !affected_by_spell(ch, PSI_CONCEAL)) {
handler.c:        if (has_skill(ch->specials.contact, PSI_TRACE)) {
handler.c:            if (psi_skill_success(ch->specials.contact, 0, PSI_TRACE, 0)) {
handler.c:                cprintf(ch->specials.contact, "You sense %s withdraw from your mind.\n\r", MSTR(ch, short_descr));
handler.c:                cprintf(ch->specials.contact, "You sense a foreign presence withdraw from your mind.\n\r");
handler.c:                gain_skill(ch->specials.contact, PSI_TRACE, 1);
handler.c:            cprintf(ch->specials.contact, "You sense a foreign presence withdraw from your mind.\n\r");
handler.c:    REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_SUBDUED);
handler.c:    if (ch->lifting) {
handler.c:        remove_lifting(ch->lifting, ch);
handler.c:    if (ch->desc && (ch->desc->character != ch))
handler.c:        ch->desc = 0;
handler.c:    if (!IS_NPC(ch) && !ch->desc) {
handler.c:    if (ch->desc) {
handler.c:        if (ch->desc->snoop.snooping)
handler.c:            ch->desc->snoop.snooping->desc->snoop.snoop_by = 0;
handler.c:        if (ch->desc->snoop.snoop_by) {
handler.c:            send_to_char("Your victim is no longer among us.\n\r", ch->desc->snoop.snoop_by);
handler.c:            ch->desc->snoop.snoop_by->desc->snoop.snooping = 0;
handler.c:        ch->desc->snoop.snooping = ch->desc->snoop.snoop_by = 0;
handler.c:    if (ch->on_obj)
handler.c:        remove_occupant(ch->on_obj, ch);
handler.c:    if (((IS_NPC(ch) || (!IS_IMMORTAL(ch) && !IS_SET(ch->in_room->room_flags, RFL_SAFE)
handler.c:        if (ch->in_room && !extracting_mount) {
handler.c:                if (ch->equipment[l])
handler.c:                    obj_to_room(unequip_char(ch, l), ch->in_room);
handler.c:            while (ch->carrying) {
handler.c:                i = ch->carrying;
handler.c:                obj_to_room(i, ch->in_room);
handler.c:            /* assert(ch->in_room == 0) */
handler.c:                if (ch->equipment[l])
handler.c:                    extract_obj(ch->equipment[l]);
handler.c:            while (ch->carrying)
handler.c:                extract_obj(ch->carrying);
handler.c:    if (ch->followers || ch->master)
handler.c:    /*  if (ch->guards || ch->specials.guarding) */
handler.c:    if (ch->specials.harnessed_to)
handler.c:    if (ch->in_room) {
handler.c:            rnum = ch->in_room->number;
handler.c:        ch->specials.was_in_room = ch->in_room;
handler.c:    if (ch->prev)
handler.c:        ch->prev->next = ch->next;
handler.c:    if (ch->next)
handler.c:        ch->next->prev = ch->prev;
handler.c:        character_list = ch->next;
handler.c:    ch->abilities.armor = race[(int) GET_RACE(ch)].natural_armor;
handler.c:    if (ch->desc)
handler.c:        if (ch->desc->original)
handler.c:        if (ch->nr >= 0) {
handler.c:            if (ch->prev_num)
handler.c:                ch->prev_num->next_num = ch->next_num;
handler.c:            if (ch->next_num)
handler.c:                ch->next_num->prev_num = ch->prev_num;
handler.c:            if (ch == (CHAR_DATA *) npc_index[ch->nr].list)
handler.c:                npc_index[ch->nr].list = ch->next_num;
handler.c:            npc_index[ch->nr].number--;
handler.c:    if (ch->desc) {
handler.c:        ch->desc->connected = CON_SLCT;
handler.c:        show_main_menu(ch->desc);
handler.c:   return get_char_other_room_vis(ch, ch->in_room, name);
handler.c:    if (room == ch->in_room 
handler.c:    for (i = ch->in_room->people, j = 1; i && (j <= number); i = i->next_in_room)
handler.c:        if ((i->in_room) != (ch->in_room) && check_char_name(ch, i, tmp)) {
handler.c:    for (i = ch->in_room->people, j = 1; i && (j <= number); i = i->next_in_room)
handler.c:        if ((i->in_room) != (ch->in_room) && check_char_name_world_raw(ch, i, tmp, useCurrSdesc)) {
handler.c:    for (i = ch->in_room->people; i; i = i->next_in_room)
handler.c:        if (i->in_room != ch->in_room && check_char_name_world_all_name_raw(ch, i, tmpname, useCurrSdesc)) {
handler.c:    for (i = ch->in_room->people, j = 1; i && (j <= number); i = i->next_in_room)
handler.c:        if ((i->in_room) != (ch->in_room) && (i->in_room) && (i->in_room->number / 1000) == (zone)
handler.c:    for (i = ch->carrying, j = 1; i && j <= number; i = i->next_content)
handler.c:    for (i = ch->in_room->contents, j = 1; i && j <= number; i = i->next_content)
handler.c:        for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
handler.c:        for (obj = ch->carrying; obj && (count <= number); obj = obj->next_content)
handler.c:            if (ch->equipment[i]
handler.c:                && (isname(tmp, OSTR(ch->equipment[i], name))
handler.c:                    || isname(tmp, real_sdesc_keywords_obj(ch->equipment[i], ch)))) {
handler.c:                    *tar_obj = ch->equipment[i];
handler.c:        for (obj = ch->in_room->contents; obj && (count <= number); obj = obj->next_content)
handler.c:        for (robj = ch->in_room->contents; robj && (count <= number); robj = robj->next_content) {
handler.c:            for (obj = ch->carrying; obj; obj = obj->next_content)
handler.c:        if (IS_SET(bitvector, FIND_LIQ_CONT_ROOM) && ch->in_room)
handler.c:            for (obj = ch->in_room->contents; obj; obj = obj->next_content)
handler.c:            if (ch->in_room) {
handler.c:                if ((ch->in_room->sector_type == SECT_SILT) && drink_type == LIQ_SILT)
handler.c:                else if ((ch->in_room->sector_type == SECT_DESERT) && drink_type == LIQ_SAND)
handler.c:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
handler.c:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
handler.c:        for (obj = ch->carrying; obj; obj = obj->next_content) {
handler.c:            obj = ch->equipment[i];
handler.c:        for (obj = ch->in_room->contents; obj; obj = obj->next_content) {
handler.c:        for (robj = ch->in_room->contents; robj; robj = robj->next_content) {
handler.c:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
handler.c:        for (obj = ch->carrying; obj; obj = obj->next_content) {
handler.c:            obj = ch->equipment[i];
handler.c:        for (obj = ch->in_room->contents; obj; obj = obj->next_content) {
handler.c:        for (robj = ch->in_room->contents; robj; robj = robj->next_content) {
handler.c:    if (!ch->in_room)
handler.c:    if (!IS_SET(ch->specials.act, CFL_AGGRESSIVE) && !ch->specials.hates)
handler.c:    if (ch->specials.fighting) {
handler.c:        if ((ch->in_room == ch->specials.fighting->in_room) && CAN_SEE(ch, ch->specials.fighting))
handler.c:            return ch->specials.fighting;
handler.c:        else if (ch->in_room != ch->specials.fighting->in_room)
handler.c:        for (tmpch = ch->in_room->people; tmpch; tmpch = tmpch->next_in_room) {
handler.c:            else if (IS_SET(ch->specials.act, CFL_AGGRESSIVE) && (GET_RACE(ch) == RACE_ELEMENTAL)
handler.c:                     && (tmpch->player.guild != ch->player.guild) && CAN_SEE(ch, tmpch)
handler.c:            else if (IS_SET(ch->specials.act, CFL_AGGRESSIVE) && (GET_RACE(ch) == RACE_HALFLING)
handler.c:            else if (IS_SET(ch->specials.act, CFL_AGGRESSIVE) && (IS_TRIBE(ch, TRIBE_CAI_SHYZN)) && (!IS_TRIBE(tmpch, TRIBE_CAI_SHYZN)) && (IS_TRIBE(tmpch, !24999)) && /* is this right? !24999 */
handler.c:            else if (IS_SET(ch->specials.act, CFL_AGGRESSIVE) && (GET_RACE(ch) != RACE_ELEMENTAL)
handler.c:            else if (tmpch->specials.fighting && (!IS_IN_SAME_TRIBE(tmpch->specials.fighting, ch))
handler.c:                     && IS_IN_SAME_TRIBE(tmpch, ch) && CAN_SEE(ch, tmpch->specials.fighting))
handler.c:                return tmpch->specials.fighting;
handler.c:        room->people = ch->next_in_room;
handler.c:            ch->in_room = 0;
handler.c:        ch->specials.was_in_room = NULL;
handler.c:    ADD_OR_UPDATE_EDESC(set_name, set_desc, ch->ex_description);
handler.c:    ADD_OR_UPDATE_EDESC(set_name, set_desc, ch->ex_description);
handler.c:    for (edesc = ch->ex_description; edesc && strcmp(edesc->keyword, want_name); edesc = edesc->next);  /* do nothing find one wanted */
handler.c:    for (tmp = ch->ex_description; tmp; last = tmp, tmp = tmp->next)
handler.c:    if (tmp == ch->ex_description)
handler.c:        ch->ex_description = tmp->next;
handler.c:    if ((obj = ch->equipment[EP]) != NULL && GET_ITEM_TYPE(obj) == itype)
handler.c:    if ((obj = ch->equipment[ES]) != NULL && GET_ITEM_TYPE(obj) == itype)
handler.c:    if ((obj = ch->equipment[ETWO]) != NULL && GET_ITEM_TYPE(obj) == itype)
immortal.c:    if (ch->in_room)
immortal.c:        roomnum = ch->in_room->number;
immortal.c:    sprintf(buf, "[%d] (%s) %s: %s %s", roomnum, ch->desc ? ch->name : "linkdead",
immortal.c:            ch->desc ? ch->desc->player_info->name : "linkdead", command_name[cmd], argument);
immortal.c:    if (!ch || !ch->desc)
immortal.c:    pPInfo = ch->desc->player_info;
immortal.c:    if (ch->desc && ch->desc->original)
immortal.c:        orig = ch->desc->original;
immortal.c:    gvprintf(ch, NULL, ch->in_room, msg, char_list, hidden, silent);
immortal.c:    for (wlist = ch->in_room->watched_by; wlist; wlist = wlist->next_watched_by) {
immortal.c:        if (ch->player.poofin) {
immortal.c:            sprintf(buf, "Current poofin: %s\n\r", ch->player.poofin);
immortal.c:    if (ch->player.poofin) {
immortal.c:        if (strlen(ch->player.poofin) < 250)
immortal.c:            strcpy(buf2, ch->player.poofin);
immortal.c:        free((char *) ch->player.poofin);
immortal.c:    ch->player.poofin = strdup(buf1);
immortal.c:        if (ch->player.poofout) {
immortal.c:            sprintf(buf, "Current poofout: %s\n\r", ch->player.poofout);
immortal.c:    if (ch->player.poofout) {
immortal.c:        if (strlen(ch->player.poofout) < 250)
immortal.c:            strcpy(buf2, ch->player.poofout);
immortal.c:        free((char *) ch->player.poofout);
immortal.c:    ch->player.poofout = strdup(buf1);
immortal.c:    for (rch = room->people; rch; rch = rch->next_in_room) {
immortal.c:    generic_astar(ch->in_room, 0, depth, (float)depth, 0, 0, 0, echo_room_caller, (void*)argument, 0, 0, 0);
immortal.c:        echo_room(ch, ch->in_room, argument);
immortal.c:        echo_zone(ch, ch->in_room->zone, argument);
immortal.c:        echo_city(ch, room_in_city(ch->in_room), argument);
immortal.c:        execute_room_program(ch->in_room, 0, CMD_PULSE, arg1);
immortal.c:        if ((obj = get_obj_in_list_vis(ch, arg1, ch->in_room->contents))) {
immortal.c:    location = ch->in_room;
immortal.c:    on_obj = ch->on_obj;
immortal.c:    original_loc = ch->in_room;
immortal.c:    if (ch->player.poofout)
immortal.c:        act(ch->player.poofout, TRUE, ch, 0, 0, TO_ROOM);
immortal.c:    if (ch->player.poofin)
immortal.c:        act(ch->player.poofin, TRUE, ch, 0, 0, TO_ROOM);
immortal.c:        sprint_flag(ch->specials.act, char_flag, buf2);
immortal.c:        if (ch->affected) {
immortal.c:            for (af = ch->affected; af; af = af->next) {
immortal.c:        sprintf(buf, "%% Thirst: %d, Hunger: %d, Drunk: %d\n\r", ch->specials.conditions[THIRST],
immortal.c:                ch->specials.conditions[FULL], ch->specials.conditions[DRUNK]);
immortal.c:        sprintf(buf, "%% State: %d, Eco: %d, Size: %d\n\r\n\r", GET_STATE(ch), ch->specials.eco,
immortal.c:    tmp1 = (ch->abilities.off + agl_app[GET_AGL(ch)].reaction);
immortal.c:    tmp2 = (ch->abilities.def + agl_app[GET_AGL(ch)].reaction);
immortal.c:        /*  if (ch->skills[SKILL_PARRY]) */
immortal.c:        tmp3 = ch->skills[SKILL_PARRY]->learned;
immortal.c://   if (NULL != (obj = ch->equipment[EP]))
immortal.c:    if ((has_skill(ch, SKILL_SHIELD)) && (NULL != (obj = ch->equipment[EP])))
immortal.c:    if ((has_skill(ch, SKILL_SHIELD)) && (NULL != (obj = ch->equipment[ES])))
immortal.c:    if (ch->clan) {
immortal.c:        for (clan = ch->clan; clan; clan = clan->next) {
immortal.c:    if ((ch->specials.eco < 10) && (ch->specials.eco > -10))
immortal.c:    else if ((ch->specials.eco < 50) && (ch->specials.eco >= 10))
immortal.c:    else if ((ch->specials.eco < 90) && (ch->specials.eco >= 50))
immortal.c:    else if ((ch->specials.eco < 100) && (ch->specials.eco >= 90))
immortal.c:    else if (ch->specials.eco == 100)
immortal.c:    else if ((ch->specials.eco > -50) && (ch->specials.eco <= -10))
immortal.c:    else if ((ch->specials.eco > -90) && (ch->specials.eco <= -50))
immortal.c:    else if ((ch->specials.eco > -100) && (ch->specials.eco <= -90))
immortal.c:    else if (ch->specials.eco == -100)
immortal.c:        ch_saves[n] = ch->specials.apply_saving_throw[n];
immortal.c:    in_city = room_in_city(ch->in_room);
immortal.c:        if (IS_SET(ch->specials.act, city[ct].c_flag)
immortal.c:        if (ch->specials.fighting) {
immortal.c:            sprintf(buf1, "fighting %s.\n\r", PERS(viewer, ch->specials.fighting));
immortal.c:        if (ch->specials.riding) {
immortal.c:            sprintf(buf1, "riding %s.\n\r", PERS(viewer, ch->specials.riding));
immortal.c:    if (ch->specials.contact) {
immortal.c:                ((IS_IMMORTAL(viewer)) ? MSTR(ch->specials.contact, name) :
immortal.c:                 MSTR(ch->specials.contact, short_descr)));
immortal.c:    if (ch->followers) {
immortal.c:        for (k = ch->followers; k; k = next_dude) {
immortal.c:    /* End if ch->followers */
immortal.c:    if (ch->obj_master) {
immortal.c:                (ch == viewer) ? "are" : "is", OSTR(ch->obj_master, short_descr));
immortal.c:    if (ch->specials.nosave) {
immortal.c:                (ch == viewer) ? "are" : "is", show_flags(nosave_flag, ch->specials.nosave));
immortal.c:    if (ch->specials.mercy) {
immortal.c:         (ch == viewer) ? "are" : "is", show_flags(mercy_flag, ch->specials.mercy));
immortal.c:        rm = ch->in_room;
immortal.c:            for (tmp_watch = rm->watching; tmp_watch; tmp_watch = tmp_watch->next_watching) {
immortal.c:                if (IS_SET(tmp_watch->watch_type, WATCH_VIEW)) {
immortal.c:		    watch_msg = tmp_watch->view_msg_string;
immortal.c:                    if (tmp_watch->room_watched) {
immortal.c:                        cprintf(ch, "%s(%d):%s: with message \"%s\"\n\r", tmp_watch->room_watched->name,
immortal.c:                            tmp_watch->room_watched->number, wtype, watch_msg);
immortal.c:                            tmp_watch->watch_room_num, wtype, watch_msg);
immortal.c:		if (IS_SET(tmp_watch->watch_type, WATCH_LISTEN)) {
immortal.c:		    watch_msg = tmp_watch->listen_msg_string;
immortal.c:                    if (tmp_watch->room_watched) {
immortal.c:                        cprintf(ch, "%s(%d):%s: with message \"%s\"\n\r", tmp_watch->room_watched->name,
immortal.c:                            tmp_watch->room_watched->number, wtype, watch_msg);
immortal.c:                            tmp_watch->watch_room_num, wtype, watch_msg);
immortal.c:            for (tmp_watch = rm->watched_by; tmp_watch; tmp_watch = tmp_watch->next_watched_by) {
immortal.c:		if (IS_SET(tmp_watch->watch_type, WATCH_VIEW)) {
immortal.c:		    watch_msg = tmp_watch->view_msg_string;
immortal.c:                    cprintf(ch, "%d:%s: with message \"%s\"\n\r", tmp_watch->room_watching->number, wtype, watch_msg);
immortal.c:		if (IS_SET(tmp_watch->watch_type, WATCH_LISTEN)) {
immortal.c:		    watch_msg = tmp_watch->listen_msg_string;
immortal.c:                    cprintf(ch, "%d:%s: with message \"%s\"\n\r", tmp_watch->room_watching->number, wtype, watch_msg);
immortal.c:        page_string(ch->desc, pPInfo->karmaLog, 1);
immortal.c:    if (!ch->desc)
immortal.c:        if (ch->desc->snoop.snooping) {
immortal.c:            ch->desc->snoop.snooping->desc->snoop.snoop_by = 0;
immortal.c:            ch->desc->snoop.snooping = 0;
immortal.c:    if (ch->desc->snoop.snooping)
immortal.c:        ch->desc->snoop.snooping->desc->snoop.snoop_by = 0;
immortal.c:    ch->desc->snoop.snooping = victim;
immortal.c:            if (ch->desc->snoop.snooping) {
immortal.c:                ch->desc->snoop.snooping->desc->snoop.snoop_by = 0;
immortal.c:                ch->desc->snoop.snooping = 0;
immortal.c:            if (ch->desc->snoop.snoop_by) {
immortal.c:                ch->desc->snoop.snoop_by->desc->snoop.snooping = 0;
immortal.c:                ch->desc->snoop.snoop_by = 0;
immortal.c:                ch->desc->character = victim;
immortal.c:                ch->desc->original = ch;
immortal.c:                victim->desc = ch->desc;
immortal.c:                ch->desc = 0;
immortal.c:    if (!ch->desc)
immortal.c:    if (!ch->desc->original) {
immortal.c:                   && (npc_index[ch->nr].vnum != 1200 && npc_index[ch->nr].vnum != 1203)) {
immortal.c:                char_from_room(ch->desc->original);
immortal.c:                char_to_room(ch->desc->original, ch->in_room);
immortal.c:                act("Your form blurs as you become $N.", FALSE, ch, 0, ch->desc->original, TO_CHAR);
immortal.c:                act("$n blurs and becomes $N.", TRUE, ch, 0, ch->desc->original, TO_ROOM);
immortal.c:                act("You return to your physical form.", FALSE, ch, 0, ch->desc->original, TO_CHAR);
immortal.c:                act("$n dissipates into nothing.", TRUE, ch, 0, ch->desc->original, TO_ROOM);
immortal.c:                af.modifier = GET_MAX_STUN(ch->desc->original) / -number(2, 3);
immortal.c:                if (!IS_IMMORTAL(ch->desc->original))
immortal.c:                    affect_to_char(ch->desc->original, &af);
immortal.c:                affect_from_char(ch->desc->original, PSI_SHADOW_WALK);
immortal.c:                ch->specials.contact = NULL;
immortal.c:        ch->desc->character = ch->desc->original;
immortal.c:        ch->desc->original = 0;
immortal.c:        ch->desc->character->desc = ch->desc;
immortal.c:        ch->desc = 0;
immortal.c:                && (npc_index[ch->nr].vnum == 1200 || npc_index[ch->nr].vnum == 1203))
immortal.c:            for (vict = ch->in_room->people; vict; vict = vict_next) {
immortal.c:        } else if ((obj = get_obj_in_list_vis(ch, name, ch->in_room->contents))) {
immortal.c:        if ((ch->in_room) && is_save_zone(ch->in_room->zone) && !(*name)) {
immortal.c:            for (vict = ch->in_room->people; vict && doneall; vict = next_v) {
immortal.c:        for (obj = ch->in_room->contents; obj; obj = next_o) {
immortal.c:        qgamelogf(QUIET_REROLL, "Rerolling %s (%s) - %s %s; Age %d", GET_NAME(ch), ch->account,
immortal.c:    ch->abilities.str = abilities[ATT_STR];
immortal.c:    ch->abilities.end = abilities[ATT_END];
immortal.c:    ch->abilities.agl = abilities[ATT_AGL];
immortal.c:    ch->abilities.wis = abilities[ATT_WIS];
immortal.c:        if (find_ex_description("[UNIQUE_STATS]", ch->ex_description, TRUE)) {
immortal.c:            stat_str = find_ex_description("[UNIQUE_STATS]", ch->ex_description, TRUE);
immortal.c:                ch->abilities.str = atoi(str_str);
immortal.c:                ch->abilities.agl = atoi(agl_str);
immortal.c:                ch->abilities.wis = atoi(wis_str);
immortal.c:                ch->abilities.end = atoi(end_str);
immortal.c:                     npc_index[ch->nr].vnum);
immortal.c:                         npc_index[ch->nr].vnum);
immortal.c:                    ch->player.height = atoi(height_str);
immortal.c:                    ch->player.weight = atoi(weight_str);
immortal.c:    ch->tmpabilities = ch->abilities;
immortal.c:                /* if (ch->skills[i]) */
immortal.c:                ch->skills[i]->learned = 100;
immortal.c:                ch->skills[i]->rel_lev = 0;
immortal.c:        ch->specials.quiet_level = ~0;
immortal.c:            real_time_passed((time(0) - ch->player.time.logon) + ch->player.time.played, 0);
immortal.c:           if (ch->player.info[14])
immortal.c:               free((char *) ch->player.info[14]);
immortal.c:           ch->player.info[14] = strdup(buf2);
immortal.c:            GET_NAME(ch), ch->account);
immortal.c:           ch->abilities.str = oldStr;
immortal.c:           ch->abilities.agl = oldAgl;
immortal.c:           ch->abilities.wis = oldWis;
immortal.c:           ch->abilities.end = oldEnd;
immortal.c:           ch->tmpabilities = ch->abilities;
immortal.c:        if (ch->in_room && ch->in_room->number == 1003) {       /* Hall of Kings */
immortal.c:        if (ch->player.info[14])
immortal.c:            free((char *) ch->player.info[14]);
immortal.c:        ch->player.info[14] = strdup(buf);
immortal.c:        qgamelogf(QUIET_REROLL, "%s (%s): %s", GET_NAME(ch), ch->account, buf);
immortal.c:    for (ch = character_list; ch; ch = ch->next)
immortal.c:            sprintf(temp, "  %s in room %d\n\r", GET_NAME(ch), ch->in_room->number);
immortal.c:                page_string(ch->desc, show_list, 1);
immortal.c:                page_string(ch->desc, show_list, 1);
immortal.c:    page_string(ch->desc, show_list, 1);
immortal.c:    page_string(ch->desc, show_list, 1);
immortal.c:  page_string(ch->desc, show_list, 1);
immortal.c:        page_string(ch->desc, show_list, 1);
immortal.c:    page_string(ch->desc, show_list, 1);
immortal.c:        page_string(ch->desc, show_list, 1);
immortal.c:    page_string(ch->desc, show_list, 1);
immortal.c:                        lastmob = tmpch->nr;
immortal.c:            heap_print(show_list, ch->in_room, event_room_cmp);
immortal.c:            else if ((tmpob = get_obj_in_list_vis(ch, buf2, ch->in_room->contents)))
immortal.c:            page_string(ch->desc, show_list, 1);
immortal.c:            page_string(ch->desc, show_list, 1);
immortal.c:        page_string(ch->desc, show_list, 1);
immortal.c:        page_string(ch->desc, show_list, 1);
immortal.c:            page_string(ch->desc, show_list, 1);
immortal.c:    page_string(ch->desc, show_list, 1);
immortal.c:    old_lev = ch->specials.il;
immortal.c:    for (tmpch = ch->in_room->people; tmpch; tmpch = tmpch->next_in_room)
immortal.c:    ch->specials.il = lev;
immortal.c:    for (tmpch = ch->in_room->people; tmpch; tmpch = tmpch->next_in_room)
immortal.c:    if (!ch->in_room) {
immortal.c:    city = room_in_city(ch->in_room);
immortal.c:    if( ch->player.hometown != city) { 
immortal.c:    if (IS_SET(ch->in_room->room_flags, RFL_INDOORS)) {
immortal.c:    } else if (IS_DARK(ch->in_room) && !IS_AFFECTED(ch, CHAR_AFF_INFRAVISION) && !IS_IMMORTAL(ch)
immortal.c:    r1 = ch->in_room;
immortal.c:    if( ch->in_room == r2 ) {
immortal.c:        && !((tch = get_char_vis(ch, arg1)) && (r1 = tch->in_room))) {
immortal.c:        && !((tch = get_char_vis(ch, arg2)) && (r2 = tch->in_room))) {
immortal.c:                if (IS_SET(ch->specials.quiet_level, (1 << (new - 2))))
immortal.c:            ch->specials.quiet_level = 0;
immortal.c:            ch->specials.quiet_level = ~0;
immortal.c:            if (IS_SET(ch->specials.quiet_level, flag)) {
immortal.c:                REMOVE_BIT(ch->specials.quiet_level, flag);
immortal.c:                MUD_SET_BIT(ch->specials.quiet_level, flag);
immortal.c:        ch->equipment[i] = (struct obj_data *) 0;
immortal.c:    load_char(ch->name, ch);
immortal.c:        load_char(ch->name, ch);
immortal.c://        page_string(ch->desc, buf, 1);
immortal.c:    if (!ch->desc) {
immortal.c:    io_thread_send_msg(ch->name, ch->account, ch->desc->descriptor, IO_T_MSG_PFIND, name,
immortal.c:    page_string(ch->desc, buf, 1);
immortal.c:        if ((ch->player.level > CREATOR || !is_immortal_account(pPInfo->name))
immortal.c:        if ((ch->player.level > CREATOR || !is_immortal_account(pPInfo->name))
immortal.c:        if (ch->player.level > BUILDER || !is_immortal_account(pPInfo->name)) {
immortal.c:    page_string(ch->desc, buf2, 1);
immortal.c:    if (is_immortal_account(buf) && ch->player.level == CREATOR) {
immortal.c:    page_string(ch->desc, buf2, 1);
immortal.c:                       && ch->player.level >= pinfo_flags[get_flag_num(pinfo_flags, arg3)].priv) {
immortal.c:            } else if (ch->player.level >= pinfo_flags[get_flag_num(pinfo_flags, arg3)].priv) {
immortal.c:            tch->name = name;
immortal.c:                    gamelogf("cmd_pinfo: Unable to open char file '%s/%s'", account, tch->name);
immortal.c:                    gamelogf("cmd_pinfo: Unable to open char file '%s/%s'", account, tch->name);
immortal.c:            tch->specials.il = read_char_field_num("CHAR", 1, "INVIS LEVEL");
immortal.c:            tch->specials.uid = read_char_field_num("CHAR", 1, "UID");
immortal.c:            tch->account = strdup(data);
immortal.c:                tch->player.info[i] = strdup(data);
immortal.c:            tch->player.time.starting_time = read_char_field_num("CHAR", 1, "STARTING TIME");
immortal.c:        if (tch->specials.il <= ch->player.level && !in_game) {
immortal.c:        } else if (tch->specials.il <= ch->player.level) {
immortal.c:        if (tch->account) {
immortal.c:            sprintf(buf, "Account: %s\n\r", tch->account);
immortal.c:        if (tch->player.time.starting_time) {
immortal.c:            sprintf(buf, "Created: %s\r", ctime(&tch->player.time.starting_time));
immortal.c:            sprintf(buf, "%s:%s\n\r", fields[i], tch->player.info[i]);
immortal.c:        if (tch->specials.uid > 0) {
immortal.c:            sprintf(buf, "%s:%d\n\r", "UID", tch->specials.uid);
immortal.c:                free(tch->player.info[i]);
immortal.c:            free(tch->account);
immortal.c:            free(tch->player.info[num]);
immortal.c:            tch->player.info[num] = strdup(data);
immortal.c:            if (ch->in_room)
immortal.c:                free(tch->player.info[i]);
immortal.c:    for (victim = ch->in_room->people; victim; victim = next)
immortal.c:        if (ch->player.level < 4) {
immortal.c:    sprintf(buf, "accountmail/%s/%s", capitalize(arg2), sch->name);
immortal.c:    ch->desc->editing = fp;
immortal.c:    ch->desc->editing_filename = strdup(buf);
immortal.c:    CREATE(ch->desc->editing_header, char, MAX_STRING_LENGTH);
immortal.c:    sprintf(ch->desc->editing_header, "\nComment from %s for '%s'\nReceived on %s:\n", sch->name,
immortal.c:    CREATE(ch->desc->tmp_str, char, MAX_STRING_LENGTH);
immortal.c:        sprintf(ch->desc->tmp_str, "%s\n", argument);
immortal.c:        string_append(ch, &ch->desc->tmp_str, MAX_STRING_LENGTH);
immortal.c:        ch->desc->tmp_str[0] = '\0';
immortal.c:        string_edit(ch, &ch->desc->tmp_str, MAX_STRING_LENGTH);
immortal.c:    victim->desc = ch->desc;
immortal.c:    ch->desc = NULL;
immortal.c:    ch->desc = victim->desc;
immortal.c:    page_string(ch->desc, buf, 1);
immortal.c:    if (ch->desc && ch->desc->original && IS_IMMORTAL(ch->desc->original)) {
immortal.c:        sCh = ch->desc->original;
immortal.c:                            npc_index[ch->nr].vnum, argument);
immortal.c:        sprintf(buf, "$n [M%d] sends:\n\r     \"%s\"\n\r", npc_index[ch->nr].vnum, argument);
info.c:    if (IS_SET(ch->specials.brief, BRIEF_EQUIP)) {
info.c:    if (ch->long_descr) {
info.c:        free((char *) ch->long_descr);
info.c:    ch->long_descr = strdup(desc_holder);
info.c:    if (ch->player.info[1]) {
info.c:        free((char *) ch->player.info[1]);
info.c:    ch->player.info[1] = strdup(objective_holder);
info.c:    if ((ch->skills[object->obj_flags.value[2]]->learned) < 40) {
info.c:    page_string(ch->desc, buffer, 1);
info.c:		&& (((ch->skills[SKILL_POISON] && ch->skills[SKILL_POISON]->learned > 70))
info.c:    } else if ((ptype >= 1) && (ch->skills[SKILL_POISON])) { 
info.c:                && ch->skills[object->obj_flags.value[2]]->learned >= 40
info.c:    page_string(ch->desc, buffer, 1);
info.c:   for( obj = ch->carrying; obj; obj = obj->next_content ) {
info.c:                if (IS_SET(ch->specials.brief, BRIEF_EQUIP)) {
info.c:    int warmth = ch->specials.eco / 10;
info.c:    if( !ch || !vict || !ch->in_room || !vict->in_room ) return -1;
info.c:    if( ch->in_room == vict->in_room ) return 0;
info.c:    return generic_astar(ch->in_room, vict->in_room, 3, 30.0f, 0, 0, 0, 0, 0, 0, 0, 0);
info.c:                    if (percent <= 80 && ch->in_room && i->in_room && (ch->in_room == i->in_room)) {    /* Add tired in ldesc */
info.c:            if (humlev && ch->in_room && i->in_room && (ch->in_room == i->in_room)) {    // Only > 0 gets shown
info.c:                if (room_in_city(ch->in_room) == ct) {
info.c:        if( IS_SET( ch->specials.brief, BRIEF_EQUIP ) ) {
info.c:            if( IS_SET( ch->specials.brief, BRIEF_EQUIP ) ) {
info.c:    if(!ch || !ch->in_room)
info.c:    for (i = ch->in_room->people; i; i = i->next_in_room)
info.c:    for (j = ch->in_room->contents; j; j = j->next_content)
info.c:        skill = ch->skills[SKILL_PEEK]->learned;
info.c:    int skill = has_skill(ch, SKILL_PEEK) ? ch->skills[SKILL_PEEK]->learned : 5;
info.c:    if (IS_SET(ch->in_room->room_flags, RFL_POPULATED)) {
info.c:            for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
info.c:                        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
info.c:            for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
info.c:                        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
info.c:        for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
info.c:                    REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
info.c:    if( !IS_IMMORTAL(ch) && IS_DARK(ch->in_room)) {
info.c:            && ch->skills[SKILL_COMPONENT_CRAFTING]) {
info.c:        if (ch->skills[SKILL_BREW]) {
info.c:        if ((affected_by_spell(ch, SPELL_DETECT_MAGICK)) && ch->skills[SKILL_COMPONENT_CRAFTING]) {
info.c:            if ((isname("nakgear1", OSTR(obj, name))) && (ch->skills[LANG_SOUTH_ACCENT])) {
info.c:            if ((isname("tulukgear1", OSTR(obj, name))) && (ch->skills[LANG_NORTH_ACCENT])) {
info.c:            if ((obj->obj_flags.value[3] == 1) && (ch->skills[PROF_BLUDGEONING] || ch->skills[SKILL_CLUBMAKING])) {
info.c:            if ((obj->obj_flags.value[3] == 2) && (ch->skills[PROF_PIERCING] || ch->skills[SKILL_KNIFE_MAKING] || ch->skills[SKILL_SWORDMAKING])) {
info.c:                if (ch->skills[SKILL_BACKSTAB] || ch->skills[SKILL_KNIFE_MAKING]) {
info.c:                } else if (ch->skills[PROF_PIERCING]) {
info.c:            if ((obj->obj_flags.value[3] == 4) && (ch->skills[PROF_CHOPPING] || ch->skills[SKILL_AXEMAKING])) {
info.c:            if ((obj->obj_flags.value[3] == 5) && (ch->skills[PROF_SLASHING] || ch->skills[SKILL_SWORDMAKING] || ch->skills[SKILL_KNIFE_MAKING])) {
info.c:            if ((obj->obj_flags.value[3] == 13) && (ch->skills[PROF_PIKE] || ch->skills[SKILL_SPEARMAKING])) {
info.c:            if ((obj->obj_flags.value[3] == 14) && (ch->skills[PROF_TRIDENT] || ch->skills[SKILL_SPEARMAKING])) {
info.c:            if ((obj->obj_flags.value[3] == 15) && (ch->skills[PROF_POLEARM] || ch->skills[SKILL_SPEARMAKING])) {
info.c:            if ((obj->obj_flags.value[3] == 16) && (ch->skills[PROF_KNIFE] || ch->skills[SKILL_KNIFE_MAKING])) {
info.c:            if ((obj->obj_flags.value[3] == 17) && (ch->skills[PROF_RAZOR] || ch->skills[SKILL_KNIFE_MAKING])) {
info.c:		&& (ch->skills[SKILL_POISON] || affected_by_spell(ch, SPELL_DETECT_POISON))) {
info.c:		&& (ch->skills[SKILL_POISON] || affected_by_spell(ch, SPELL_DETECT_POISON))) {
info.c:		&& (ch->skills[SKILL_POISON] || affected_by_spell(ch, SPELL_DETECT_POISON))) {
info.c:        for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
info.c:        ch_int = ch->player.height;
info.c:        tar_int = tar_ch->player.height;
info.c:        shoes = ch->equipment[WEAR_FEET];
info.c:        tshoes = tar_ch->equipment[WEAR_FEET];
info.c:        ch_int = ch->player.weight;
info.c:        tar_int = tar_ch->player.weight;
info.c:        if (ch->in_room->direction[ex]
info.c:            && IS_SET(ch->in_room->direction[ex]->exit_info, EX_SPL_SAND_WALL)) {
info.c:        if (ch->in_room->direction[ex]
info.c:            && IS_SET(ch->in_room->direction[ex]->exit_info, EX_SPL_BLADE_BARRIER)) {
info.c:        if (ch->in_room->direction[ex]
info.c:            && IS_SET(ch->in_room->direction[ex]->exit_info, EX_SPL_THORN_WALL)) {
info.c:        if (ch->in_room->direction[ex]
info.c:            && IS_SET(ch->in_room->direction[ex]->exit_info, EX_SPL_FIRE_WALL)) {
info.c:        if (ch->in_room->direction[ex]
info.c:            && IS_SET(ch->in_room->direction[ex]->exit_info, EX_SPL_WIND_WALL)) {
info.c:                                 "through what appear to be blades of pech-grass, though they are much larger,\n\r"
info.c:        sector_select = ch->in_room->sector_type;
info.c:    if (!ch || !ch->desc)
info.c:    if (!ch->in_room)
info.c:    } else if (IS_DARK(ch->in_room) && !IS_AFFECTED(ch, CHAR_AFF_INFRAVISION) && !IS_IMMORTAL(ch)
info.c:            if (!IS_SET(ch->specials.brief, BRIEF_ROOM))
info.c:            if (IS_DARK(ch->in_room) && !IS_IMMORTAL(ch) && (GET_RACE(ch) != RACE_GHOUL)
info.c:                         * from_room = ch->in_room;
info.c:                                && (find_ex_description("[BLURRED_VISION]", ch->ex_description, TRUE))) {
info.c:                        was_in = ch->in_room;
info.c:                        ch->in_room = tar_room;
info.c:                        ch->in_room = was_in;
info.c:                        if( ch->specials.riding != NULL ) {
info.c:                           ch_height = GET_HEIGHT(ch) / 2 + GET_HEIGHT(ch->specials.riding);
info.c:                            for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
info.c:                        tmp_desc = find_ex_description(arg2, ch->in_room->ex_description, FALSE);
info.c:                            page_string(ch->desc, tmp_desc, 0);
info.c:                        if ((table = get_obj_in_list_vis(ch, arg3, ch->in_room->contents)) != NULL) {
info.c:                                        page_string(ch->desc, OSTR(tmp_object, description), 1);
info.c:                                            page_string(ch->desc, tmp_desc, 1);
info.c:                        if (ch->equipment[j]) {
info.c:                            if (CAN_SEE_OBJ(ch, ch->equipment[j])) {
info.c:                                    find_ex_description(arg2, ch->equipment[j]->ex_description,
info.c:                                        find_obj_keyword(ch->equipment[j], find_bits, ch, obj_keyword,
info.c:                                    page_string(ch->desc, tmp_desc, 1);
info.c:                    for (tmp_object = ch->carrying; tmp_object && !found;
info.c:                                page_string(ch->desc, tmp_desc, 1);
info.c:                    for (tmp_object = ch->in_room->contents; tmp_object && !found;
info.c:                                page_string(ch->desc, tmp_desc, 1);
info.c:                    for (tmp_char = ch->in_room->people; tmp_char && !found;
info.c:                                page_string(ch->desc, tmp_desc, 1);
info.c:                                page_string(ch->desc, tmp_desc, 1);
info.c:                                        page_string(ch->desc, tmp_desc, 1);
info.c:                            page_string(ch->desc, tmp_desc, 1);
info.c:                    sprintf(tmp, "%s [%d] ", ch->in_room->name, ch->in_room->number);
info.c:                    sprint_flag(ch->in_room->room_flags, room_flag, buffer);
info.c:                        sprintf(tmp, "%s", ch->in_room->name);
info.c:                    if (ch->in_room->direction[dir]
info.c:                        && !IS_SET(ch->in_room->direction[dir]->exit_info, EX_SECRET)) {
info.c:                        if (!IS_SET(ch->specials.brief, BRIEF_EXITS)
info.c:                tmpob = find_exitable_wagon_for_room(ch->in_room);
info.c:                        if( !IS_SET(ch->specials.brief, BRIEF_EXITS)) {
info.c:		if (!IS_SET(ch->specials.brief, BRIEF_NOVICE)) {
info.c:		    if (IS_SET(ch->in_room->room_flags, RFL_SAFE)) {
info.c:                        if( !IS_SET(ch->specials.brief, BRIEF_EXITS)) {
info.c:		    if (is_save_zone(ch->in_room->zone)) {
info.c:                        if( !IS_SET(ch->specials.brief, BRIEF_EXITS)) {
info.c:                if (!IS_SET(ch->specials.brief, BRIEF_ROOM)) {
info.c:                        find_ex_description("[DET_ETH_DESC]", ch->in_room->ex_description, TRUE);
info.c:                        find_ex_description("[DET_INVIS_DESC]", ch->in_room->ex_description, TRUE);
info.c:                                     (IS_SET(ch->specials.affected_by, CHAR_AFF_DETECT_ETHEREAL))))
info.c:                                           (ch->specials.affected_by, CHAR_AFF_DETECT_INVISIBLE))))
info.c:                                find_ex_description("night", ch->in_room->ex_description, FALSE);
info.c:                                    send_to_char(bdesc_list[ch->in_room->zone]
info.c:                                                 [ch->in_room->bdesc_index].desc, ch);
info.c:                                    send_to_char(ch->in_room->description, ch);
info.c:                                send_to_char(bdesc_list[ch->in_room->zone]
info.c:                                             [ch->in_room->bdesc_index].desc, ch);
info.c:                                send_to_char(ch->in_room->description, ch);
info.c:                if (IS_SET(ch->in_room->room_flags, RFL_RESTFUL_SHADE))
info.c:                if ((IS_SET(ch->in_room->room_flags, RFL_SPL_ALARM))
info.c:                 * if (ch->in_room->direction[ex] &&
info.c:                 * IS_SET (ch->in_room->direction[ex]->exit_info,
info.c:                 * if (ch->in_room->direction[ex] &&
info.c:                 * IS_SET (ch->in_room->direction[ex]->exit_info,
info.c:                 * if (ch->in_room->direction[ex] &&
info.c:                 * IS_SET (ch->in_room->direction[ex]->exit_info,
info.c:                 * if (ch->in_room->direction[ex] &&
info.c:                 * IS_SET (ch->in_room->direction[ex]->exit_info,
info.c:                if (IS_SET(ch->in_room->room_flags, RFL_ASH))
info.c:                list_obj_to_char(ch->in_room->contents, ch, 0, FALSE);
info.c:                list_char_to_char(ch->in_room->people, ch, 0);
info.c:            tmpob = find_wagon_for_room(ch->in_room);
info.c:                    was_in = ch->in_room;
info.c:                    ch->in_room = tmpob->in_room;
info.c:                    ch->in_room = was_in;
info.c:                if (ch->in_room->sector_type == SECT_INSIDE) {
info.c:                    sprintf(tmp, "%s [%d]", ch->in_room->name, ch->in_room->number);
info.c:                    sprint_flag(ch->in_room->room_flags, room_flag, buffer);
info.c:                    sprintf(tmp, "%s", ch->in_room->name);
info.c:                    if (ch->in_room->direction[dir]
info.c:                        && !IS_SET(ch->in_room->direction[dir]->exit_info, EX_SECRET)) {
info.c:                tmpob = find_exitable_wagon_for_room(ch->in_room);
info.c:		if (!IS_SET(ch->specials.brief, BRIEF_NOVICE)) {
info.c:		    if (IS_SET(ch->in_room->room_flags, RFL_SAFE)) {
info.c:		    if (is_save_zone(ch->in_room->zone)) {
info.c:                //                send_to_char(bdesc_list[ch->in_room->zone]
info.c:                //                             [ch->in_room->bdesc_index].desc, ch);
info.c:                tmp_desc = find_ex_description("[DET_ETH_DESC]", ch->in_room->ex_description, TRUE);
info.c:                                 || (IS_SET(ch->specials.affected_by, CHAR_AFF_DETECT_ETHEREAL))))
info.c:                    find_ex_description("[DET_INVIS_DESC]", ch->in_room->ex_description, TRUE);
info.c:                                  || (IS_SET(ch->specials.affected_by, CHAR_AFF_DETECT_INVISIBLE))))
info.c:                        tmp_desc = find_ex_description("night", ch->in_room->ex_description, FALSE);
info.c:                            send_to_char(bdesc_list[ch->in_room->zone]
info.c:                                         [ch->in_room->bdesc_index].desc, ch);
info.c:                            send_to_char(ch->in_room->description, ch);
info.c:                        send_to_char(bdesc_list[ch->in_room->zone]
info.c:                                     [ch->in_room->bdesc_index].desc, ch);
info.c:                        send_to_char(ch->in_room->description, ch);
info.c:                //                send_to_char(ch->in_room->description, ch);
info.c:                if (IS_SET(ch->in_room->room_flags, RFL_RESTFUL_SHADE))
info.c:                if (IS_SET(ch->in_room->room_flags, RFL_ASH))
info.c:                    if (ch->in_room->direction[ex]
info.c:                        && IS_SET(ch->in_room->direction[ex]->exit_info, EX_SPL_SAND_WALL)) {
info.c:                    if (ch->in_room->direction[ex]
info.c:                        && IS_SET(ch->in_room->direction[ex]->exit_info, EX_SPL_FIRE_WALL)) {
info.c:                    if (ch->in_room->direction[ex]
info.c:                        && IS_SET(ch->in_room->direction[ex]->exit_info, EX_SPL_BLADE_BARRIER)) {
info.c:                    if (ch->in_room->direction[ex]
info.c:                        && IS_SET(ch->in_room->direction[ex]->exit_info, EX_SPL_WIND_WALL)) {
info.c:    if (!ch->desc)
info.c:    if (IS_DARK(ch->in_room) && !IS_AFFECTED(ch, CHAR_AFF_INFRAVISION) && !IS_IMMORTAL(ch)
info.c:                    page_string(ch->desc, tmp_desc->description, 1);
info.c:			if (ch->skills[bookSkill]->learned < 
info.c:			  if (ch->skills[bookSkill]->learned > 
info.c:			    oldSkillLearnedValue = ch->skills[bookSkill]->learned;
info.c:			    if (ch->skills[bookSkill]->learned != 
info.c:    if ((IS_DARK(ch->in_room) || (visibility(ch) <= 0))
info.c:                            sector_select = ch->in_room->sector_type;
info.c:                            sector_select = ch->in_room->sector_type;
info.c:                            sector_select = ch->in_room->sector_type;
info.c:    tmpob = find_exitable_wagon_for_room(ch->in_room);
info.c:    if (ch->clan) {
info.c:        if (!ch->clan->next && ch->clan->clan < MAX_CLAN && !IS_NPC(ch)) {
info.c:            int clan = ch->clan->clan;
info.c:            int rank = ch->clan->rank;
info.c:        } else if (ch->clan->next) {
info.c:        cprintf(ch, "Keywords: %s\n\r", ch->player.extkwds);
info.c:    if (ch->player.info[1]) {
info.c:        cprintf(ch, "Objective: %s\n\r", ch->player.info[1]);
info.c:    if (!IS_NPC(ch) || (IS_NPC(ch) && ch->long_descr)) {
info.c:            cprintf(ch, "%s%s%s\n\r", ch->long_descr ? capitalize(PERS(ch, ch)) : "",
info.c:                    ch->long_descr ? " " : "", ch->long_descr ? ch->long_descr : no_ldesc);
info.c:            cprintf(ch, "%s\n\r", capitalize(ch->long_descr));
info.c:                if (zone_table[zone].uid == ch->specials.uid) {
info.c:                    if (priv->uid == ch->specials.uid) {
info.c:                    if (IS_SET(ch->specials.group, grp[g].bitv)
info.c:        if (ch->specials.il) {
info.c:            cprintf(ch, "Your invisibility level is %d.\n\r", ch->specials.il);
info.c:    playing_time = real_time_passed((time(0) - ch->player.time.logon) + ch->player.time.played, 0);
info.c:        if (ch->on_obj) {
info.c:            cprintf(ch, " on %s", format_obj_to_char(ch->on_obj, ch, 1));
info.c:            if (ch->on_obj->table) {
info.c:                cprintf(ch, ", at %s", format_obj_to_char(ch->on_obj->table, ch, 1));
info.c:        if (ch->on_obj) {
info.c:            cprintf(ch, " on %s", format_obj_to_char(ch->on_obj, ch, 1));
info.c:            if (ch->on_obj->table) {
info.c:                cprintf(ch, ", at %s", format_obj_to_char(ch->on_obj->table, ch, 1));
info.c:        if (ch->on_obj) {
info.c:            cprintf(ch, " on %s", format_obj_to_char(ch->on_obj, ch, 1));
info.c:            if (ch->on_obj->table) {
info.c:                cprintf(ch, ", at %s", format_obj_to_char(ch->on_obj->table, ch, 1));
info.c:        if (ch->specials.fighting)
info.c:                 PERS(ch, ch->specials.fighting));
info.c:                 PERS(ch, ch->specials.fighting));
info.c:        if (!ch->specials.riding) {
info.c:            if (ch->on_obj) {
info.c:                if (IS_SET(ch->on_obj->obj_flags.value[1], FURN_SKIMMER)
info.c:                 || IS_SET(ch->on_obj->obj_flags.value[1], FURN_WAGON))
info.c:                    cprintf(ch, " on %s", format_obj_to_char(ch->on_obj, ch, 1));
info.c:                    cprintf(ch, " at %s", format_obj_to_char(ch->on_obj, ch, 1));
info.c:                if (ch->on_obj->table) {
info.c:                    cprintf(ch, ", at %s", format_obj_to_char(ch->on_obj->table, ch, 1));
info.c:            cprintf(ch, "You are riding %s.\n\r", PERS(ch, ch->specials.riding));
info.c:    if (!ch || !ch->in_room)
info.c:    if (get_room_extra_desc_value(ch->in_room, "[time_failure]", buffer, MAX_STRING_LENGTH)) {
info.c:    if (has_special_on_cmd(ch->in_room->specials, "cave_emulator", -1)
info.c:        || ch->in_room->sector_type == SECT_SOUTHERN_CAVERN
info.c:        || ch->in_room->sector_type == SECT_CAVERN 
info.c:        || ch->in_room->sector_type == SECT_SEWER) {
info.c:    if (ch->in_room->zone == 34) {
info.c:    wroom = ch->in_room;
info.c:        if (ch->in_room->sector_type == SECT_SILT || ch->in_room->sector_type == SECT_SHALLOWS) {
info.c:  page_string(ch->desc, output, 1);
info.c:  page_string(ch->desc, help_output, 1);
info.c:    if (!ch->desc) {
info.c:  if (!ch->desc)
info.c:      page_string(ch->desc, help, 1);
info.c:        page_string(ch->desc, help, 1);
info.c:    page_string(ch->desc, output, 1);
info.c:    if (!ch->desc)
info.c:        page_string(ch->desc, godhelp, 0);
info.c:    page_string(ch->desc, output, 1);
info.c:                    for (pC = ch->clan; pC; pC = pC->next)
info.c:            if (show_room && (view->in_room->number != ch->in_room->number))
info.c:    page_string(ch->desc, show_list, 1);
info.c:    page_string(ch->desc, show_list, 1);
info.c:    for (i = ch->carrying; i; i = ii) {
info.c:    for (i = ch->carrying; i; i = i->next_content) {
info.c:    if (IS_SET(ch->specials.brief, BRIEF_EQUIP)) {
info.c:        if (IS_SET(ch->specials.brief, BRIEF_EQUIP) && ch->carrying) {
info.c:        } else if (!IS_SET(ch->specials.brief, BRIEF_EQUIP)) {
info.c:    sprintf(buf, "%s", list_obj_to_char(ch->carrying, ch, 2, FALSE));
info.c:    if (IS_SET(ch->specials.brief, BRIEF_EQUIP)
info.c:    if (IS_SET(ch->specials.brief, BRIEF_EQUIP)) {
info.c:        if (ch->equipment[sorted_eq[j]]) {
info.c:            if (CAN_SEE_OBJ(ch, ch->equipment[sorted_eq[j]])) {
info.c:                show_obj_to_char(ch->equipment[sorted_eq[j]], ch, 1);
info.c:    page_string(ch->desc, credits, 0);
info.c:    page_string(ch->desc, areas, 0);
info.c:    page_string(ch->desc, news, 0);
info.c:    page_string(ch->desc, motd, 0);
info.c:    page_string(ch->desc, wizlist, 0);
info.c:        page_string(ch->desc, show_list, 1);
info.c:            page_string(ch->desc, show_list, 1);
info.c:            page_string(ch->desc, show_list, 1);
info.c:            page_string(ch->desc, show_list, 1);
info.c:            page_string(ch->desc, show_list, 1);
info.c:            page_string(ch->desc, show_list, 1);
info.c:    for (i = ch->in_room->people; i; i = i->next_in_room) {
info.c:        if (check_char_name(ch, i, name) && i->in_room != ch->in_room) {
info.c:    for (k = ch->carrying; k; k = k->next_content) {
info.c:    for (k = ch->in_room->contents; k; k = k->next_content) {
info.c:            && CAN_SEE_OBJ(ch, k) && k->in_room != ch->in_room && k->carried_by != ch) {
info.c:        page_string(ch->desc, show_list, 1);
info.c:            if (ch->player.height > victim->player.height) {
info.c:                if (ch->player.weight > victim->player.weight)
info.c:            } else if (ch->player.height < victim->player.height) {
info.c:                if (victim->player.weight > ch->player.weight)
info.c:                if (ch->player.weight > victim->player.weight)
info.c:                else if (ch->player.weight < victim->player.weight)
info.c:  page_string(ch->desc, show_list, 1);
info.c:    page_string(ch->desc, buf, 1);
info.c:        page_string(ch->desc, buf, TRUE);
info.c:        obj = ch->carrying;
info.c:        obj = ch->in_room->contents;
info.c:    in_room = ch->in_room;
info.c:    page_string(ch->desc, buf2, 1);
info.c:                    && ch->skills[obj->obj_flags.value[2]]->learned > 40) {
info.c:            page_string(ch->desc, buf, 1);
info.c:        page_string(ch->desc, buf, 1);
info.c:            if (IS_SET(ch->specials.brief, BRIEF_EQUIP)) {
info.c:            ch->desc->editing_biography = entry;
info.c:                ch->desc->editing_biography = entry;
info.c:            page_string(ch->desc, buffer, 1);
info.c:    page_string(ch->desc, buffer, 1);
info.c:    return ch->equipment[wear_loc];
info.c:    if (IS_NPC(ch) && IS_SET(ch->specials.act, CFL_MOUNT)) {
io_thread.c:        if (!ch || !ch->desc) {
io_thread.c:        if (ch->desc->descriptor != msg->desc)
io_thread.c:        if (!ch || !ch->desc) {
io_thread.c:        if (ch->desc->descriptor != msg->desc)
io_thread.c:        page_string(ch->desc, (char *)msg->data, 1);
light.c:        light_a_light(obj, ch->in_room);
light.c:                    light_a_light(obj, ch->in_room);
light.c:                        light_a_light(obj, ch->in_room);
light.c:                        light_a_light(obj, ch->in_room);
light.c:                    light_a_light(obj, ch->in_room);
light.c:    OBJ_DATA *retval = extinguish_light(obj, ch->in_room);
light.c:    ROOM_DATA *rm = ch->in_room;
light.c:        if ((obj = ch->equipment[i]) != NULL && GET_ITEM_TYPE(obj) == ITEM_LIGHT && IS_LIT(obj)) {
light.c:    ROOM_DATA *rm = ch->in_room;
light.c:        if ((obj = ch->equipment[i]) != NULL && GET_ITEM_TYPE(obj) == ITEM_LIGHT && IS_LIT(obj)) {
light.c:        if ((obj = ch->equipment[i]) != NULL && GET_ITEM_TYPE(obj) == ITEM_LIGHT) {
light.c:        (ch != NULL ? ch->in_room : obj->in_room != NULL ? obj->in_room : on_obj !=
limits.c:        free((char *) ch->skills[sk]);
limits.c:    ch->skills[sk] = (struct char_skill_data *) 0;
limits.c:    CREATE(ch->skills[sk], struct char_skill_data, 1);
limits.c:    ch->skills[sk]->learned = perc;
limits.c:    ch->skills[sk]->taught_flags = 0;
limits.c:    ch->skills[sk]->last_gain = 0;
limits.c:    ch->skills[sk]->rel_lev = 0;
limits.c:        /* if (!ch->skills[SKILL_WILLPOWER]) */
limits.c:        /* ch->skills[SKILL_WILLPOWER]->taught = TRUE; */
limits.c:        /* if (!ch->skills[PSI_CONTACT]) */
limits.c:        /*      ch->skills[PSI_CONTACT]->taught = TRUE; */
limits.c:        /* if (!ch->skills[PSI_BARRIER]) */
limits.c:        /* ch->skills[PSI_BARRIER]->taught = TRUE; */
limits.c:                /* if (!ch->skills[new_skill[i]]) */
limits.c:                /* ch->skills[new_skill[i]]->taught = TRUE; */
limits.c:                ch->skills[new_skill[i]]->learned += 10;
limits.c:     + (ch->skills[sk]->learned / 7));
limits.c:    if (((t = time(0)) - ch->skills[sk]->last_gain) < (SECS_PER_REAL_MIN * wt))
limits.c:    ch->skills[sk]->last_gain = t;
limits.c:    int oldsk = ch->skills[sk]->learned;
limits.c:        ch->skills[sk]->learned = MIN(ch->skills[sk]->learned + gain, 90);
limits.c:    ch->skills[sk]->learned = raw + diff;
limits.c:        free((char *) ch->skills[sk]);
limits.c:        ch->skills[sk] = (struct char_skill_data *) 0;
limits.c:    if (oldsk != ch->skills[sk]->learned)
limits.c:                oldsk, ch->skills[sk]->learned);
limits.c:    if (raw >= guild[(int) ch->player.guild].skill_max_learned[sk] - 10) {
limits.c:            if (guild[(int) ch->player.guild].skill_prev[i] == sk)
limits.c:                    init_skill(ch, i, guild[(int) ch->player.guild].skill_percent[i]);
limits.c:    if (raw >= sub_guild[(int) ch->player.sub_guild].skill_max_learned[sk] - 10) {
limits.c:            if (sub_guild[(int) ch->player.sub_guild].skill_prev[i] == sk)
limits.c:                    init_skill(ch, i, sub_guild[(int) ch->player.sub_guild].skill_percent[i]);
limits.c:        ch->specials.apply_saving_throw[n] = saving_throw[j][n];
limits.c:            ch->specials.apply_saving_throw[n] += end_app[GET_END(ch)].end_saves;
limits.c:            ch->specials.apply_saving_throw[n] += agl_app[GET_AGL(ch)].reaction;
limits.c:            /*        (ch->skills[n])) */
limits.c:            if ((ch->skills[n]->learned) > max) {
limits.c:                max = ch->skills[n]->learned;
limits.c:            ch->specials.language = check;
limits.c:    if (IS_SET(ch->skills[accent]->taught_flags, SKILL_FLAG_NOGAIN))
limits.c:    wait = MAX(5, (60 - wis_app[GET_WIS(ch)].learn) + (ch->skills[accent]->learned / 9));
limits.c:    if (((t = time(0)) - ch->skills[accent]->last_gain) < (SECS_PER_REAL_MIN * wait))
limits.c:    ch->skills[accent]->last_gain = t;
limits.c:        ch->skills[accent]->learned += amount;
limits.c:        ch->skills[accent]->learned = MIN(ch->skills[accent]->learned, 100);
limits.c:        /* if (!ch->skills[lang]) */
limits.c:    if (IS_SET(ch->skills[lang]->taught_flags, SKILL_FLAG_NOGAIN))
limits.c:    wait = MAX(5, (60 - wis_app[GET_WIS(ch)].learn) + (ch->skills[lang]->learned / 9));
limits.c:    if (((t = time(0)) - ch->skills[lang]->last_gain) < (SECS_PER_REAL_MIN * wait))
limits.c:    ch->skills[lang]->last_gain = t;
limits.c:        ch->skills[lang]->learned += amount;
limits.c:        ch->skills[lang]->learned = MIN(ch->skills[lang]->learned, 100);
limits.c:    ch->abilities.off /= 2;
limits.c:    ch->abilities.def /= 2;
limits.c:            /* if (ch->skills[sk]) */
limits.c:            if (ch->skills[sk]->rel_lev > tot)
limits.c:                tot = ch->skills[sk]->rel_lev;
limits.c:            /* if (ch->skills[sk]) */
limits.c:            if (ch->skills[sk]->rel_lev <= 0) {
limits.c:                free((char *) ch->skills[sk]);
limits.c:                ch->skills[sk] = 0;
limits.c:                ch->skills[sk]->rel_lev--;
limits.c:            ch->specials.conditions[i] = -1;
limits.c:    if (ch->desc)
limits.c:      if ( (ch->desc->idle / (WAIT_SEC *20)) > 60 ) 
limits.c:   if (++ch->specials.timer > 8)
limits.c:   if (!IS_IMMORTAL(ch) && !ch->specials.was_in_room && ch->in_room) 
limits.c:   ch->specials.was_in_room = ch->in_room;
limits.c:   if (ch->specials.fighting) {
limits.c:   stop_fighting(ch->specials.fighting);
limits.c:    if (!ch || !ch->in_room)
limits.c:    struct weather_node *wn = find_weather_node(ch->in_room);
limits.c:        if (IS_SET(ch->in_room->room_flags, RFL_RESTFUL_SHADE))
limits.c:    if (IS_SET(ch->in_room->room_flags, RFL_INDOORS))
limits.c:    if ( ch->desc && ch->desc->term
limits.c:     && IS_SET(ch->specials.act, CFL_INFOBAR)) {
limits.c:        adjust_infobar(ch->desc, type, buf);
limits.c:        for( af = ch->affected; af; af = af->next ) 
limits.c:                     !IS_NPC(ch) ? ch->account : "", !IS_NPC(ch) ? ") " : "",
limits.c:                     ch->in_room->number);
limits.c:            for (rch = ch->in_room->people; rch; rch = rch->next_in_room)
limits.c:                    free(ch->player.info[1]);
limits.c:                     GET_NAME(ch), ch->in_room->number);
limits.c:                    ch->player.info[1] = strdup(buf);
limits.c:                    if ((room_in_city(ch->in_room) == CITY_ALLANAK)
limits.c:                        || (room_in_city(ch->in_room) == CITY_TULUK))
limits.c:                    if (ch->in_room->sector_type == SECT_CITY)
limits.c:                    if (ch->equipment[WEAR_LEGS]) {      // leggings smelly
limits.c:                        obj = ch->equipment[WEAR_LEGS];
limits.c:                    if (ch->equipment[ES]) {
limits.c:                        obj = ch->equipment[ES];
limits.c:                        obj_to_room(unequip_char(ch, ES), ch->in_room);
limits.c:                        drop_light(obj, ch->in_room);
limits.c:                    if (ch->equipment[EP]) {
limits.c:                        obj = ch->equipment[EP];
limits.c:                        obj_to_room(unequip_char(ch, EP), ch->in_room);
limits.c:                        drop_light(obj, ch->in_room);
limits.c:                    if (ch->equipment[ETWO]) {
limits.c:                        obj = ch->equipment[ETWO];
limits.c:                        obj_to_room(unequip_char(ch, ETWO), ch->in_room);
limits.c:                        drop_light(obj, ch->in_room);
limits.c:                    if (ch->specials.subduing)
limits.c:                            free(ch->player.info[1]);
limits.c:                                GET_NAME(ch), ch->in_room->number);
limits.c:                            ch->player.info[1] = strdup(buf);
limits.c:    d = ch->desc;
limits.c:    if (d && !d->connected && d->term && IS_SET(ch->specials.act, CFL_INFOBAR)){
limits.c:        ch->old.hp = GET_HIT(ch);
limits.c:        ch->old.max_hp = GET_MAX_HIT(ch);
limits.c:        ch->old.mana = GET_MANA(ch);
limits.c:        ch->old.max_mana = GET_MAX_MANA(ch);
limits.c:        ch->old.move = GET_MOVE(ch);
limits.c:        ch->old.max_move = GET_MAX_MOVE(ch);
limits.c:        ch->old.stun = GET_STUN(ch);
limits.c:        ch->old.max_stun = GET_MAX_STUN(ch);
limits.c:        switch( ch->in_room->sector_type ) {
limits.c:        if (IS_SET(ch->in_room->room_flags, RFL_INDOORS))
limits.c:        if (IS_SET(ch->in_room->room_flags, RFL_RESTFUL_SHADE))
limits.c:                     !IS_NPC(ch) ? ch->account : "", 
limits.c:                     ch->in_room->number);
limits.c:                            real_time_passed((time(0) - ch->player.time.logon) +
limits.c:                             ch->player.time.played, 0);
limits.c:                          || (ch->player.dead && !strcmp(ch->player.dead, "rebirth")))
limits.c:                         && !IS_SET(ch->specials.act, CFL_NO_DEATH)) {
limits.c:                            if (ch->player.info[1])
limits.c:                                free(ch->player.info[1]);
limits.c:                            ch->player.info[1] = strdup(buf);
limits.c:                && (!IS_SET(ch->in_room->room_flags, RFL_INDOORS))) {
limits.c:                        if (!number(0, chance) && !ch->specials.fighting)
limits.c:                    if (IS_SET(ch->in_room->room_flags, RFL_INDOORS)
limits.c:                            wn = find_weather_node(ch->in_room);
limits.c:                        if (ch->in_room
limits.c:                            && (ch->in_room->sector_type == SECT_NILAZ_PLANE
limits.c:                                || IS_SET(ch->in_room->room_flags, RFL_NO_ELEM_MAGICK)))
limits.c:                        if (ch->in_room && IS_DARK(ch->in_room))
limits.c:                    if (IS_SET(ch->in_room->room_flags, RFL_DMANAREGEN))
limits.c:                        if (wn->zone == ch->in_room->zone)
limits.c:                        && !IS_SET(ch->in_room->room_flags, RFL_INDOORS))
limits.c:                    if (!IS_SET(ch->in_room->room_flags, RFL_NO_ELEM_MAGICK)
limits.c:                 && (IS_SET(ch->specials.act, CFL_MOUNT)
limits.c:                        if (ch->in_room->sector_type == SECT_DESERT)
limits.c:                        else if (ch->in_room->sector_type == SECT_INSIDE)
limits.c:                         && !ch->specials.fighting) {
limits.c:    if (!IS_NPC(ch) && IS_SET(ch->specials.act, CFL_AGGRESSIVE))
limits.c:    pts = ch->points.max_hit;
limits.c:     * if (ch->specials.eco) 
limits.c:     * alt = (ch->specials.eco / 3);
limits.c:     * pts += ch->points.max_hit;
limits.c:    pts = ch->points.max_stun;
limits.c:    if(ch->specials.guarding 
limits.c:     || ch->specials.dir_guarding > -1 
limits.c:     ||  ch->specials.obj_guarding) 
limits.c:    pts += ch->points.mana_bonus;
limits.c:    pts = 100 + end_app[GET_END(ch)].move_bonus + ch->points.move_bonus;
limits.c://    if (ch->specials.eco != 0)
limits.c://        alt = (ch->specials.eco / 3);
limits.c:        /*  if (ch->skills[TOL_ALCOHOL]) */
limits.c:        tol = ch->skills[TOL_ALCOHOL]->learned;
list.c:    if (!(clan = ch->player.tribe)) {
magick.c:    for (tmp_af = ch->affected; tmp_af; tmp_af = tmp_af->next) {
magick.c:    if (ch->equipment[WEAR_NECK]
magick.c:        && !strcmp(OSTR(ch->equipment[WEAR_NECK], short_descr), "a dull black gem"))
magick.c:    if (ch->equipment[WEAR_ABOUT_THROAT]
magick.c:        && !strcmp(OSTR(ch->equipment[WEAR_ABOUT_THROAT], short_descr), "a dull black gem"))
magick.c:    if (!(IS_SET(ch->in_room->room_flags, RFL_MAGICK_OK))) {
magick.c:        if (ch->in_room->city == CITY_ALLANAK) {
magick.c:    if (room_in_city(ch->in_room) != ct)
magick.c:            //      if (city[ct].tribe == ch->player.tribe)
magick.c:    if (room_in_city(ch->in_room) != ct)
magick.c:  sprintf(creator_name, "[CREATED_BY_%s_(%s)]", ch->name, ch->account);
magick.c:    sprintf(creator_name, "[CREATED_BY_%s_(%s)]", ch->name, ch->account);
magick.c:    if (!ch->desc)
magick.c:      sprintf(creator_name, "[CREATED_BY__m%d]", ch->nr);
magick.c:      if (ch->desc->original)
magick.c:        sprintf(creator_name, "[CREATED_BY_%s_(%s)_while_playing_m%d]", ch->desc->original->name, ch->desc->original->account, ch->nr);
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_SPL_ALARM)) {
magick.c:    if (((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))
magick.c:            || (ch->in_room->sector_type == SECT_AIR)) {
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_ASH)) {
magick.c:        sprintf(buf, "%d", npc_index[ch->nr].vnum);
magick.c:        set_room_extra_desc_value(ch->in_room, "[ALARM_SPL_PC_info]", buf);
magick.c:        set_room_extra_desc_value(ch->in_room, "[ALARM_SPL_PC_info]", MSTR(ch, name));
magick.c:        set_room_extra_desc_value(ch->in_room, "[ALARM_SPL_ACCOUNT_info]", ch->account);
magick.c:    MUD_SET_BIT(ch->in_room->room_flags, RFL_SPL_ALARM);
magick.c:    set_room_extra_desc_value(ch->in_room, ename, edesc);
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_SANDSTORM)) {
magick.c:    sector = ch->in_room->sector_type;
magick.c:    ROOM_DATA *trm = ch->in_room;
magick.c:        ch->specials.eco = MAX(-100, (ch->specials.eco - 1));
magick.c:    sector = ch->in_room->sector_type;
magick.c:    if (ch->in_room->sector_type == SECT_SHALLOWS || ch->in_room->sector_type == SECT_SILT) {
magick.c:    customLightObjVnum = find_ex_description("[CUSTOM_BALL_OF_LIGHT_VNUM]", ch->ex_description, TRUE);
magick.c:            if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:            if (ch->specials.eco >= -5)
magick.c:            obj_to_room(tmp_obj, ch->in_room);
magick.c:            light_a_light(tmp_obj, ch->in_room);
magick.c:            light_a_light(tmp_obj, ch->in_room);
magick.c:        obj_to_room(tmp_obj, ch->in_room);
magick.c:        light_a_light(tmp_obj, ch->in_room);
magick.c:      if (!IS_SET(ch->specials.act, CFL_CRIM_ALLANAK)) {
magick.c:                  ch->in_room->number);
magick.c:                ch->in_room->number);
magick.c:      was_in = ch->in_room;
magick.c:      if (ch->in_room->zone == 34) {      /* Elemental Planes zone 34 */
magick.c:        sector = ch->in_room->sector_type;
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER)) {
magick.c:    //  if (ch->in_room->sector_type == SECT_NILAZ_PLANE) {
magick.c:    if (ch->in_room->sector_type == SECT_SHALLOWS && ch->in_room->sector_type == SECT_SILT) {
magick.c:    if (ch->in_room->sector_type == SECT_AIR) {
magick.c:    if ((ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))
magick.c:        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_AIR_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)) {
magick.c:    burrow->direction[DIR_UP]->to_room = ch->in_room;
magick.c:    sector = ch->in_room->sector_type;
magick.c:    ch->specials.riding = NULL;
magick.c:    if (ch->specials.fighting == victim || ch->specials.alt_fighting == victim) {
magick.c:    if ((ch->in_room->sector_type == SECT_SILT)
magick.c:        || (ch->in_room->sector_type == SECT_SHALLOWS)
magick.c:        || (ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)) {
magick.c:        tar_ch = get_random_non_immortal_in_room(ch->in_room);
magick.c:                         ch->in_room);
magick.c:                         GET_NAME(tar_ch), GET_NAME(ch), ch->in_room->number);
magick.c:                send_to_room("The lightning swirls in the air, then dissipates.\n\r", ch->in_room);
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_DARK)) {
magick.c:    MUD_SET_BIT(ch->in_room->room_flags, RFL_DARK);
magick.c:    sector = ch->in_room->sector_type;
magick.c:    new_event(EVNT_REMOVE_DARK, level * 30 * 60, 0, 0, 0, ch->in_room, 0);
magick.c:            if (ch->in_room->sector_type == SECT_SILT)
magick.c:            if (ch->in_room->sector_type == SECT_SILT)
magick.c:            if (ch->in_room->sector_type == SECT_SILT)
magick.c:        obj_to_room(tmp_obj, ch->in_room);
magick.c:    if (ch->in_room->sector_type == SECT_FIRE_PLANE) {
magick.c:            if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:                if (ch->in_room->sector_type == SECT_SILT)
magick.c:    if (ch->in_room->sector_type == SECT_FIRE_PLANE) {
magick.c:            if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:                if (ch->in_room->sector_type == SECT_SILT)
magick.c:    targch = ch->specials.contact;
magick.c:    sector = ch->in_room->sector_type;
magick.c:    sector = ch->in_room->sector_type;
magick.c:    if (ch->in_room->sector_type == SECT_AIR) {
magick.c:    if (ch->in_room->sector_type == SECT_SILT)
magick.c:    qroomlogf(QUIET_COMBAT, ch->in_room, "demonfire base dam:  %d", dam);
magick.c:    if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:    qroomlogf(QUIET_COMBAT, ch->in_room, "demonfire final dam: %d", dam);
magick.c:    if (ch->in_room->sector_type == SECT_SILT) {
magick.c:    if (ch->in_room->sector_type != SECT_SHADOW_PLANE) {
magick.c:    if (ch->in_room->sector_type == SECT_SILT) {
magick.c:    if (ch->in_room->sector_type == SECT_SILT) {
magick.c:    if (ch->in_room->sector_type == SECT_SILT) {
magick.c:        //      for( obj = ch->carrying; obj; obj = obj->next_content )
magick.c:        if (IS_SET(ch->in_room->room_flags, RFL_RESTFUL_SHADE)) {
magick.c:            REMOVE_BIT(ch->in_room->room_flags, RFL_RESTFUL_SHADE);
magick.c:        if (IS_SET(ch->in_room->room_flags, RFL_SPL_ALARM)) {
magick.c:	    remove_alarm_spell(ch->in_room);
magick.c:            if (ch->in_room->direction[dir]) {  /* is there an exit that way? */
magick.c:                if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL)) { /* Does exit have wall of sand on it? */
magick.c:                    REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL);
magick.c:                    send_to_room(buf, ch->in_room);
magick.c:                            if (back->to_room == ch->in_room) {
magick.c:    if ((ch->in_room->sector_type == SECT_INSIDE) || (ch->in_room->sector_type == SECT_CITY)) {
magick.c:    if (ch->specials.eco < 0) {
magick.c:    if (ch->specials.eco == 0) {
magick.c:    ch->specials.eco = MAX(-100, ch->specials.eco - level);
magick.c:    if (room == ch->in_room) return TRUE;  // No messages, but continue pathing
magick.c:    for (tch = room->people; tch; tch = tch->next_in_room) {
magick.c:    if (!ch->in_room) {
magick.c:    if (ch->in_room->sector_type == SECT_AIR_PLANE) {
magick.c:    if ((ch->in_room->sector_type == SECT_INSIDE) || (ch->in_room->sector_type == SECT_CAVERN))
magick.c:    else if ((ch->in_room->sector_type == SECT_CITY) || (ch->in_room->sector_type == SECT_RUINS))
magick.c:    sector = ch->in_room->sector_type;
magick.c:    generic_astar(ch->in_room, 0, level - 1, (float)level - 1.0, 0, RFL_NO_ELEM_MAGICK | RFL_NO_MAGICK,
magick.c:    for (tch = ch->in_room->people; tch; tch = next_tch) {
magick.c:        next_tch = tch->next_in_room;
magick.c:    if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:            if (ch->in_room->sector_type == SECT_FIRE_PLANE) {
magick.c:            if (ch->specials.riding) {
magick.c:                ch->specials.riding = 0;
magick.c:    sector = ch->in_room->sector_type;
magick.c:    if (ch->in_room->sector_type == SECT_AIR)
magick.c:    else if (ch->in_room->sector_type == SECT_SILT)
magick.c:    if (ch->in_room->sector_type == SECT_SILT)
magick.c:        sector = ch->in_room->sector_type;
magick.c:    else if (ch->in_room->sector_type == SECT_SILT)
magick.c:        sector = ch->in_room->sector_type;
magick.c:    if (ch->in_room->sector_type == SECT_SHADOW_PLANE)
magick.c:    else if (ch->in_room->sector_type == SECT_SILT)
magick.c:    if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:        obj_to_room(tmp_obj, ch->in_room);
magick.c:    if (ch->in_room->sector_type == SECT_SHADOW_PLANE) {
magick.c:    qroomlogf(QUIET_COMBAT, ch->in_room, "fireball base dam:  %d", dam);
magick.c:        if ((ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:            || (ch->in_room->sector_type == SECT_SHADOW_PLANE))
magick.c:        if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:        if (ch->in_room->sector_type == SECT_SHADOW_PLANE) {
magick.c:        qroomlogf(QUIET_COMBAT, ch->in_room, "fireball final dam: %d", dam);
magick.c:        if ((ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:            || (ch->in_room->sector_type == SECT_SHADOW_PLANE))
magick.c:        if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:        if (ch->in_room->sector_type == SECT_SHADOW_PLANE) {
magick.c:    if (ch->in_room->sector_type == SECT_ROAD)
magick.c:    if (ch->in_room->sector_type == SECT_AIR)
magick.c:    else if (ch->in_room->sector_type == SECT_AIR_PLANE) {
magick.c:    if ((ch->in_room->sector_type == SECT_AIR_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_EARTH_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)) {
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_NO_ELEM_MAGICK)) {
magick.c:    MUD_SET_BIT(ch->in_room->room_flags, RFL_NO_ELEM_MAGICK);
magick.c:    for (tch = ch->in_room->people; tch; tch = next_tch) {
magick.c:        next_tch = tch->next_in_room;
magick.c:    new_event(EVNT_REMOVE_NOELEMMAGICK, level * 30 * 60, 0, 0, 0, ch->in_room, 0);
magick.c:    sector = ch->in_room->sector_type;
magick.c:            sprintf(logbuf, "%s cast fury upon %s, instigating mul rage in room %d.", GET_NAME(ch), (ch == victim ? "themself" : GET_NAME(victim)), ch->in_room->number);
magick.c:            if (ch->specials.eco >= 0) {
magick.c:        char_to_room(victim, ch->in_room);
magick.c:                ch->in_room->number);
magick.c:        char_to_room(victim, ch->in_room);
magick.c:    for (follower = ch->followers; follower; follower = follower->next) {
magick.c:    qroomlogf(QUIET_LOG, ch->in_room,
magick.c:        sector = ch->in_room->sector_type;
magick.c:    if (!ch->in_room)
magick.c:            ch->skills[SPELL_GOLEM]->learned = 0;
magick.c:        if ((IS_SET(ch->in_room->room_flags, RFL_INDOORS))
magick.c:        if (ch->in_room->sector_type != SECT_DESERT) {
magick.c:        if (IS_SET(ch->in_room->room_flags, RFL_INDOORS)) {
magick.c:            && (!(IS_SET(ch->in_room->room_flags, RFL_INDOORS)))) {
magick.c:    if ((ch->in_room->sector_type == SECT_EARTH_PLANE)
magick.c:        || ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))) {
magick.c:        char_to_room(mob, ch->in_room);
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER)) {
magick.c:    if ((ch->in_room->sector_type == SECT_SILT)
magick.c:        && (!IS_SET(ch->in_room->room_flags, RFL_SANDSTORM))) {
magick.c:        MUD_SET_BIT(ch->in_room->room_flags, RFL_SANDSTORM);
magick.c://    gamelogf ("distance is %d", get_land_distance (ch->in_room, victim->in_room));
magick.c:    if (choose_exit_name_for(victim->in_room, ch->in_room, ch_command, level * 10, 0) == -1) {
magick.c:                ch->in_room->number);
magick.c:                ch->in_room->number);
magick.c:        for (tch = victim->in_room->people; tch; tch = tch->next_in_room)
magick.c:            REMOVE_BIT(tch->specials.affected_by, CHAR_AFF_SUBDUED);
magick.c:    for (tch = victim->in_room->people; tch; tch = tch->next_in_room)
magick.c:        if ((tch != victim) && (victim == tch->master))
magick.c:    if ((choose_exit_name_for(victim->in_room, ch->in_room, ch_command, level * 10, 0) != -1)
magick.c:        && (victim->in_room != ch->in_room))
magick.c:    if (ch->in_room->sector_type == SECT_AIR)
magick.c:    if (ch->in_room->sector_type == SECT_AIR_PLANE)
magick.c:        if (choose_exit_name_for(victim->in_room, ch->in_room, ch_command, level * 10, 0) != -1) {
magick.c:                tmpob = find_wagon_for_room(ch->in_room);
magick.c:                        dest_room = ch->in_room;
magick.c:        if (victim->in_room == ch->in_room)
magick.c:    if ((ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))) {
magick.c:    char_to_room(victim, ch->in_room);
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER)) {
magick.c:    if (ch->in_room->sector_type == SECT_FIRE_PLANE) {
magick.c:    if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER)) {
magick.c:    if (ch->in_room->sector_type == SECT_FIRE_PLANE) {
magick.c:    if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:    char_to_room(mob, ch->in_room);
magick.c:    if ((ch->in_room->sector_type == SECT_SILT) && (GET_GUILD(ch) != GUILD_VOID_ELEMENTALIST)) {
magick.c:    if (((ch->in_room->sector_type == SECT_CAVERN) && (GET_GUILD(ch) == GUILD_STONE_ELEMENTALIST))
magick.c:        || ((IS_SET(ch->in_room->room_flags, RFL_DARK))
magick.c:    else if (((ch->in_room->sector_type == SECT_AIR) && (GET_GUILD(ch) == GUILD_WIND_ELEMENTALIST))
magick.c:             || (((ch->in_room->sector_type == SECT_NILAZ_PLANE)
magick.c:                 || ((ch->in_room->sector_type == SECT_ROAD)
magick.c:    else if (((IS_SET(ch->in_room->room_flags, RFL_PLANT_HEAVY))
magick.c:              || (IS_SET(ch->in_room->room_flags, RFL_PLANT_SPARSE)))
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER)) {
magick.c:    if ((IS_SET(ch->in_room->room_flags, RFL_INDOORS))
magick.c:        || (ch->in_room->sector_type == SECT_CAVERN)) {
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER)) {
magick.c:    if (ch->in_room->sector_type == SECT_SILT)
magick.c:    if (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)
magick.c:        for (curr_ch = ch->in_room->people; curr_ch; curr_ch = next_ch) {
magick.c:            next_ch = curr_ch->next_in_room;
magick.c:            if (IS_SET(curr_ch->specials.act, CFL_MOUNT)) {
magick.c:    if (ch->in_room->sector_type == SECT_SILT) {
magick.c:    if (ch->in_room->sector_type == SECT_FIRE_PLANE) {
magick.c:    if ((GET_RACE(tar_ch) == RACE_VAMPIRE) || (IS_SET(tar_ch->specials.act, CFL_UNDEAD))) {
magick.c:    if (ch->in_room->sector_type == SECT_DESERT) {
magick.c:        if (((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))
magick.c:            || (ch->in_room->sector_type == SECT_EARTH_PLANE)) {
magick.c:    if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:    if (ch->in_room->sector_type == SECT_SILT) {
magick.c:    } else if (ch->in_room->sector_type == SECT_LIGHTNING_PLANE) {
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER)) {
magick.c:        if (ch->equipment[EP]) {
magick.c:                ch->equipment[EP], 0, TO_CHAR);
magick.c:    if (((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))
magick.c:        || (ch->in_room->sector_type == SECT_WATER_PLANE)) {
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_INDOORS)
magick.c:        || ((ch->in_room->sector_type == SECT_INSIDE)
magick.c:            || (ch->in_room->sector_type == SECT_CAVERN))) {
magick.c:    for (temp = ch->in_room->contents; temp; temp = next_obj) {
magick.c:    obj_to_room(storm, ch->in_room);
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER)) {
magick.c:        obj_to_room(tmp_obj, ch->in_room);
magick.c:    for (tmp_obj = ch->carrying; tmp_obj; tmp_obj = tmp_obj->next_content) {
magick.c:    if (!ch->in_room) {
magick.c:    if ((ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_EARTH_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_AIR_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_NILAZ_PLANE)) {
magick.c:    if (ch->in_room->zone == RESERVED_Z) {
magick.c:    room_num = ch->in_room->number;
magick.c:            bdesc_list[ch->in_room->zone][ch->in_room->bdesc_index].desc, ch->in_room->description ? ch->in_room->description : "");
magick.c:    if (((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))
magick.c:        || (ch->in_room->sector_type == SECT_EARTH_PLANE)) {
magick.c:    char_to_room(victim, ch->in_room);
magick.c:    if ((IS_SET(ch->in_room->room_flags, RFL_INDOORS))
magick.c:        || (ch->in_room->sector_type == SECT_CAVERN)) {
magick.c:    if (ch->in_room->sector_type == SECT_FIRE_PLANE) {
magick.c:    if (ch->in_room->sector_type == SECT_SILT)
magick.c:    if (ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        for (curr_ch = ch->in_room->people; curr_ch; curr_ch = next_ch) {
magick.c:            next_ch = curr_ch->next_in_room;
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_NO_MOUNT)) {
magick.c:    if ((ch->in_room->sector_type <= SECT_CITY) && (GET_GUILD(ch) == GUILD_STONE_ELEMENTALIST)) {
magick.c:    char_to_room(mob, ch->in_room);
magick.c:    if ((ch->in_room->sector_type == SECT_CITY)
magick.c:        || ((ch->in_room->sector_type == SECT_CAVERN)
magick.c:            || (ch->in_room->sector_type == SECT_INSIDE))) {
magick.c:    if (ch->in_room->sector_type == SECT_FIRE_PLANE) {
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER)) {
magick.c:    if (ch->in_room->sector_type == SECT_WATER_PLANE) {
magick.c:    test_obj = get_obj_in_list(ch, "oasis_spellobj", ch->in_room->contents);
magick.c:    obj_to_room(tmp_obj, ch->in_room);
magick.c:    if (!(IS_SET(ch->in_room->room_flags, RFL_RESTFUL_SHADE))) {
magick.c:        MUD_SET_BIT(ch->in_room->room_flags, RFL_RESTFUL_SHADE);
magick.c:        send_to_room("A restful shade descends upon you.\n\r", ch->in_room);
magick.c:        new_event(EVNT_REMOVE_SHADE, level * 3 * 60, 0, 0, 0, ch->in_room, 0);
magick.c:             ch->in_room->number);
magick.c:    if ((ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) || (ch->in_room->sector_type == SECT_SILT)) {
magick.c:    if ((ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_AIR_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_EARTH_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)) {
magick.c:        for (curr_ch = ch->in_room->people; curr_ch; curr_ch = next_ch) {
magick.c:            next_ch = curr_ch->next_in_room;
magick.c:    if ((ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_AIR_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_EARTH_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)) {
magick.c:    for (temp = ch->in_room->contents; temp; temp = next_obj) {
magick.c:    obj_to_room(hole, ch->in_room);
magick.c:        } else if (!is_on_same_plane(ch->in_room, victim->in_room)) {
magick.c:    if (find_exitable_wagon_for_room(ch->in_room)) {
magick.c:                ch->in_room->number,
magick.c:      if (room_in_city(ch->in_room) == CITY_ALLANAK) {
magick.c:        if (!IS_SET(ch->specials.act, CFL_CRIM_ALLANAK)) {
magick.c:                    ch->in_room->number,
magick.c:                  ch->in_room->number,
magick.c:                  ch->in_room->number,
magick.c:    obj_to_room(origin_portal, ch->in_room);
magick.c:    dest_portal->obj_flags.value[0] = ch->in_room->number;
magick.c:    if (!ch->desc)
magick.c:    if (ch->desc->snoop.snooping || ch->desc->snoop.snoop_by) {
magick.c:    if (ch->desc->original && level < 7) {
magick.c:                         npcnumber, (ch->in_room ? ch->in_room->number : 0));
magick.c:                     npcnumber, (ch->in_room ? ch->in_room->number : 0));
magick.c:    char_to_room(mob, ch->in_room);
magick.c:    ch->specials.eco = MAX(-100, (ch->specials.eco - drain));
magick.c:    if (!ch->desc->original)
magick.c:        ch->desc->original = ch;
magick.c:    ch->desc->character = mob;
magick.c:    mob->desc = ch->desc;
magick.c:    ch->desc = 0;
magick.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER)) {
magick.c:    if (ch->in_room->sector_type == SECT_FIRE_PLANE) {
magick.c:    if ((ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)) {
magick.c:        for (curr_ch = ch->in_room->people; curr_ch; curr_ch = next_ch) {
magick.c:            next_ch = curr_ch->next_in_room;
magick.c:            if (IS_SET(curr_ch->specials.act, CFL_MOUNT)) {
magick.c:    sector = ch->in_room->sector_type;
magick.c:        if (ch->equipment[i]) {
magick.c:            if (ch->equipment[i]->obj_flags.material == MATERIAL_CLOTH) {
magick.c:                if (ch->equipment[i]->obj_flags.type == ITEM_WORN) {
magick.c:                    sflag_to_obj(ch->equipment[i], OST_BURNED);
magick.c:                if (ch->equipment[i]->obj_flags.type == ITEM_ARMOR) {
magick.c:                if (ch->equipment[i]->obj_flags.type == ITEM_CONTAINER) {
magick.c:    if (!ch->in_room) {
magick.c:    if (((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))
magick.c:        || (ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)) {
magick.c:    for (tch = ch->in_room->people; tch; tch = next_tch) {
magick.c:        next_tch = tch->next_in_room;
magick.c:                next_tch = tch->next_in_room;
magick.c:        next_tch = tch->next;
magick.c:        if (tch->in_room && (tch->in_room != ch->in_room) && (tch->in_room != other_room)
magick.c:            && (tch->in_room->zone == ch->in_room->zone))
magick.c:  was_in = ch->in_room;
magick.c:  if (!is_on_same_plane(ch->in_room, victim->in_room)) {
magick.c:    if (IS_SET(ch->specials.act, CFL_CRIM_ALLANAK)) {
magick.c:                ch->in_room->number);
magick.c:                ch->in_room->number);
magick.c:                ch->in_room->number);
magick.c:  dist = find_dist_for(ch->in_room, victim->in_room, ch);
magick.c:        if (ch->in_room->direction[i]) {
magick.c:    if (ch->in_room->sector_type == SECT_AIR)
magick.c:    if (ch->in_room->sector_type == SECT_AIR_PLANE) {
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_RESTFUL_SHADE)) {
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_INDOORS)) {
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_NO_ELEM_MAGICK)) {
magick.c:    sector = ch->in_room->sector_type;
magick.c:    MUD_SET_BIT(ch->in_room->room_flags, RFL_RESTFUL_SHADE);
magick.c:    new_event(EVNT_REMOVE_SHADE, level * 30 * 60, 0, 0, 0, ch->in_room, 0);
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_NO_ELEM_MAGICK)) {
magick.c:    new_event(EVNT_REWIND, duration, ch, 0, 0, ch->in_room, dist);
magick.c:    if (ch->in_room->sector_type != SECT_WATER_PLANE)
magick.c:    if (!ch->in_room) {
magick.c:    sandtype = is_enough_sand(ch->in_room);
magick.c:        obj_to_room(tmp_obj, ch->in_room);
magick.c:    if (!ch->in_room) {
magick.c:    sandtype = is_enough_sand(ch->in_room);
magick.c:    obj_to_room(shelter, ch->in_room);
magick.c:    if (!ch->in_room) {
magick.c:    sandtype = is_enough_sand(ch->in_room);
magick.c:        char_to_room(mob, ch->in_room);
magick.c:    if (!ch->in_room) {
magick.c:    sandtype = is_enough_sand(ch->in_room);
magick.c:    if ((chance > number(1, 100)) && ch->in_room->direction[dir = number(0, 5)]) {
magick.c:        room = ch->in_room->direction[dir]->to_room;
magick.c:    if ((ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))) {
magick.c:        if (ch->equipment[EP]) {
magick.c:                ch->equipment[EP], 0, TO_CHAR);
magick.c:    if ((ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))) {
magick.c:    if (!ch->desc)
magick.c:    if (ch->desc->original) {
magick.c:    if (ch->desc->snoop.snooping || ch->desc->snoop.snoop_by) {
magick.c:    char_to_room(shadow, ch->in_room);
magick.c:    if (!ch->desc->original)
magick.c:        ch->desc->original = ch;
magick.c:    ch->desc->character = shadow;
magick.c:    ch->desc->original = ch;
magick.c:    shadow->desc = ch->desc;
magick.c:    ch->desc = 0;
magick.c:        if ((ch->skills[i] && skill[i].sk_class == CLASS_PSIONICS)
magick.c:            || (ch->skills[i] && skill[i].sk_class == CLASS_LANG)) {
magick.c:                init_skill(shadow, i, ch->skills[i]->learned);
magick.c:                shadow->skills[i]->learned = ch->skills[i]->learned;
magick.c:    shadow->specials.language = ch->specials.language;
magick.c:    if (ch->in_room->sector_type == SECT_SHADOW_PLANE)
magick.c:    if ((ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))) {
magick.c:        obj_to_room(tmp_obj, ch->in_room);
magick.c:    if (ch->in_room->sector_type == SECT_SHADOW_PLANE)
magick.c:            strcpy(msg1, "A pitch-black arc of shadow crosses the sky, blotting out all light.");
magick.c:            strcpy(msg2, "A pitch-black arc of shadow crosses the sky, blotting out all light.");
magick.c:            strcpy(msg1, "A pitch-black arc of shadow crosses the sky, blotting out all light.");
magick.c:            strcpy(msg2, "A pitch-black arc of shadow crosses the sky, blotting out all light.");
magick.c:        if (!IS_SET(ch->in_room->room_flags, RFL_DARK)) {
magick.c:            MUD_SET_BIT(ch->in_room->room_flags, RFL_DARK);
magick.c:            new_event(EVNT_REMOVE_DARK, level * 30 * 60, 0, 0, 0, ch->in_room, 0);
magick.c:    if ((ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))) {
magick.c:        obj_to_room(tmp_obj, ch->in_room);
magick.c:    if ((ch->in_room->sector_type == SECT_EARTH_PLANE)
magick.c:        || ((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))) {
magick.c:        obj_to_room(tmp_obj, ch->in_room);
magick.c:        obj_to_room(tmp_obj, ch->in_room);
magick.c:    if ((ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_AIR_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_EARTH_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)) {
magick.c:    if (ch->in_room->sector_type == SECT_NILAZ_PLANE)
magick.c:    if (!victim || !victim->in_room || (ch && !ch->in_room)) {
magick.c:    if (path_from_to_for(ch->in_room, victim->in_room, max_distance, MAX_STRING_LENGTH, buf, victim)
magick.c:        for (temp = ch->in_room->people; temp; temp = temp->next)
magick.c:    if (ch->specials.eco == 0) {
magick.c:    if (ch->specials.eco < 0) {
magick.c:        life = ((level * ch->specials.eco) / 7);
magick.c:    if ((ch->in_room->sector_type == SECT_CITY) || (ch->in_room->sector_type == SECT_AIR)
magick.c:        || (ch->in_room->sector_type == SECT_INSIDE)) {
magick.c:    if (life > ch->specials.eco)
magick.c:        life = ch->specials.eco;
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_PLANT_HEAVY))
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_PLANT_SPARSE))
magick.c:        ch->specials.eco = MAX(0, ch->specials.eco - life);
magick.c:                     ch->in_room);
magick.c:        if (IS_SET(ch->in_room->room_flags, RFL_ASH))
magick.c:            REMOVE_BIT(ch->in_room->room_flags, RFL_ASH);
magick.c:                if (wn->zone == ch->in_room->zone)
magick.c:    if (((ch->in_room->sector_type == SECT_NILAZ_PLANE) && (GET_GUILD(ch) != GUILD_DEFILER))
magick.c:        || (ch->in_room->sector_type == SECT_EARTH_PLANE)) {
magick.c:    char_to_room(victim, ch->in_room);
magick.c:        if (ch->in_room->sector_type == SECT_EARTH_PLANE) {
magick.c:    if (ch->in_room->sector_type == SECT_EARTH_PLANE) {
magick.c:    if (!is_on_same_plane(ch->in_room, victim->in_room)) {
magick.c:        && ((choose_exit_name_for(ch->in_room, victim->in_room, ch_comm, 20 * level, ch)) == -1)) {
magick.c:      if (!IS_SET(ch->specials.act, CFL_CRIM_ALLANAK)) {
magick.c:                  ch->in_room->number,
magick.c:      ROOM_DATA *was_in = ch->in_room;
magick.c:    target = ch->in_room;
magick.c:        if (!is_on_same_plane(obj->in_room, ch->in_room)) {
magick.c:        if (ch->in_room->zone == 34) {  /* Elemental Planes zone 34 */
magick.c:            sector = ch->in_room->sector_type;
magick.c:                basenum = floor(ch->in_room->number / 100) * 100;
magick.c:      if (IS_SET(ch->specials.act, CFL_CRIM_ALLANAK)) {
magick.c:                  ch->in_room->number);
magick.c:                  ch->in_room->number);
magick.c:                ch->in_room->number);
magick.c:    for (curr_ch = ch->in_room->people; curr_ch; curr_ch = next_ch) {
magick.c:        next_ch = curr_ch->next_in_room;
magick.c:               && (!IS_SET(curr_ch->specials.act, CFL_UNDEAD))
magick.c:               || (IS_SET(curr_ch->specials.act, CFL_MOUNT))) {
magick.c:    ROOM_DATA *rm1 = ch->in_room, *rm2 = victim->in_room;
magick.c:    ROOM_DATA *was_rm1 = ch->in_room, *was_rm2 = victim->in_room;
magick.c:    if (!ch->specials.contact || (ch->specials.contact && ch->specials.contact != victim)) {
magick.c:    if (!is_on_same_plane(ch->in_room, victim->in_room)) {
magick.c:    if (IS_SET(ch->in_room->room_flags, RFL_NO_MAGICK)
magick.c:        || IS_SET(ch->in_room->room_flags, RFL_IMMORTAL_ROOM)
magick.c:        || IS_SET(ch->in_room->room_flags, RFL_NO_ELEM_MAGICK)
magick.c:        ROOM_DATA *was_in = ch->in_room;
magick.c:        if (!IS_SET(ch->specials.act, CFL_CRIM_ALLANAK)) {
magick.c:                    ch->in_room->number);
magick.c:                  ch->in_room->number);
magick.c:                ch->in_room->number);
magick.c:                ch->in_room->number);
magick.c:    from_room = ch->in_room;
magick.c:    obj_to_room(origin_portal, ch->in_room);
magick.c:    if ((ch->in_room->sector_type == SECT_FIRE_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_WATER_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_AIR_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_EARTH_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)
magick.c:        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)) {
magick.c:        sector = ch->in_room->sector_type;
magick.c:        || ((affected_by_spell(victim, SPELL_FLY)) || (ch->in_room->sector_type == SECT_AIR)))
magick.c:    if ((IS_SET(ch->in_room->room_flags, RFL_PLANT_SPARSE)
magick.c:         || (IS_SET(ch->in_room->room_flags, RFL_PLANT_HEAVY)))) {
magick.c:        test_obj = get_obj_in_list(ch, "wither_obj", ch->in_room->contents);
magick.c:        obj_to_room(tmp_obj, ch->in_room);
magick.c:		    if (ch->specials.eco < 0) {
magick.c:                    free(ch->player.info[1]);
magick.c:                        GET_NAME(ch), ch->in_room->number);
magick.c:                    ch->player.info[1] = strdup(buf);
magick.c:    CHAR_DATA *target = ch->specials.contact;
mail.c:    if (ch->points.obsidian < cost) {
mail.c:        ch->points.obsidian -= cost;
mail.c:    if (!(mail = get_obj_in_list_vis(ch, mail_name, ch->carrying))) {
mail.c:    if (!(mail = get_obj_in_list_vis(ch, mail_name, ch->carrying))) {
mail.c:            head_object = ch->carrying;
mail.c:    else if ((ch->player.tribe == 28) && (IS_SET(ch->specials.act, CFL_CLANLEADER)))
mail.c:                ch->points.obsidian += cost;
mail.c:    if (ch->player.extkwds)
mail.c:        strcat(keywords, ch->player.extkwds);
mcreation.c:    char_to_room(npc, ch->in_room);
mcreation.c:    if (ch->description) {
mcreation.c:        old = ch->description;
mcreation.c:    CREATE(ch->description, char, strlen(text_to_append) + strlen(old) + 2);
mcreation.c:    strcpy(ch->description, old);
mcreation.c:    strcat(ch->description, text_to_append);
mcreation.c:    if (!ch->desc)
mcreation.c:        zone = ch->in_room->zone;
mcreation.c:        char_to_room(vict, ch->in_room);
memory.c:    if (!IS_NPC(ch) || IS_SET(ch->specials.act, CFL_UNIQUE))
memory.c:    for (tmpmem = ch->specials.hates; tmpmem; tmpmem = tmpmem->next)
memory.c:    if (!IS_NPC(ch) || IS_SET(ch->specials.act, CFL_UNIQUE))
memory.c:    for (tmpmem = ch->specials.fears; tmpmem; tmpmem = tmpmem->next)
memory.c:    if (!IS_NPC(ch) || IS_SET(ch->specials.act, CFL_UNIQUE))
memory.c:    for (tmpmem = ch->specials.likes; tmpmem; tmpmem = tmpmem->next)
memory.c:    tmpmem->next = ch->specials.hates;
memory.c:    ch->specials.hates = tmpmem;
memory.c:    tmpmem->next = ch->specials.hates;
memory.c:    ch->specials.hates = tmpmem;
memory.c:    tmpmem->next = ch->specials.fears;
memory.c:    ch->specials.fears = tmpmem;
memory.c:    tmpmem->next = ch->specials.likes;
memory.c:    ch->specials.likes = tmpmem;
memory.c:    if (ch->specials.hates->remembers == mem) {
memory.c:        tmpmem = ch->specials.hates;
memory.c:        ch->specials.hates = ch->specials.hates->next;
memory.c:        for (tmpmem = ch->specials.hates; tmpmem->next->remembers != mem; tmpmem = tmpmem->next);
memory.c:    if (ch->specials.fears->remembers == mem) {
memory.c:        tmpmem = ch->specials.fears;
memory.c:        ch->specials.fears = ch->specials.fears->next;
memory.c:        for (tmpmem = ch->specials.fears; tmpmem->next->remembers != mem; tmpmem = tmpmem->next);
memory.c:    if (ch->specials.fears->remembers == mem) {
memory.c:        tmpmem = ch->specials.likes;
memory.c:        ch->specials.likes = ch->specials.fears->next;
memory.c:        for (tmpmem = ch->specials.likes; tmpmem->next->remembers != mem; tmpmem = tmpmem->next);
memory.c:   while ( ch->fears )
memory.c:   remove_from_fears ( ch, ch->fears->remembers );
memory.c:   while ( ch->hates )
memory.c:   remove_from_hates ( ch, ch->hates->remembers );
memory.c:    while (ch->specials.fears) {
memory.c:        remove = ch->specials.fears;
memory.c:        ch->specials.fears = ch->specials.fears->next;
memory.c:    while (ch->specials.hates) {
memory.c:        remove = ch->specials.hates;
memory.c:        ch->specials.hates = ch->specials.hates->next;
memory.c:    while (ch->specials.likes) {
memory.c:        remove = ch->specials.likes;
memory.c:        ch->specials.likes = ch->specials.likes->next;
modify.c:            ch->desc->player_info->edit_end);
modify.c:    ch->desc->str = pString;
modify.c:    ch->desc->max_str = maxlen;
modify.c:    ch->desc->editing_display = strdup(text);
modify.c:    if (!ch->desc->editing_display) {
modify.c:    ch->desc->editing_display = strdup(text);
modify.c:    if (!ch->desc->editing_display) {
monitor.c:        if (ch->in_room && pPl->room == ch->in_room)
monitor.c:        if( pPl->clan == 0 && ch->clan == NULL )
monitor.c:        if (pPl->clan != 0 && is_clan_member(ch->clan, pPl->clan))
monitor.c:            if (pPl->ch && ch->in_room && pPl->ch->in_room == ch->in_room)
monitor.c:            if (pPl->clan != -1 && ch->in_room) {
monitor.c:                for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
monitor.c:                    if (is_clan_member(rch->clan, pPl->clan))
monitor.c:        if (IS_SET(pPl->show, MONITOR_TABLE) && ch->on_obj && pPl->ch) {
monitor.c:            if (ch->on_obj->table)
monitor.c:                table = ch->on_obj->table;
monitor.c:                table = ch->on_obj;
monitor.c:            if (pPl->ch->on_obj == table || (pPl->ch->on_obj
monitor.c:             && pPl->ch->on_obj->table && pPl->ch->on_obj->table == table))
monitor.c:    if (!ch->desc)
monitor.c:    if (ch->desc->monitoring) {
monitor.c:        pCl = find_in_monitoring(ch->desc->monitoring, target, show);
monitor.c:    if (ch->desc->monitoring_all && (ch->desc->monitor_all_show & show)
monitor.c:        && ((ch->desc->monitor_all_show & MONITOR_INCLUDE_NPC) || !IS_NPC(target)))
monitor.c:    if (ch->desc->monitoring_review 
monitor.c:     && (ch->desc->monitor_review_show & show)
monitor.c:     && ((ch->desc->monitor_review_show & MONITOR_INCLUDE_NPC) || !IS_NPC(target)))
monitor.c:        if (ch->desc->monitoring_all) {
monitor.c:            flag_desc = show_flags(monitor_flags, ch->desc->monitor_all_show);
monitor.c:        if (ch->desc->monitoring_review) {
monitor.c:            flag_desc = show_flags(monitor_flags, ch->desc->monitor_review_show);
monitor.c:        for (pCl = ch->desc->monitoring; pCl; pCl = pCl->next) {
monitor.c:        if (ch->desc->monitoring == NULL) {
monitor.c:        for (pCl = ch->desc->monitoring; pCl; pCl = pCl_next) {
monitor.c:        ch->desc->monitoring = NULL;
monitor.c:        ch->desc->monitoring_all = FALSE;
monitor.c:        ch->desc->monitor_all_show = 0;
monitor.c:        ch->desc->monitoring_review = FALSE;
monitor.c:        ch->desc->monitor_review_show = 0;
monitor.c:        ch->desc->monitor_all_show ^= flags;
monitor.c:        ch->desc->monitoring_all = (flags != 0);
monitor.c:        if( ch->desc->monitoring_review ) {
monitor.c:            ch->desc->monitoring_review = FALSE;
monitor.c:            ch->desc->monitor_review_show = 0;
monitor.c:        ch->desc->monitor_review_show ^= flags;
monitor.c:        ch->desc->monitoring_review = (flags != 0);
monitor.c:        room = ch->in_room;
monitor.c:        if (find_room_in_monitoring(ch->desc->monitoring, room))
monitor.c:            remove_room_monitoring(ch->desc, room, flags);
monitor.c:            add_room_monitoring(ch->desc, room, flags);
monitor.c:        if ((pCl = find_room_in_monitoring(ch->desc->monitoring, room))
monitor.c:        room = ch->in_room;
monitor.c:        for (rch = room->people; rch; rch = rch->next_in_room) {
monitor.c:            add_monitoring(ch->desc, rch, flags);
monitor.c:        if (find_guild_in_monitoring(ch->desc->monitoring, gld))
monitor.c:            remove_guild_monitoring(ch->desc, gld, flags);
monitor.c:            add_guild_monitoring(ch->desc, gld, flags);
monitor.c:        if ((pCl = find_guild_in_monitoring(ch->desc->monitoring, gld))
monitor.c:        if (find_clan_in_monitoring(ch->desc->monitoring, clan))
monitor.c:            remove_clan_monitoring(ch->desc, clan, flags);
monitor.c:            add_clan_monitoring(ch->desc, clan, flags);
monitor.c:        if ((pCl = find_clan_in_monitoring(ch->desc->monitoring, clan))
monitor.c:    if (victim->player.level >= ch->player.level && victim != ch) {
monitor.c:    if ((pCl = find_ch_in_monitoring(ch->desc->monitoring, victim)) != NULL) {
monitor.c:        remove_monitoring(ch->desc, victim, to_rem);
monitor.c:        if (!flags && !find_ch_in_monitoring(ch->desc->monitoring, victim)) {
monitor.c:    add_monitoring(ch->desc, victim, flags);
monitor.c:    pCl = find_ch_in_monitoring(ch->desc->monitoring, victim);
mount.c:  if (mount->in_room != ch->in_room) {
mount.c:  if (ch->specials.riding == mount || 
mount.c:  if (ch->specials.riding) {
mount.c:    return ch->specials.riding;
mount.c:  for (curr_follower = ch->followers; 
mount.c:    if (curr_follower->follower->in_room == ch->in_room &&
mount.c:  for (curr_ch = ch->in_room->people; 
mount.c:       curr_ch = curr_ch->next_in_room) {
mount.c:      if (curr_ch->specials.riding == mount) {
mount.c:  if (ch->specials.riding) {
mount.c:    num_followers = count_mount_followers(ch->specials.riding);
mount.c:  for (curr_follower = ch->followers; 
mount.c:    if (ch->in_room == curr_follower->follower->in_room &&
mount.c:  } else if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
mount.c:  if (ch->specials.riding && 
mount.c:      ch->specials.riding != mount) {
mount.c:    cprintf(ch, "You are already riding %s, dismount first.\n\r", PERS(ch, ch->specials.riding));
mount.c:        ch->specials.riding != mount) {
mount.c:    obj_to_room(obj, ch->in_room);
mount.c:  if (find_ex_description("[ROOTED]", ch->ex_description, TRUE)) {
mount.c:  if (ch->specials.riding) {
mount.c:    cprintf(ch, "You're already riding %s.\n\r", PERS(ch, ch->specials.riding));
mount.c:  if (ch->lifting) {
mount.c:    cprintf(ch, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
mount.c:    if (!drop_lifting(ch, ch->lifting)) {
mount.c:      if ((ch->skills[SKILL_RIDE]->learned > 60) &&
mount.c:          (number(1, 100) < ch->skills[SKILL_RIDE]->learned)) {
mount.c:  if (ch->specials.fighting &&
mount.c:      !is_paralyzed(ch->specials.fighting)) {
mount.c:    if (ch->skills[SKILL_RIDE] && 
mount.c:        (number(1, fightcheck) > ch->skills[SKILL_RIDE]->learned)) {
mount.c:  ch->specials.riding = mount;
mount.c:  if (!ch->specials.riding) {
mount.c:    for (rider = ch->in_room->people; 
mount.c:  mount = ch->specials.riding;
mount.c:  ch->specials.riding = 0;
movement.c:  if (!ch->in_room) {
movement.c:  if (IS_SET(ch->specials.affected_by, CHAR_AFF_CLIMBING) &&
movement.c:    REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_CLIMBING);
movement.c:    if (IS_SET(ch->in_room->room_flags, RFL_FALLING)) {
movement.c:      if (IS_SET(ch->specials.affected_by, CHAR_AFF_HIDE)) {
movement.c:        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
movement.c:  if (ch->in_room->direction[cmd-1]) {
movement.c:    return ch->in_room->direction[cmd - 1]->to_room;
movement.c:      REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_INVULNERABILITY);
movement.c:  skill = ch->skills[SKILL_RIDE]->learned;
movement.c:  if (!ch->specials.riding) {
movement.c:  if (SPEED_RUNNING == GET_SPEED(ch->specials.riding)) {
movement.c:  switch (ch->in_room->sector_type) {
movement.c:    if (GET_RACE(ch->specials.riding) == RACE_RATLON ||
movement.c:        GET_RACE(ch->specials.riding) == RACE_GWOSHI) {
movement.c:    if( GET_RACE(ch->specials.riding) == RACE_RATLON ||
movement.c:        GET_RACE(ch->specials.riding) == RACE_GWOSHI) {
movement.c:      !ch->in_room ||
movement.c:      (BURROW_ZONE != ch->in_room->zone)) {
movement.c:      ch->in_room->direction[DIR_UP] &&
movement.c:      ch->in_room->direction[DIR_UP]->to_room) {
movement.c:    surface_room = ch->in_room->direction[DIR_UP]->to_room;
movement.c:    burrow_room = ch->in_room;
movement.c:    sprintf(buf, "%s emerges into %s [%d].\n\r", MSTR(ch, name), ch->in_room->name, ch->in_room->number);
movement.c:    REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_BURROW);
movement.c:  if (!ch->on_obj) {
movement.c:  furniture_obj = ch->on_obj;
movement.c:  remove_occupant(ch->on_obj, ch);
movement.c:        if ((table = get_obj_in_list_vis(ch, arg2, ch->in_room->contents)) == NULL) {
movement.c:            for (table = ch->in_room->contents; table; table = table->next_content) {
movement.c:        if ((chair = get_obj_in_list_vis(ch, arg2, ch->in_room->contents)) == NULL) {
movement.c:          if (!rch->on_obj) {
movement.c:          if ((table = rch->on_obj->table) == NULL) {
movement.c:            chair = rch->on_obj;
movement.c:        if (NULL == (table = get_obj_in_list_vis(ch, arg2, ch->in_room->contents))) {
movement.c:    else if (NULL == (chair = get_obj_in_list_vis(ch, arg1, ch->in_room->contents))) {
movement.c:        ch->on_obj && IS_SET(ch->on_obj->obj_flags.value[1], reqFlag)) {
movement.c:      chair = ch->on_obj;
movement.c:    else if (ch->on_obj &&
movement.c:             IS_SET(ch->on_obj->obj_flags.value[1], FURN_SKIMMER) &&
movement.c:             ch->in_room->sector_type == SECT_SILT) {
movement.c:      act("Getting off $p would be suicide!", FALSE, ch, ch->on_obj, NULL, TO_CHAR);
movement.c:      if (ch->on_obj && newPos != POSITION_STANDING) {
movement.c:    if (ch->on_obj && newPos != POSITION_STANDING) {
movement.c:  if (ch->on_obj != chair) {
movement.c:  if (newPos == GET_POS(ch) && ch->on_obj == chair) {
movement.c:      (ch->on_obj && chair != ch->on_obj) ||
movement.c:      (!ch->on_obj && GET_POS(ch) < POSITION_STANDING)) {
movement.c:    if (ch->specials.riding) {
movement.c:      act("You swing your legs over and jump off of $N.", FALSE, ch, table, ch->specials.riding, TO_CHAR);
movement.c:      act("$n swings $s legs over and jumps off of $N.", FALSE, ch, table, ch->specials.riding, TO_ROOM);
movement.c:      act("$n swings $s legs over and jumps off of you.", FALSE, ch, table, ch->specials.riding, TO_VICT);
movement.c:      ch->specials.riding = 0;
movement.c:  } else if (ch->in_room->sector_type == (SECT_WATER_PLANE)) {
movement.c:  if (ch->on_obj) {
movement.c:    act("You push off of $p and stand up.", FALSE, ch, ch->on_obj, 0, TO_CHAR);
movement.c:    act("$n pushes off of $p and rises to $s feet.", TRUE, ch, ch->on_obj, 0, TO_ROOM);
movement.c:    remove_occupant(ch->on_obj, ch);
movement.c:      if (IS_SET(ch->in_room->room_flags, RFL_NO_CLIMB)) {
movement.c:           number(50, 150) < ch->skills[SKILL_CLIMB]->learned) ||
movement.c:        MUD_SET_BIT(ch->specials.affected_by, CHAR_AFF_CLIMBING);
movement.c:  mover = ch->specials.riding ? ch->specials.riding : ch;
movement.c:      (mover == ch->specials.riding) && 
movement.c:  if (is_cargo_bay(to_room) && ch->lifting) {
movement.c:    int obj_weight = calc_object_weight_for_cargo_bay(ch->lifting);
movement.c:               smash_article(format_obj_to_char( ch->lifting, ch, 1)));
movement.c:  if (ch->specials.riding == mover) {
movement.c:      ch->specials.riding = NULL;
movement.c:  if (ch->lifting) {
movement.c:    if (GET_OBJ_WEIGHT(ch->lifting) / 2 > get_lifting_capacity(ch->lifting->lifted_by)) {
movement.c:      act("You try and drag $p, but it's too heavy.", 0, ch, ch->lifting, 0, TO_CHAR);
movement.c:      act("$n strains, trying to drag $p, but it doesn't move.", 0, ch, ch->lifting, 0, TO_ROOM);
movement.c:    } else if (GET_OBJ_WEIGHT(ch->lifting) > get_lifting_capacity(ch->lifting->lifted_by)) {
movement.c:      need_movement += MAX(0, (GET_OBJ_WEIGHT(ch->lifting)
movement.c:                               - get_lifting_capacity(ch->lifting->lifted_by))
movement.c:                           / MIN(1, count_plyr_list(ch->lifting->lifted_by, NULL)));
movement.c:  if (IS_SET(ch->specials.act, CFL_MOUNT) && (mover == ch) && ch->master) {
movement.c:    if (IS_NPC(mover) && (mover == ch->specials.riding)) {
movement.c:  if (following && ch->desc && ch->desc->str) {
movement.c:  if (!ch->specials.riding) {
movement.c:  if (ch->desc && (ch->specials.act_wait > 50) && ch->master && following) {
movement.c:    act("$N is too fast for you, so you lag behind.", FALSE, ch, 0, ch->master, TO_CHAR);
movement.c:    act("$N is unable to keep up with you, and lags behind.", FALSE, ch->master, 0, ch, TO_CHAR);
movement.c:      (!IS_SET(ch->in_room->room_flags, RFL_FALLING))) {
movement.c:    for (curr_follower = ch->followers; curr_follower; curr_follower = next_follower) {
movement.c:        if (ch->in_room->sector_type == SECT_FIELD||
movement.c:            ch->in_room->sector_type == SECT_DESERT ||
movement.c:            ch->in_room->sector_type == SECT_HILLS ||
movement.c:            ch->in_room->sector_type == SECT_MOUNTAIN ||
movement.c:            ch->in_room->sector_type == SECT_GRASSLANDS) {
movement.c:                  room_sector[ch->in_room->sector_type].name,
movement.c:  if (ch->specials.subduing && (cmd == DIR_UP) &&
movement.c:      ((mover == ch->specials.riding) || (IS_SET(ch->specials.act, CFL_MOUNT)))) {
movement.c:  if (ch->specials.subduing) {
movement.c:    thorn_check(ch->specials.subduing, cmd);
movement.c:  if (ch->specials.subduing) {
movement.c:    wall_of_fire_check(ch->specials.subduing, cmd);
movement.c:  if (ch->specials.subduing) {
movement.c:    blade_barrier_check(ch->specials.subduing, cmd);
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, "Climb Learned = %d", percent);
movement.c:      percent = ((ch->specials.riding == mover) ? 0 : 10);
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, "Climb Base Chance = %d", percent);
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, "w/equipment = %d", percent);
movement.c:    qroomlogf(QUIET_CALC, ch->in_room, "+ agility reaction = %d", percent);
movement.c:    qroomlogf(QUIET_CALC, ch->in_room, "+ strength todam = %d", percent);
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, "+ climb_tool = %d", percent);
movement.c:        qroomlogf(QUIET_CALC, ch->in_room, "+ hands_free(1) = %d",  percent);
movement.c:        qroomlogf(QUIET_CALC, ch->in_room, "+ hands_free(2) = %d", percent);
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, "+ levitate = %d", percent);
movement.c:    if (IS_SET(ch->specials.nosave, NOSAVE_CLIMB)) {
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, "NOSAVE climb = %d", percent);
movement.c:        mover == ch->specials.riding &&
movement.c:    if (mover == ch->specials.riding && 
movement.c:        IS_SET(ch->in_room->direction[cmd]->to_room->room_flags, RFL_NO_CLIMB)) {
movement.c:    qroomlogf(QUIET_CALC, ch->in_room, "Rolled a %d", roll);
movement.c:        for (tch = ch->in_room->people; tch; tch = next_tch) {
movement.c:          next_tch = tch->next_in_room;
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, "Skill (%d) >= Roll (%d)  CLIMB SUCCESS!!!", percent, roll);
movement.c:          if (ch->equipment[ETWO]) {
movement.c:                    OSTR(ch->equipment[ETWO], short_descr),
movement.c:                    OSTR(ch->equipment[EP], short_descr),
movement.c:                    OSTR(ch->equipment[ES], short_descr),
movement.c:      if (!IS_SET(ch->specials.affected_by, CHAR_AFF_CLIMBING)) {
movement.c:        MUD_SET_BIT(ch->specials.affected_by, CHAR_AFF_CLIMBING);
movement.c:        qroomlogf(QUIET_CALC, ch->in_room, "NO_CLIMB!!!");
movement.c:        if (IS_SET(ch->in_room->room_flags, RFL_NO_CLIMB)) {
movement.c:        qroomlogf(QUIET_CALC, ch->in_room, "Skill (%d) < Roll (%d)  CLIMB FAIL!!!", percent, roll);
movement.c:        if (IS_SET(ch->specials.nosave, NOSAVE_CLIMB)) {
movement.c:            IS_SET(ch->specials.affected_by, CHAR_AFF_CLIMBING)) {
movement.c:          REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_CLIMBING);
movement.c:            (!IS_SET(ch->specials.nosave, NOSAVE_CLIMB))) {
movement.c:    if (IS_SET(ch->specials.affected_by, CHAR_AFF_CLIMBING)) {
movement.c:      REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_CLIMBING);
movement.c:      for (tch = ch->in_room->people; tch; tch = next_tch) {
movement.c:        next_tch = tch->next_in_room;
movement.c:  if (!ch->in_room) {
movement.c:    gamelog("simple_move: Unable to find ch->in_room");
movement.c:  was_in = ch->in_room;
movement.c:    for (tch = ch->in_room->people; tch; tch = next_tch) {
movement.c:      next_tch = tch->next_in_room;       // In case the tch goes away
movement.c:      if (tch && affected_by_spell(tch, PSI_SHADOW_WALK) && tch->desc && tch->desc->original) {
movement.c:    char_to_room(rider, ch->in_room);
movement.c:  if (get_room_extra_desc_value(ch->in_room, "[ALARM_SPL_PC_info]", edesc, sizeof(edesc))) {
movement.c:  if (get_room_extra_desc_value(ch->in_room, "[ALARM_SPL_ACCOUNT_info]", edesc, sizeof(edesc))) {
movement.c:    sprintf(buf3, "%d", npc_index[ch->nr].vnum);
movement.c:    if (!strcmp(name_string, ch->name) &&
movement.c:        !strcmp(account_string, ch->account)) {
movement.c:  if ((IS_SET(ch->in_room->room_flags, RFL_SPL_ALARM) &&
movement.c:          sprintf(buf4, "You sense that %s has triggered your alarm in %s.\n\r", PERS(caster, ch), ch->in_room->name);
movement.c:    sector = ch->in_room->sector_type;
movement.c:      send_to_room("A deep rumbling comes from the stony walls.\n\r", ch->in_room);
movement.c:                   ch->in_room);
movement.c:      send_to_room("Rocks stir underfoot with a groan of noise.\n\r", ch->in_room);
movement.c:                   "momentarily filling the air.\n\r", ch->in_room);
movement.c:                   "ground beneath them stirs.\n\r", ch->in_room);
movement.c:      send_to_room("A brief ringing sound fills the air.\n\r", ch->in_room);
movement.c:    if (TRUE == get_room_extra_desc_value(ch->in_room, "[ALARM_SPL_USES]", buf1, MAX_STRING_LENGTH)) {
movement.c:      set_room_extra_desc_value(ch->in_room, "[ALARM_SPL_USES]", buf2);
movement.c:      remove_alarm_spell(ch->in_room);
movement.c:  if (mover == ch->specials.riding) {
movement.c:  if (ch->specials.subduing) {
movement.c:    char_from_room_move(ch->specials.subduing);
movement.c:    char_to_room(ch->specials.subduing, was_in->direction[cmd]->to_room);
movement.c:    cmd_look(ch->specials.subduing, "", -1, 0);
movement.c:    for (tch = ch->in_room->people; tch; tch = next_tch) {
movement.c:      next_tch = tch->next_in_room;
movement.c:          } else if (ch->lifting) {
movement.c:                    GET_OBJ_WEIGHT(ch->lifting) >
movement.c:                    get_lifting_capacity(ch->lifting->lifted_by)
movement.c:          if (ch->specials.subduing) {
movement.c:          if (ch->specials.riding) {
movement.c:    if ((cmd < DIR_UP) && (ch->in_room->sector_type == (SECT_WATER_PLANE))) {
movement.c:    } else if ((cmd == DIR_UP) && (ch->in_room->sector_type == (SECT_WATER_PLANE))) {
movement.c:    } else if (ch->in_room->sector_type == (SECT_WATER_PLANE)) {
movement.c:    act(buf, TRUE, rider, 0, ch->specials.subduing, TO_NOTVICT);
movement.c:  if (IS_SET(ch->in_room->room_flags, RFL_DEATH) && !IS_IMMORTAL(ch)) {
movement.c:  if (ch->desc && !IS_IMMORTAL(ch)) {
movement.c:    ch->specials.act_wait += lag_time(mover) + extra_lag;
movement.c:  if (!ch->in_room) {
movement.c:    if (wn->zone == ch->in_room->zone) {
movement.c:  if( ch->in_room->direction[cmd - 1] ) {
movement.c:    to_room = ch->in_room->direction[cmd - 1]->to_room;
movement.c:  if (IS_SET(ch->in_room->room_flags, RFL_SANDSTORM)) {
movement.c:  if (IS_SET(ch->in_room->room_flags, RFL_INDOORS)) {
movement.c:  if ((wn && !IS_SET(ch->in_room->room_flags, RFL_INDOORS)) &&
movement.c:      (ch->in_room->direction[cmd - 1])) {
movement.c:  if ((IS_SET(ch->in_room->room_flags, RFL_SANDSTORM)) ||
movement.c:      ((wn && !IS_SET(ch->in_room->room_flags, RFL_INDOORS) && condition >= 5.00))) {
movement.c:    if (ch->in_room->sector_type == SECT_CITY) {
movement.c:  if (!IS_DARK(ch->in_room) && 
movement.c:      (!IS_SET(ch->specials.act, CFL_MOUNT) || 
movement.c:       (IS_SET(ch->specials.act, CFL_MOUNT) && !ch->master)) &&
movement.c:    OBJ_DATA *sunslits = ch->equipment[WEAR_FACE];
movement.c:    qroomlogf(QUIET_CALC, ch->in_room, "%s has %d base direction sense for wis", MSTR(ch, name), skill);
movement.c:      skill += ch->skills[SKILL_DIRECTION_SENSE]->learned;
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, " +%d Direction sense = %d",
movement.c:                ch->skills[SKILL_DIRECTION_SENSE]->learned, skill);
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, " +50 sunslits = %d", skill);
movement.c:    if (ch->master && has_skill(ch->master, SKILL_DIRECTION_SENSE) &&
movement.c:        ch->master->in_room == to_room) {
movement.c:      skill += ch->master->skills[SKILL_DIRECTION_SENSE]->learned;
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, " +%d leader = %d", 
movement.c:                ch->master->skills[SKILL_DIRECTION_SENSE]->learned, skill);
movement.c:      qroomlogf(QUIET_CALC, ch->in_room, 
movement.c:  if (IS_DARK(ch->in_room) &&
movement.c:      (!IS_SET(ch->specials.act, CFL_MOUNT) ||
movement.c:       (IS_SET(ch->specials.act, CFL_MOUNT) && !ch->master)) &&
movement.c:      skill += ch->skills[SKILL_DIRECTION_SENSE]->learned;
movement.c:    if (ch->master && has_skill(ch->master, SKILL_DIRECTION_SENSE) &&
movement.c:        ch->master->in_room == to_room) {
movement.c:      skill += ch->master->skills[SKILL_DIRECTION_SENSE]->learned;
movement.c:  if (!ch->in_room->direction[cmd]) {
movement.c:    if (!(dome_room = ch->in_room->direction[cmd]->to_room)) {
movement.c:    } else if (!ch->followers && 
movement.c:               !ch->master && 
movement.c:               !ch->lifting &&
movement.c:               !(ch->specials.riding && ch->specials.riding->followers)) {
movement.c:          (ch->in_room == ch->master->in_room)) {
movement.c:        was_in = ch->in_room;
movement.c:          if (ch->followers) {
movement.c:            for (k = ch->followers; k; k = next_dude) {
movement.c:                new_room = ch->in_room;
movement.c:                      (k->follower->in_room != ch->in_room)) {
movement.c:          }           /* end if ch->followers */
movement.c:          if (ch->specials.riding && ch->specials.riding->followers) {
movement.c:            for (k = ch->specials.riding->followers; k; k = next_dude) {
movement.c:                new_room = ch->specials.riding->in_room;
movement.c:                remove_char_from_room(ch->specials.riding);
movement.c:                add_char_to_room(ch->specials.riding, k->follower->in_room);
movement.c:                act(buf, FALSE, k->follower, 0, ch->specials.riding, TO_CHAR);
movement.c:                remove_char_from_room(ch->specials.riding);
movement.c:                add_char_to_room(ch->specials.riding, new_room);
movement.c:          if (ch->lifting) {
movement.c:            for (pPl = ch->lifting->lifted_by; pPl; pPl = pPlNext) {
movement.c:              if (pPl->ch && was_in == pPl->ch->in_room
movement.c:                obj_weight = GET_OBJ_WEIGHT(ch->lifting);
movement.c:                capacity = get_lifting_capacity(ch->lifting->lifted_by);
movement.c:                act(buf, FALSE, pPl->ch, ch->lifting, ch, TO_CHAR);
movement.c:                  GET_NAME(ch), !IS_NPC(ch) ? "(" : "", !IS_NPC(ch) ? ch->account : "",
movement.c:                  !IS_NPC(ch) ? ") " : "", ch->in_room->number);
movement.c:            struct time_info_data playing_time = real_time_passed((time(0) - ch->player.time.logon) +
movement.c:                                                                  ch->player.time.played, 0);
movement.c:                 (ch->player.dead && !strcmp(ch->player.dead, "rebirth"))) &&
movement.c:                !IS_SET(ch->specials.act, CFL_NO_DEATH)) {
movement.c:              if (ch->player.info[1]) {
movement.c:                free(ch->player.info[1]);
movement.c:              ch->player.info[1] = strdup(buf);
movement.c:  if (!ch->specials.to_process && cmd == CMD_UNLATCH) {
movement.c:        (ch->skills[SKILL_SLEIGHT_OF_HAND] &&
movement.c:         skill_success(ch, NULL, ch->skills[SKILL_SLEIGHT_OF_HAND]->learned))) {
movement.c:        for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
movement.c:    if ((ch->skills[SKILL_SLEIGHT_OF_HAND] &&
movement.c:         skill_success(ch, NULL, ch->skills[SKILL_SLEIGHT_OF_HAND]->learned))) {
movement.c:        skill = ch->skills[SKILL_SLEIGHT_OF_HAND] ?
movement.c:          ch->skills[SKILL_SLEIGHT_OF_HAND]->learned: 0;
movement.c:          REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
movement.c:            if ((ct = room_in_city(ch->in_room)) == CITY_NONE)
movement.c:            (ch->skills[SKILL_SLEIGHT_OF_HAND] && 
movement.c:             skill_success(ch, NULL, ch->skills[SKILL_SLEIGHT_OF_HAND]->learned))) {
movement.c:            for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
movement.c:            if (back->to_room == ch->in_room) {
movement.c:              old_room = ch->in_room;
movement.c:              if (back->to_room == ch->in_room) {
movement.c:  if (!ch->specials.to_process && cmd == CMD_LATCH) {
movement.c:        (has_skill(ch, SKILL_SLEIGHT_OF_HAND) && skill_success(ch, NULL, ch->skills[SKILL_SLEIGHT_OF_HAND]->learned))) {
movement.c:         skill_success(ch, NULL, ch->skills[SKILL_SLEIGHT_OF_HAND]->learned))) {
movement.c:        skill = ch->skills[SKILL_SLEIGHT_OF_HAND] ?
movement.c:          ch->skills[SKILL_SLEIGHT_OF_HAND]->learned: 0;
movement.c:          REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
movement.c:            if ((ct = room_in_city(ch->in_room)) == CITY_NONE)
movement.c:           skill_success(ch, NULL, ch->skills[SKILL_SLEIGHT_OF_HAND]->learned))) {
movement.c:          for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
movement.c:          if (back->to_room == ch->in_room) {
movement.c:            old_room = ch->in_room;
movement.c:  for (o = ch->carrying; o; o = o->next_content) {
movement.c:  if (!ch->equipment[ES]) {
movement.c:  OBJ_DATA *obj = ch->equipment[ES];
movement.c:    if (!ch->specials.to_process) {
movement.c:  if (ch->lifting) {
movement.c:    sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
movement.c:    if (!drop_lifting(ch, ch->lifting)) {
movement.c:            if (back->to_room == ch->in_room) {
movement.c:            if (back->to_room == ch->in_room) {
movement.c:  if (ch->lifting) {
movement.c:    sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
movement.c:    if (!drop_lifting(ch, ch->lifting)) {
movement.c:            if (back->to_room == ch->in_room) {
movement.c:            if (back->to_room == ch->in_room) {
movement.c:  if (!ch->in_room) {
movement.c:    wag = get_obj_in_list_vis(ch, buf, ch->in_room->contents);
movement.c:        (ch->in_room == ch->master->in_room)) {
movement.c:    mt = ch->specials.riding;
movement.c:    sub = ch->specials.subduing;
movement.c:        IS_SET(ch->specials.act, CFL_MOUNT)) {
movement.c:      if (ch->master) {
movement.c:        act("$N can't fit in $p and stops following you.", FALSE, ch->master, wag, ch, TO_CHAR);
movement.c:    if (ch->lifting && ch->lifting->in_room == ch->in_room) {
movement.c:      if (GET_OBJ_WEIGHT(ch->lifting) / 2 > get_lifting_capacity(ch->lifting->lifted_by)) {
movement.c:        act("You try and drag $p, but it's too heavy.", 0, ch, ch->lifting, 0, TO_CHAR);
movement.c:        act("$n strains, trying to drag $p, but it doesn't move.", 0, ch, ch->lifting, 0, TO_ROOM);
movement.c:    if (ch->lifting && IS_AFFECTED(ch, CHAR_AFF_HIDE)) {
movement.c:      roomlogf(ch->in_room, "%s is lifting, removing hide affect.", MSTR(ch, name));
movement.c:      REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
movement.c:    for (tch = ch->in_room->people; tch; tch = t_next_in_room) {
movement.c:      t_next_in_room = tch->next_in_room;
movement.c:      } else if (ch->lifting && ch != tch) {
movement.c:                GET_OBJ_WEIGHT(ch->lifting) > get_lifting_capacity(ch->lifting->lifted_by)
movement.c:                ? "drags" : "carries", format_obj_to_char(ch->lifting, tch, 1));
movement.c:      if ((IS_SET(ch->in_room->room_flags, RFL_SPL_ALARM) && (!IS_IMMORTAL(ch)))) {
movement.c:        sector = ch->in_room->sector_type;
movement.c:          send_to_room("A deep rumbling comes from the stony walls.\n\r", ch->in_room);
movement.c:          send_to_room("The sands underfoot shift with an odd chiming sound.\n\r", ch->in_room);
movement.c:          send_to_room("Rocks stir underfoot with a groan of noise..\n\r", ch->in_room);
movement.c:          send_to_room("The silt underfoot roils, an odd chiming sound momentarily filling the air.\n\r", ch->in_room);
movement.c:          send_to_room("The thorny bushes all around rustle as the ground beneath them stirs.\n\r", ch->in_room);
movement.c:          send_to_room("A brief ringing sound fills the air.\n\r", ch->in_room);
movement.c:        remove_alarm_spell(ch->in_room);
movement.c:    if (ch->lifting && ch->lifting->in_room == ch->in_room) {
movement.c:              GET_OBJ_WEIGHT(ch->lifting) > get_lifting_capacity(ch->lifting->lifted_by)
movement.c:              ? "drag" : "carry", format_obj_to_char(ch->lifting, ch, 1));
movement.c:    was_in = ch->in_room;
movement.c:      ch->specials.riding = mt;
movement.c:    for (tch = ch->in_room->people; tch; tch = t_next_in_room) {
movement.c:      t_next_in_room = tch->next_in_room;
movement.c:      } else if (ch->lifting && ch != tch) {
movement.c:                GET_OBJ_WEIGHT(ch->lifting) > get_lifting_capacity(ch->lifting->lifted_by)
movement.c:                ? "drags" : "carries", format_obj_to_char(ch->lifting, tch, 1));
movement.c:    if (ch->lifting && ch->lifting->in_room != ch->in_room) {
movement.c:      obj_from_room(ch->lifting);
movement.c:      obj_to_room(ch->lifting, get_room_num(wag->obj_flags.value[0]));
movement.c:      for (pPl = ch->lifting->lifted_by; pPl; pPl = pPlNext) {
movement.c:        if (was_in == pPl->ch->in_room &&
movement.c:          obj_weight = GET_OBJ_WEIGHT(ch->lifting);
movement.c:          capacity = get_lifting_capacity(ch->lifting->lifted_by);
movement.c:          act(buf, FALSE, pPl->ch, ch->lifting, ch, TO_CHAR);
movement.c:    for (k = ch->followers; k; k = next_dude) {
movement.c:        ch->in_room == ch->master->in_room) {
movement.c:    wagon = find_exitable_wagon_for_room(ch->in_room);
movement.c:      if (ch->lifting && ch->lifting->in_room == ch->in_room) {
movement.c:          REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
movement.c:        if (GET_OBJ_WEIGHT(ch->lifting) / 2 > get_lifting_capacity(ch->lifting->lifted_by)) {
movement.c:          act("You try and drag $p, but it's too heavy.", 0, ch, ch->lifting, 0, TO_CHAR);
movement.c:          act("$n strains, trying to drag $p, but it doesn't move.", 0, ch, ch->lifting, 0, TO_ROOM);
movement.c:      mount = ch->specials.riding;
movement.c:      sub = ch->specials.subduing;
movement.c:      for (target_ch = ch->in_room->people; target_ch; target_ch = target_ch->next_in_room) {
movement.c:        if (ch->lifting && ch != target_ch) {
movement.c:                  GET_OBJ_WEIGHT(ch->lifting) > get_lifting_capacity(ch->lifting->lifted_by)
movement.c:                  ? "drags" : "carries", format_obj_to_char(ch->lifting, target_ch, 1));
movement.c:        if ((IS_SET(ch->in_room->room_flags, RFL_SPL_ALARM) && (!IS_IMMORTAL(ch)))) {
movement.c:          sector = ch->in_room->sector_type;
movement.c:            send_to_room("A deep rumbling comes from the stony walls.\n\r", ch->in_room);
movement.c:            send_to_room("The sands underfoot shift with an odd chiming sound.\n\r", ch->in_room);
movement.c:            send_to_room("Rocks stir underfoot with a groan of noise..\n\r", ch->in_room);
movement.c:            send_to_room("The silt underfoot roils, an odd chiming sound momentarily filling the air.\n\r", ch->in_room);
movement.c:            send_to_room("The thorny bushes all around rustle as the ground beneath them stirs.\n\r", ch->in_room);
movement.c:            send_to_room("A brief ringing sound fills the air.\n\r", ch->in_room);
movement.c:          remove_alarm_spell(ch->in_room);
movement.c:      if (ch->lifting && ch->lifting->in_room == ch->in_room) {
movement.c:                GET_OBJ_WEIGHT(ch->lifting) > get_lifting_capacity(ch->lifting->lifted_by)
movement.c:                ? "drag" : "carry", format_obj_to_char(ch->lifting, ch, 1));
movement.c:      was_in = ch->in_room;
movement.c:      for (target_ch = ch->in_room->people; target_ch; target_ch = target_ch->next_in_room) {
movement.c:        if (ch->lifting && ch != target_ch) {
movement.c:                  GET_OBJ_WEIGHT(ch->lifting) > get_lifting_capacity(ch->lifting->lifted_by)
movement.c:                  ? "drags" : "carries", format_obj_to_char(ch->lifting, target_ch, 1));
movement.c:      if (ch->lifting && ch->lifting->in_room != ch->in_room) {
movement.c:        obj_from_room(ch->lifting);
movement.c:        obj_to_room(ch->lifting, wagon->in_room);
movement.c:        for (pPl = ch->lifting->lifted_by; pPl; pPl = pPlNext) {
movement.c:          if (was_in == pPl->ch->in_room &&
movement.c:            obj_weight = GET_OBJ_WEIGHT(ch->lifting);
movement.c:            capacity = get_lifting_capacity(ch->lifting->lifted_by);
movement.c:            act(buf, FALSE, pPl->ch, ch->lifting, ch, TO_CHAR);
movement.c:      if (ch->followers) {    /* if character is being followed */
movement.c:        for (k = ch->followers; k; k = next_dude) { /* as long as there are followers */
movement.c:    if (ch->on_obj) {
movement.c:    if (ch->on_obj) {
movement.c:    if (ch->specials.fighting) {
movement.c:    if (ch->on_obj) {
movement.c:      sprintf(buf, "Error: cmd_stand: %s (%s) was in bad position '%d'", ch->name, ch->desc->player_info->name, GET_POS(ch));
movement.c:              MSTR(ch, short_descr), npc_index[ch->nr].vnum, GET_POS(ch));
movement.c:  if (ch->specials.subduing) {
movement.c:    act("Not while holding onto $N!", FALSE, ch, 0, ch->specials.subduing, TO_CHAR);
movement.c:  if (ch->lifting) {
movement.c:    sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
movement.c:    if (!drop_lifting(ch, ch->lifting)) {
movement.c:  if (ch->in_room->sector_type == SECT_AIR) {
movement.c:    if (ch->specials.riding) {
movement.c:      act("You swing your legs over, and jump off of $N.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:      act("$n swings $s legs over and jumps off of $N.", FALSE, ch, 0, ch->specials.riding, TO_ROOM);
movement.c:      act("$n swings $s legs over and jumps off of you.", FALSE, ch, 0, ch->specials.riding, TO_VICT);
movement.c:      ch->specials.riding = 0;
movement.c:      sprintf(buf, "Error: cmd_sit: %s (%s) was in bad position '%d'", ch->name, ch->desc->player_info->name, GET_POS(ch));
movement.c:              MSTR(ch, short_descr), npc_index[ch->nr].vnum, GET_POS(ch));
movement.c:  if (ch->specials.subduing) {
movement.c:    cprintf(ch, "Not while holding onto %s!\n\r", PERS(ch, ch->specials.subduing));
movement.c:  if (ch->lifting) {
movement.c:    cprintf(ch, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
movement.c:    if (!drop_lifting(ch, ch->lifting)) {
movement.c:  if (ch->in_room->sector_type == SECT_AIR) {
movement.c:    if (ch->specials.riding == mount) {
movement.c:    if (ch->specials.riding == mount) {
movement.c:      ch->specials.riding = 0;
movement.c:    if (ch->specials.riding) {
movement.c:      find_ch_keyword(ch->specials.riding, ch, arg1, sizeof(arg1));
movement.c:      if (affected_by_spell(ch->specials.riding, SPELL_LEVITATE)) {
movement.c:        affect_from_char(ch->specials.riding, SPELL_LEVITATE);
movement.c:        act("$N floats to the ground, and curls up.", FALSE, ch, 0, ch->specials.riding, TO_ROOM);
movement.c:        act("$N floats to the ground, and curls up.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:        act("$N curls up on the ground.", FALSE, ch, 0, ch->specials.riding, TO_ROOM);
movement.c:        act("$N curls up on the ground.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:      sprintf(buf, "%s dismounts and rests %s.\n\r", MSTR(ch, name), MSTR(ch->specials.riding, short_descr));
movement.c:      set_char_position(ch->specials.riding, POSITION_RESTING);
movement.c:      ch->specials.riding = 0;
movement.c:              ch->name, ch->desc->player_info->name, GET_POS(ch));
movement.c:              MSTR(ch, short_descr), npc_index[ch->nr].vnum, GET_POS(ch));
movement.c:  if (ch->specials.subduing) {
movement.c:    act("Not while holding onto $N!", FALSE, ch, 0, ch->specials.subduing, TO_CHAR);
movement.c:  if (ch->specials.riding) {
movement.c:  if (ch->in_room->sector_type == SECT_AIR) {
movement.c:  if (ch->lifting) {
movement.c:    sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
movement.c:    if (!drop_lifting(ch, ch->lifting)) {
movement.c:    set_tracks_sleeping(ch, ch->in_room);
movement.c:      sprintf(buf, "Error: cmd_sleep: %s (%s) was in bad position '%d'", ch->name,
movement.c:              ch->desc->player_info->name, GET_POS(ch));
movement.c:              MSTR(ch, short_descr), npc_index[ch->nr].vnum, GET_POS(ch));
movement.c:    set_tracks_sleeping(ch, ch->in_room);
movement.c:        (ch->specials.riding && 
movement.c:         (GET_RACE_TYPE(ch->specials.riding) == RTYPE_AVIAN_FLYING ||
movement.c:          GET_RACE(ch->specials.riding) == RACE_WYVERN)))) {
movement.c:    if (ch->specials.riding) {
movement.c:      act("You try as hard as you can, but you can't get $N to fly.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:    if (ch->specials.riding && (GET_RACE_TYPE(ch->specials.riding) != RTYPE_AVIAN_FLYING &&
movement.c:                                GET_RACE(ch->specials.riding) != RACE_WYVERN)) {
movement.c:      act("You leap off of $N's back, and begin to fly.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:      act("$n leaps off of $N's back, and begins to fly.", FALSE, ch, 0, ch->specials.riding, TO_ROOM);
movement.c:      ch->specials.riding = 0;
movement.c:    MUD_SET_BIT(ch->specials.affected_by, CHAR_AFF_FLYING);
movement.c:  if (ch->specials.riding && 
movement.c:      (GET_RACE_TYPE(ch->specials.riding) == RTYPE_AVIAN_FLYING ||
movement.c:       GET_RACE(ch->specials.riding) == RACE_WYVERN)) {
movement.c:    if (IS_AFFECTED(ch->specials.riding, CHAR_AFF_FLYING)) {
movement.c:      act("But $N is already flying.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:      act("$n barks a command at $N, who begins flying.", FALSE, ch, 0, ch->specials.riding, TO_ROOM);
movement.c:      act("You pull on the reins, and $N, begins flying.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:      MUD_SET_BIT(ch->specials.riding->specials.affected_by, CHAR_AFF_FLYING);
movement.c:      REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_FLYING);     
movement.c:  if (ch->specials.riding && 
movement.c:      is_flying_char(ch->specials.riding) > FLY_FEATHER) {
movement.c:    act("You have $N land upon the ground.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:    act("$n lands $N upon the ground.", FALSE, ch, 0, ch->specials.riding, TO_ROOM);
movement.c:    if (affected_by_spell(ch->specials.riding, SPELL_LEVITATE)) {
movement.c:      affect_from_char(ch->specials.riding, SPELL_LEVITATE);
movement.c:    if (affected_by_spell(ch->specials.riding, SPELL_FLY)) {
movement.c:      affect_from_char(ch->specials.riding, SPELL_FLY);
movement.c:    if (IS_AFFECTED(ch->specials.riding, CHAR_AFF_FLYING)) {
movement.c:      REMOVE_BIT(ch->specials.riding->specials.affected_by, CHAR_AFF_FLYING);
movement.c:  if (IS_SET(ch->in_room->room_flags, RFL_FALLING)) {
movement.c:              send_to_room_parsed(ch, ch->in_room, message, FALSE);
movement.c:          send_to_room_parsed(ch, ch->in_room, message, FALSE);
movement.c:          if (ch->on_obj && IS_SET(ch->on_obj->obj_flags.value[1], FURN_SIT)) {
movement.c:            on_obj = ch->on_obj;
movement.c:    if (ch->master) {
movement.c:      act("You are following $N.", FALSE, ch, 0, ch->master, TO_CHAR);
movement.c:      if (ch->obj_master) {
movement.c:        act("You are following $p.", FALSE, ch, ch->obj_master, 0, TO_CHAR);
movement.c:    leader_obj = get_obj_in_list_vis(ch, name, ch->in_room->contents);
movement.c:    act("And leave $N's side? Never!", FALSE, ch, 0, ch->master, TO_CHAR);
movement.c:        if (ch->master) {
movement.c:          sprintf(buf2, "You are following %s.\n\r", PERS(ch, ch->master));
movement.c:        if (ch->obj_master) {
movement.c:          sprintf(buf2, "You are following %s.\n\r", OSTR(ch->obj_master, short_descr));
movement.c:      if ((!ch->master) && (!ch->obj_master)) {
movement.c:      if ((ch->master) || (ch->obj_master)) {
movement.c:      !ch->in_room ||
movement.c:      !ch->in_room->direction[DIR_DOWN] ||
movement.c:      !ch->in_room->direction[DIR_DOWN]->to_room) {
movement.c:    if (ch->in_room->sector_type != SECT_AIR_PLANE) {
movement.c:    if (ch->in_room->sector_type != SECT_AIR_PLANE) {
movement.c:  was_in = ch->in_room;
movement.c:      if (IS_SET(ch->in_room->room_flags, RFL_DEATH)) {
movement.c:                !IS_NPC(ch) ? ch->account : "", 
movement.c:                ch->in_room->number);
movement.c:            real_time_passed((time(0) - ch->player.time.logon) + ch->player.time.played, 0);
movement.c:               (ch->player.dead && !strcmp(ch->player.dead, "rebirth"))) &&
movement.c:              !IS_SET(ch->specials.act, CFL_NO_DEATH)) {
movement.c:            if (ch->player.info[1]) {
movement.c:              free(ch->player.info[1]);
movement.c:            ch->player.info[1] = strdup(buf);
movement.c:                 !will_char_fall_in_room(ch, ch->in_room)) {
movement.c:                    !IS_NPC(ch) ? "(" : "", !IS_NPC(ch) ? ch->account : "",
movement.c:                    !IS_NPC(ch) ? ") " : "", ch->in_room->number);
movement.c:                real_time_passed((time(0) - ch->player.time.logon) +
movement.c:                                 ch->player.time.played,
movement.c:                   (ch->player.dead && !strcmp(ch->player.dead, "rebirth"))) &&
movement.c:                  !IS_SET(ch->specials.act, CFL_NO_DEATH)) {
movement.c:                if (ch->player.info[1]) {
movement.c:                  free(ch->player.info[1]);
movement.c:                ch->player.info[1] = strdup(buf);
movement.c:  if (ch->lifting) {
movement.c:  if (ch->in_room->sector_type == SECT_DESERT) {
movement.c:  if (find_ex_description("[ROOTED]", ch->ex_description, TRUE)) {
movement.c:  if (!ch->in_room) {
movement.c:  loss += movement_loss[(int) ch->in_room->sector_type];
movement.c:  if ((ch->in_room->sector_type == SECT_FIRE_PLANE && (GET_GUILD(ch) != GUILD_FIRE_ELEMENTALIST)) ||
movement.c:      (ch->in_room->sector_type == SECT_WATER_PLANE && (GET_GUILD(ch) != GUILD_WATER_ELEMENTALIST)) ||
movement.c:      (ch->in_room->sector_type == SECT_EARTH_PLANE && (GET_GUILD(ch) != GUILD_STONE_ELEMENTALIST)) ||
movement.c:      (ch->in_room->sector_type == SECT_AIR_PLANE && (GET_GUILD(ch) != GUILD_WIND_ELEMENTALIST)) ||
movement.c:      (ch->in_room->sector_type == SECT_SHADOW_PLANE && (GET_GUILD(ch) != GUILD_SHADOW_ELEMENTALIST)) ||
movement.c:      (ch->in_room->sector_type == SECT_NILAZ_PLANE && (GET_GUILD(ch) != GUILD_VOID_ELEMENTALIST)) ||
movement.c:      (ch->in_room->sector_type == SECT_LIGHTNING_PLANE && (GET_GUILD(ch) != GUILD_LIGHTNING_ELEMENTALIST))) {
movement.c:  if (ch->specials.subduing) {
movement.c:      ((ch->in_room->sector_type == SECT_LIGHT_FOREST) || (ch->in_room->sector_type == SECT_HEAVY_FOREST))) {
movement.c:  if ((ch->in_room->sector_type == SECT_DESERT) || (ch->in_room->sector_type == SECT_SALT_FLATS)) {
movement.c:  } else if ((ch->in_room->sector_type == SECT_LIGHT_FOREST) ||
movement.c:             (ch->in_room->sector_type == SECT_THORNLANDS) ||
movement.c:             (ch->in_room->sector_type == SECT_RUINS) ||
movement.c:             (ch->in_room->sector_type == SECT_SOUTHERN_CAVERN) ||
movement.c:             (ch->in_room->sector_type == SECT_CAVERN) ||
movement.c:             (ch->in_room->sector_type == SECT_SHALLOWS)) {
movement.c:  } else if (ch->in_room->sector_type == SECT_HEAVY_FOREST) {
movement.c:  } else if (ch->in_room->sector_type == SECT_ROAD) {
movement.c:  } else if (ch->in_room->sector_type == SECT_CITY) {
movement.c:  } else if (ch->in_room->sector_type == SECT_INSIDE) {
movement.c:      (ch->in_room->sector_type == SECT_DESERT)) {
movement.c:      ((ch->in_room->sector_type == SECT_LIGHT_FOREST) || (ch->in_room->sector_type == SECT_HEAVY_FOREST))) {
movement.c:      (ch->in_room->sector_type != SECT_DESERT)) {
movement.c:  if ((ch->in_room->sector_type == SECT_SILT) && IS_SET(ch->specials.act, CFL_SILT_GUY)) {
movement.c:  if ((ch->in_room->sector_type != SECT_CITY) && 
movement.c:      (ch->in_room->sector_type != SECT_INSIDE)) {
movement.c:    if (ch->in_room->sector_type == SECT_AIR || 
movement.c:        ch->in_room->sector_type == SECT_AIR_PLANE) {
movement.c:  if (find_ex_description("[ROOTED]", ch->ex_description, TRUE)) {
movement.c:    if ((armor = ch->equipment[pos]) && (armor->obj_flags.material == MATERIAL_METAL)) {
movement.c:  if ((ch->in_room) &&
movement.c:      ((ch->in_room->sector_type == SECT_CITY) || (ch->in_room->sector_type == SECT_INSIDE))){
movement.c:  for (ch = room->people; ch; ch = ch->next_in_room) {
movement.c:    rm += (ch->player.weight * 10) + calc_carried_weight(ch);
movement.c:  if (!ch->in_room) {
movement.c:      send_to_char("(!ch->in_room error.\n\r", ch);
movement.c:  wagon = find_pilotable_wagon_for_room(ch->in_room);
movement.c:    if (ch->on_obj) {
movement.c:      if (ch->on_obj->obj_flags.type == ITEM_FURNITURE) {
movement.c:        if (IS_SET(ch->on_obj->obj_flags.value[1], FURN_SKIMMER) ||
movement.c:            IS_SET(ch->on_obj->obj_flags.value[1], FURN_WAGON)) {
movement.c:          wagon = ch->on_obj;
movement.c:        if (AWAKE(sCh->ch) && (sCh->ch->desc || IS_NPC(sCh->ch))) {
movement.c:        if (!(ch->in_room->sector_type == SECT_SILT ||
movement.c:              ch->in_room->sector_type == SECT_SHALLOWS)) {
movement.c:                     ? ch->skills[SKILL_PILOT]->learned : 0);
movement.c:              remove_occupant(sch->on_obj, sCh->ch);
movement.c:              if (will_char_fall_in_room(sch, sch->in_room)) {
movement.c:                if (IS_SET(sch->in_room->room_flags, RFL_NO_FLYING) &&
movement.c:                  REMOVE_BIT(sch->specials.affected_by, CHAR_AFF_FLYING);
movement.c:  pilot_skill = (has_skill(ch, SKILL_PILOT) ? ch->skills[SKILL_PILOT]->learned : 0);
movement.c:  if (ch->specials.riding) {
movement.c:    if (!GET_SPEED(ch->specials.riding)) {
movement.c:      act("$N is already walking slowly.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:    act("You slap $N lightly on the side, and $E slows down.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:    GET_SPEED(ch->specials.riding) = SPEED_WALKING;
movement.c:  if (ch->in_room->sector_type == SECT_SILT) {
movement.c:  if (ch->specials.riding) {
movement.c:    if (GET_SPEED(ch->specials.riding)) {
movement.c:      act("$N is already running.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:    act("You slap $N lightly on the side, and $E begins to run.", FALSE, ch, 0, ch->specials.riding, TO_CHAR);
movement.c:    GET_SPEED(ch->specials.riding) = SPEED_RUNNING;
movement.c:  if (ch->obj_master) {
movement.c:    if (!ch->obj_master->followers) {
movement.c:      sprintf(buf, "Warning! %s has no followers!\n\r", OSTR(ch->obj_master, short_descr));
movement.c:    if (ch->obj_master->followers->follower == ch) {
movement.c:      if (!ch->obj_master) {
movement.c:      if (!ch->obj_master->followers) {
movement.c:      k = ch->obj_master->followers;
movement.c:      ch->obj_master->followers = k->next;
movement.c:      for (k = ch->obj_master->followers; 
movement.c:    ch->obj_master = (struct obj_data *) 0;
movement.c:  if (ch->master) {
movement.c:      act("Your mind reels momentarily as $N's hold over you wanes.", FALSE, ch, 0, ch->master, TO_CHAR);
movement.c:      act("$n will no longer take your orders.", FALSE, ch, 0, ch->master, TO_VICT);
movement.c:    if (ch->lifting && ch->master->lifting == ch->lifting) {
movement.c:      sprintf(buf, "[Dropping %s.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
movement.c:      if (!drop_lifting(ch, ch->lifting)) {
movement.c:    if (ch->master->followers->follower == ch) {
movement.c:      k = ch->master->followers;
movement.c:      ch->master->followers = k->next;
movement.c:      for (k = ch->master->followers; 
movement.c:    ch->master = 0;
movement.c:    REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_CHARM);
movement.c:    shhlog("ERROR: ch->master == NULL in stop_follower");
movement.c:  if (ch->master) {
movement.c:  ch->master = leader;
npc.c:        for (tch = target->in_room->people; tch; tch = tch->next_in_room)
npc.c:                for (tch = rm->people; tch; tch = tch->next_in_room)
npc.c:    if (IS_SET(ch->specials.act, CFL_SCAVENGER)
npc.c:        && ch->skills[SKILL_PEEK]
npc.c:    if (IS_SET(ch->specials.act, CFL_SCAVENGER)
npc.c:        && ch->skills[SKILL_PEEK]
npc.c:        && (!ch->specials.fighting))
npc.c:    ct = room_in_city(ch->in_room);
npc.c:    if (!(ch->skills[spell]))
npc.c:    lev = (ch->skills[spell]->rel_lev) - n;
npc.c:    if ((ch->skills[SPELL_BANISHMENT]) && (!(IS_SET(ch->in_room->room_flags, RFL_INDOORS)))
npc.c:    if ((ch->skills[SPELL_REPEL]) && (max_npc_spell_power(ch, SPELL_REPEL) > -1)) {
npc.c:    if ((ch->skills[SPELL_TELEPORT]) && (max_npc_spell_power(ch, SPELL_TELEPORT) > -1)) {
npc.c:    if ((GET_HIT(ch) < (GET_MAX_HIT(ch) / 2)) && (ch->skills[SPELL_HEAL])
npc.c:    if ((!IS_CALMED(fighting)) && (ch->skills[SPELL_CALM])
npc.c:    if (!(affected_by_spell(fighting, SPELL_POISON)) && (ch->skills[SPELL_POISON])
npc.c:    if ((ch->skills[SPELL_HEALTH_DRAIN]) && (max_npc_spell_power(ch, SPELL_HEALTH_DRAIN) > -1)) {
npc.c:     * (ch->skills[SPELL_INVULNERABILITY]) &&
npc.c:    if (!IS_AFFECTED(fighting, CHAR_AFF_SILENCE) && (ch->skills[SPELL_SILENCE])) {
npc.c:     * (ch->skills[SPELL_CALM]) &&
npc.c:    if ((!affected_by_spell(ch, SPELL_STONE_SKIN)) && (ch->skills[SPELL_STONE_SKIN])
npc.c:    if ((!IS_AFFECTED(fighting, CHAR_AFF_FEEBLEMIND)) && (ch->skills[SPELL_FEEBLEMIND])) {
npc.c:    if ((!affected_by_spell(ch, SPELL_STRENGTH)) && (ch->skills[SPELL_STRENGTH])
npc.c:    if ((!affected_by_spell(fighting, SPELL_WEAKEN)) && (ch->skills[SPELL_WEAKEN])
npc.c:    if ((ch->skills[SPELL_STAMINA_DRAIN]) && (max_npc_spell_power(ch, SPELL_STAMINA_DRAIN) > -1)) {
npc.c:    if ((ch->skills[SPELL_BANISHMENT]) && (max_npc_spell_power(ch, SPELL_BANISHMENT) > 1)) {
npc.c:    if ((ch->skills[SPELL_REPEL]) && (GET_HIT(ch) <= (GET_MAX_HIT(ch) / 2))
npc.c:    if ((ch->skills[SPELL_BLIND]) && (max_npc_spell_power(ch, SPELL_BLIND) > -1)) {
npc.c:         || (affected_by_spell(fighting, SPELL_ARMOR))) && (ch->skills[SPELL_DISPEL_MAGICK])
npc.c:    if ((!IS_AFFECTED(fighting, CHAR_AFF_BLIND)) && (ch->skills[SPELL_BLIND])
npc.c:    if ((GET_MANA(fighting) >= (GET_MAX_MANA(fighting) / 4)) && (ch->skills[SPELL_AURA_DRAIN])) {
npc.c:    if ((ch->skills[SPELL_DEMONFIRE]) && (max_npc_spell_power(ch, SPELL_DEMONFIRE) > -1)) {
npc.c:    if ((ch->skills[SPELL_FIREBALL]) && (max_npc_spell_power(ch, SPELL_FIREBALL) > -1)) {
npc.c:    if ((ch->skills[SPELL_FLAMESTRIKE]) && (max_npc_spell_power(ch, SPELL_FLAMESTRIKE) > -1)) {
npc.c:    if ((!IS_AFFECTED(fighting, CHAR_AFF_BLIND)) && (ch->skills[SPELL_BLIND])
npc.c:    if ((!affected_by_spell(fighting, SPELL_CURSE)) && (ch->skills[SPELL_BLIND])
npc.c:    if ((!affected_by_spell(fighting, SPELL_FEAR)) && (ch->skills[SPELL_FEAR])
npc.c:        && (ch->skills[SPELL_PSI_SUPPRESSION])
npc.c:    if ((ch->skills[SPELL_AURA_DRAIN]) && (max_npc_spell_power(ch, SPELL_AURA_DRAIN) > -1)) {
npc.c:    if ((!affected_by_spell(fighting, SPELL_PARALYZE)) && (ch->skills[SPELL_PARALYZE])
npc.c:    if ((!affected_by_spell(fighting, SPELL_SLOW)) && (ch->skills[SPELL_SLOW])
npc.c:    if ((ch->skills[SPELL_LIGHTNING_BOLT]) && (max_npc_spell_power(ch, SPELL_LIGHTNING_BOLT) > -1)) {
npc.c:    if ((GET_HIT(ch) < (GET_MAX_HIT(ch) / 2)) && (ch->skills[SPELL_HEAL])
npc.c:         || (affected_by_spell(fighting, SPELL_ARMOR))) && (ch->skills[SPELL_DISPEL_MAGICK])
npc.c:    if (!IS_AFFECTED(fighting, CHAR_AFF_SILENCE) && (ch->skills[SPELL_SILENCE])) {
npc.c:    if ((!IS_AFFECTED(fighting, CHAR_AFF_BLIND)) && (ch->skills[SPELL_BLIND])
npc.c:    if ((ch->skills[SPELL_BANISHMENT]) && (max_npc_spell_power(ch, SPELL_BANISHMENT) > -1)) {
npc.c:    if ((ch->skills[SPELL_FIREBALL]) && (max_npc_spell_power(ch, SPELL_FIREBALL) > -1)) {
npc.c:    if ((ch->skills[SPELL_HEALTH_DRAIN]) && (max_npc_spell_power(ch, SPELL_HEALTH_DRAIN) > -1)) {
npc.c:    if ((ch->skills[SPELL_LIGHTNING_BOLT]) && (max_npc_spell_power(ch, SPELL_LIGHTNING_BOLT) > -1)) {
npc.c:    if ((ch->skills[SPELL_FIREBALL]) && (max_npc_spell_power(ch, SPELL_FIREBALL) > -1)) {
npc.c:    if (ch->specials.act_wait > 0)
npc.c:    if ((ch->skills[SKILL_DISARM]) && (!(number(0, 4)))) {
npc.c:    } else if ((ch->skills[SKILL_KICK]) && (!(number(0, 3)))) {
npc.c:    } else if ((ch->skills[SKILL_BASH]) && (!(number(0, 3)))) {
npc.c:    if (IS_SET(ch->specials.act, CFL_SENTINEL))
npc.c:    if (!IS_SET(ch->specials.act, CFL_AGGRESSIVE) && !does_hate(ch, hates))
npc.c:        && GET_RACE(ch) != RACE_JAKHAL && GET_RACE(ch) != RACE_GESRA && !ch->specials.fighting
npc.c:    if ((ch->skills[SPELL_BURROW]) && (max_npc_spell_power(ch, SPELL_BURROW) > -1)) {
npc.c:    if ((!IS_AFFECTED(ch, CHAR_AFF_INVISIBLE)) && (ch->skills[SPELL_INVISIBLE])
npc.c:    if (!(ch->in_room) || (ch->desc) || (!ch->specials.fighting))
npc.c:    if (IS_SET(ch->specials.act, CFL_FROZEN))
npc.c:        acted = drov_cleric_act_combat(ch, ch->specials.fighting);
npc.c:        acted = nilaz_cleric_act_combat(ch, ch->specials.fighting);
npc.c:        acted = lightning_cleric_act_combat(ch, ch->specials.fighting);
npc.c:        acted = sun_cleric_act_combat(ch, ch->specials.fighting);
npc.c:        acted = water_cleric_act_combat(ch, ch->specials.fighting);
npc.c:        acted = wind_cleric_act_combat(ch, ch->specials.fighting);
npc.c:        acted = stone_cleric_act_combat(ch, ch->specials.fighting);
npc.c:        acted = templar_act_combat(ch, ch->specials.fighting);
npc.c:        acted = defiler_act_combat(ch, ch->specials.fighting);
npc.c:        acted = non_spell_act_combat(ch, ch->specials.fighting);
npc.c:        acted = non_spell_act_combat(ch, ch->specials.fighting);
npc.c:        if (ch->equipment[drawloc[j]] && (ch->equipment[drawloc[j]]->obj_flags.type == ITEM_WEAPON)) {
npc.c:            sprintf(buf, "%s", first_name(OSTR(ch->equipment[drawloc[j]], name), buf2));
npc.c:    if (!ch->equipment[ETWO] && (!ch->equipment[ES] || !ch->equipment[EP])) {
npc.c:        for (temp_obj = ch->carrying; temp_obj; temp_obj = temp_obj->next_content) {
npc.c:                if (!ch->equipment[EP])
npc.c:                else if (!ch->equipment[ES])
npc.c:    if (IS_SET(ch->specials.act, CFL_WIMPY)) {
npc.c:    if (IS_SET(ch->specials.act, CFL_NOHELP))
npc.c:        if (tar_ch->specials.fighting) {
npc.c:            if ((ch->in_room != tar_ch->in_room) && (!ch->specials.fighting)
npc.c:                && !IS_SET(ch->specials.act, CFL_SENTINEL)) {
npc.c:                dir = choose_exit_name_for(ch->in_room, tar_ch->in_room, ch_command, 2, ch);
npc.c:                if (ch->skills[SKILL_RESCUE]) { /*  should work now  */
npc.c:                if (ch->skills[SPELL_HEAL] && (max_npc_spell_power(ch, SPELL_HEAL) > -1)) {
npc.c:            if (!ch->specials.fighting) {
npc.c:    if (IS_CALMED(ch) || ch->specials.fighting)
npc.c:        && IS_SET(tar_ch->specials.act, CFL_CRIM_ALLANAK)
npc.c:        && IS_SET(tar_ch->specials.act, CFL_CRIM_ALLANAK)
npc.c:        if ((ch->in_room != tar_ch->in_room) && !IS_SET(ch->specials.act, CFL_SENTINEL)) {
npc.c:            dir = choose_exit_name_for(ch->in_room, tar_ch->in_room, ch_command, 2, ch);
npc.c:                if ((missile = ch->equipment[EP]) != NULL) {
npc.c:                        ex = choose_exit_name_for(ch->in_room,  /*start room  */
npc.c:                                                  tar_ch->in_room,      /* target room */
npc.c:                if ((missile = ch->equipment[ES]) != NULL)
npc.c:                            if (!(missile = ch->equipment[EP]))
npc.c:                                for (temp_obj = ch->carrying; temp_obj;
npc.c:                            if (!(missile = ch->equipment[EP]))
npc.c:                                for (temp_obj = ch->carrying; temp_obj;
npc.c:                            if ((missile = ch->equipment[EP]) != NULL) {
npc.c:                                    ex = choose_exit_name_for(ch->in_room, tar_ch->in_room, exit_name, 3,       /* max dist   */
npc.c:                                        first_name(OSTR(ch->equipment[ES], name), buf2));
npc.c:                                    if (ch->equipment[drawloc[j]]
npc.c:                                        && (ch->equipment[drawloc[j]]->obj_flags.type ==
npc.c:                                                first_name(OSTR(ch->equipment[drawloc[j]], name),
npc.c:                && !IS_SET(ch->specials.act, CFL_AGGRESSIVE))
npc.c:            if (ch->skills[SKILL_BACKSTAB]) {
npc.c:            } else if (ch->skills[SKILL_SAP]) {
npc.c:     * if (find_ex_description("[SPECIAL_POOP]", ch->ex_description, TRUE))
npc.c:    obj_to_room(poopobject, ch->in_room);
npc.c:    if (!(ch->in_room) || (ch->desc) || is_in_command_q(ch))
npc.c:    if (IS_SET(ch->specials.act, CFL_FROZEN))
npc.c:    if (find_ex_description("[UNDYING]", ch->ex_description, TRUE))
npc.c:        if (IS_SET(ch->specials.act, CFL_UNDEAD))
npc.c:    if (ch->specials.subduing && affected_by_spell(ch->specials.subduing, SPELL_FIRE_ARMOR)) {
npc.c:     && ch->specials.fighting && !CAN_SEE(ch, ch->specials.fighting)){ 
npc.c:    if (IS_SET(ch->specials.act, CFL_MOUNT) && !ch->specials.fighting) {
npc.c:        if (ch->specials.fighting && !number(0, 2)) {
npc.c:    for (tmp = ch->in_room->people; tmp; tmp = tmp->next_in_room) {
npc.c:    for (tmp = ch->in_room->people; tmp; tmp = next_in_room) {
npc.c:    for (startPerson = ch->in_room->people; startPerson && roomCount < startCount;
npc.c:        else if (tmp == startPerson && startPerson == ch->in_room->people) {
npc.c:            next_in_room = ch->in_room->people;
npc.c:                if (IS_SET(ch->specials.act, CFL_AGGRESSIVE)
npc.c:    for (tmp = ch->in_room->people; tmp && !acted; tmp = next_in_room) {
npc.c:                    if (IS_SET(ch->specials.act, CFL_AGGRESSIVE)
npc.c:        if (ch && ch->in_room && ch->in_room->direction[dir]) {
npc.c:            near_room = ch->in_room->direction[dir]->to_room;
npc.c:                else if (tmp == startPerson && startPerson == ch->in_room->people)
npc.c:                    if ((IS_SET(ch->specials.act, CFL_AGGRESSIVE)
npc.c:                    if ((IS_SET(ch->specials.act, CFL_AGGRESSIVE)
npc.c:    if (IS_SET(ch->specials.act, CFL_SCAVENGER)) {
npc.c:        if (AWAKE(ch) && !(ch->specials.fighting)) {
npc.c:            if (ch->skills[SKILL_PEEK] && !number(0, 10)) {
npc.c:                for (tmp = ch->in_room->people; tmp && !acted; tmp = next_in_room) {
npc.c:            if (ch->in_room->contents && !number(0, 10)) {
npc.c:                for (max = 1, best_obj = 0, obj = ch->in_room->contents; obj;
npc.c:    if ((ch->skills[SKILL_HUNT]) && ch->specials.hates) {
npc.c:        tmp = find_closest_hates(ch, MAX(5, ch->skills[SKILL_HUNT]->learned / 10));
npc.c:    if (IS_SET(ch->specials.act, CFL_AGGRESSIVE)) {
npc.c:        if (AWAKE(ch) && !(ch->specials.fighting)) {
npc.c:            if (ch->in_room->contents && !number(0, 10)) {
npc.c:                for (best_obj = 0, obj = ch->in_room->contents; obj; obj = obj->next_content) {
npc.c:                        char_to_room(tmp, ch->in_room);
npc.c:                        obj_to_room(tmp_obj, ch->in_room);
npc.c:                    obj_to_room(tmp_obj, ch->in_room);
npc.c:    if (IS_SET(ch->specials.act, CFL_SCAVENGER) && FALSE) {
npc.c:        if (ch->skills[SKILL_STEAL]) {
npc.c:            if (ch->skills[SKILL_STEAL]->learned > 50) {
npc.c:                    for (tmp = ch->in_room->people; tmp; tmp = tmp->next_in_room)
npc.c:    if (!ch->specials.fighting || (GET_POS(ch) != POSITION_FIGHTING))
npc.c:    if (skill_success(ch, NULL, ch->skills[SKILL_WILLPOWER]->learned))
npc.c:    sprintf(logbuf, "Mul rage overtakes %s in room %d.", GET_NAME(ch), ch->in_room->number);
npc.c:    if (!(rm = ch->in_room)) {
npc.c:    if (!ch->desc && ch->specials.act_wait > 0)
npc.c:        ch->specials.act_wait = MAX(ch->specials.act_wait - WAIT_SEC, 0);
npc.c:    if (ch->queued_commands && ch->specials.act_wait <= 0 && !in_command_q ) {
npc.c:    if (ch->specials.act_wait == 0 && !in_command_q) {
npc.c:    if (!ch->on_obj || (ch->on_obj && (!ch->on_obj->table && ch->on_obj->obj_flags.value[2] <= 1))) {
npc.c:    if (ch->on_obj->table)
npc.c:        table = ch->on_obj->table;
npc.c:        table = ch->on_obj;
npc.c:        gprintf(NULL, ch->in_room, "$csc babble$cy incoherently.\n", ch, ch);
npc.c:    sprintf(buf, "talks at their %s", ch->on_obj->table ? "table" : "seat");
npc.c:    sprintf(buf, "At your %s, you say in %s%s%s:\n\r", ch->on_obj
npc.c:            && ch->on_obj->table ? "table" : "seat", skill_name[GET_SPOKEN_LANGUAGE(ch)],
npc.c:    for (vch = ch->in_room->people; vch; vch = vch->next_in_room) {
npc.c:            CHAR_DATA *gch = vch->specials.guarding;
npc.c:            CHAR_DATA *fch = vch->master;
npc.c:            if( gch && (gch->on_obj == table 
npc.c:             || (gch->on_obj 
npc.c:              && gch->on_obj->table && gch->on_obj->table == table))) {
npc.c:            if( !vch->on_obj && fch && (fch->on_obj == table 
npc.c:             || (fch->on_obj && fch->on_obj->table
npc.c:              && fch->on_obj->table == table))) {
npc.c:            if (vch->on_obj == table
npc.c:                || (vch->on_obj && vch->on_obj->table && vch->on_obj->table == table)) {
npc.c:                sprintf(buf, "At your %s, %s says in %s%s%s:\n\r", vch->on_obj
npc.c:                        && vch->on_obj->table ? "table" : "seat", name, language,
npc.c:                 ? vch->skills[SKILL_LISTEN]->learned : 0;
npc.c:                        ch->on_obj->table ? format_obj_to_char(ch->on_obj->table, vch, 1)
npc.c:                        : format_obj_to_char(ch->on_obj, vch, 1), name, language,
npc.c:                            (ch->on_obj->table ? format_obj_to_char(ch->on_obj->table, vch, 1)
npc.c:                             : format_obj_to_char(ch->on_obj, vch, 1)), name, how);
npc.c:        for (tmp_wlist = ch->in_room->watched_by; tmp_wlist; tmp_wlist = tmp_wlist->next_watched_by) {
npc.c:                            (ch->on_obj->table ? format_obj_to_char(ch->on_obj->table, lis, 1)
npc.c:                             : format_obj_to_char(ch->on_obj, lis, 1)), PERS(lis, ch),
object.c:    if (!ch->on_obj)
object.c:    chair = ch->on_obj;
object.c:        if (!ch->equipment[WEAR_HANDS])
object.c:        if (!ch->equipment[WEAR_ABOUT])
object.c:            if (ch->equipment[counter])
object.c:                    || (counter == WEAR_ABOUT && (!(ch->equipment[WEAR_BODY]))))
object.c:                    sflag_to_obj(ch->equipment[counter], sflag);
object.c:            if (ch->equipment[counter])
object.c:                        sflag_to_obj(ch->equipment[counter], sflag);
object.c:            if (ch->equipment[counter])
object.c:                    sflag_to_obj(ch->equipment[counter], sflag);
object.c:            if (ch->equipment[counter])
object.c:                sflag_to_obj(ch->equipment[counter], sflag);
object.c:    for (tmp_ch = rm->people; tmp_ch; tmp_ch = tmp_ch->next_in_room)
object.c:  sprintf(crafter_name, "[CRAFTED_BY_%s_(%s)]", ch->name, ch->account);
object.c:    sprintf(crafter_name, "[CRAFTED_BY_%s_(%s)]", ch->name, ch->account);
object.c:    if (!ch->desc)
object.c:      sprintf(crafter_name, "[CRAFTED_BY__m%d]", ch->nr);
object.c:      if (ch->desc->original)
object.c:	sprintf(crafter_name, "[CRAFTED_BY_%s_(%s)_while_playing_m%d]", ch->desc->original->name, ch->desc->original->account, ch->nr);
object.c:    assert(!ch->obj_master);
object.c:    ch->obj_master = obj_leader;
object.c:    if (ch->lifting) {
object.c:        sprintf(buffer, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
object.c:        if (!drop_lifting(ch, ch->lifting))
object.c:    if ((ch->specials.riding) && (obj_object->in_room || (sub_object && sub_object->in_room))) {
object.c:        for (tmp_ch = ch->in_room->people; tmp_ch; tmp_ch = tmp_ch->next)
object.c:                && (tmp_ch->specials.fighting == ch || tmp_ch->specials.alt_fighting == ch)) {
object.c:                old_def = (int) ch->abilities.def;
object.c:                ch->abilities.def -= 25;
object.c:                ch->abilities.def = (sbyte) MAX(0, ch->abilities.def - 25);
object.c:                    ch->abilities.def = (sbyte) old_def;
object.c:            if (ch->equipment[EP] || ch->equipment[ES]
object.c:                || ch->equipment[ETWO] || ch->specials.riding || ch->specials.subduing) {
object.c:            if (ch->desc && ch->desc->str) {
object.c:                    obj_to_room(around, ch->in_room);
object.c:            obj_to_room(around, ch->in_room);
object.c:            for (j = 0; j < MAX_WEAR && (ch->equipment[j] != sub_object); j++) {        /* skip thru till found */
object.c:            for (tmp_obj = ch->carrying; tmp_obj; tmp_obj = tmp_obj->next_content)
object.c:            && (ch->skills[SKILL_SLEIGHT_OF_HAND]
object.c:                                 ch->skills[SKILL_SLEIGHT_OF_HAND]->learned + palm_bonus))) {
object.c:                for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
object.c:            for (tmp_obj = ch->carrying; tmp_obj; tmp_obj = tmp_obj->next_content)
object.c:    if (!ch->specials.to_process && cmd == CMD_PALM) {
object.c:        for (obj_object = ch->in_room->contents; obj_object && ch->in_room; obj_object = next_obj) {
object.c:                    if (ch->specials.act_wait <= 0)
object.c:                        ch->specials.act_wait = number(3,5);
object.c:        obj_object = get_obj_in_list_vis(ch, arg1, ch->in_room->contents);
object.c:                            if (ch->specials.act_wait <= 0)
object.c:                                ch->specials.act_wait = number(3,5);
object.c:                                if (ch->specials.act_wait <= 0)
object.c:                                    ch->specials.act_wait = number(3,5);
object.c:                if (sub_object->carried_by != ch && ch->on_obj
object.c:                                if (ch->specials.act_wait <= 0)
object.c:                                    ch->specials.act_wait = number(3,5);
object.c:                if (sub_object->carried_by != ch && ch->on_obj 
object.c:                        obj_to_room(around, ch->in_room);
object.c:    for (ch = room->people; ch; ch = ch->next_in_room)
object.c:        weight = weight + ch->player.weight + (calc_carried_weight(ch) / 10);
object.c:    if (is_cargo_bay(ch->in_room)) {
object.c:        weight = get_room_weight(ch->in_room);
object.c:        rm_max_weight = get_room_max_weight(ch->in_room);
object.c:            if (!ch->desc) {
object.c:                 GET_NAME(ch), npc_index[ch->nr].vnum, OSTR(obj, short_descr), 
object.c:                 GET_NAME(ch), ch->desc->player_info->name,
object.c:             GET_NAME(ch), ch->account, OSTR(obj, short_descr), 
object.c:        if (!(cash_obj = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
object.c:                    obj_to_room(cash_obj, ch->in_room);
object.c:                    obj_to_room(new_cash, ch->in_room);
object.c:            if (ch->lifting)
object.c:                if (drop_lifting(ch, ch->lifting))
object.c:            for (tmp_object = ch->carrying; tmp_object; tmp_object = next_obj) {        /* Go through the loop and drop each item */
object.c:                        else if (ch->in_room) {
object.c:                            switch (ch->in_room->sector_type) {
object.c:                            obj_to_room(tmp_object, ch->in_room);
object.c:                            if (ch->specials.act_wait <= 0)
object.c:                                ch->specials.act_wait = number(3,5);
object.c:                            if (tmp_object == ch->equipment[j])
object.c:                    else if (ch->in_room)
object.c:                        switch (ch->in_room->sector_type) {
object.c:                    obj_to_room(tmp_object, ch->in_room);
object.c:            } else if (ch->lifting && (isname(arg, OSTR(ch->lifting, name)))) {  /* End item found */
object.c:                drop_lifting(ch, ch->lifting);
object.c:            if (obj_object == ch->equipment[j])
object.c:                    if (ch->equipment[WEAR_ON_BELT_1]) {
object.c:                                OSTR(ch->equipment[WEAR_ON_BELT_1], short_descr));
object.c:                        if (ch->equipment[WEAR_ON_BELT_2]) {
object.c:                                    OSTR(ch->equipment[WEAR_ON_BELT_2], short_descr));
object.c:            && (ch->skills[SKILL_SLEIGHT_OF_HAND]
object.c:                                 ch->skills[SKILL_SLEIGHT_OF_HAND]->learned + slip_bonus))) {
object.c:                for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
object.c:            && (ch->skills[SKILL_SLEIGHT_OF_HAND]
object.c:                                 ch->skills[SKILL_SLEIGHT_OF_HAND]->learned + slip_bonus))) {
object.c:                for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
object.c:        for (j = 0; j < MAX_WEAR && (ch->equipment[j] != sub_object); j++) {    /* skip thru till found */
object.c:    if (!ch->specials.to_process && cmd == CMD_SLIP) {
object.c:        if (sub_object->carried_by != ch && ch->on_obj
object.c:    if (ch->lifting) {
object.c:        sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
object.c:        if (!drop_lifting(ch, ch->lifting))
object.c:        if (!(cash_obj = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
object.c:            for (obj_object = ch->carrying; obj_object; obj_object = next_obj) {
object.c:                        if (ch->specials.act_wait <= 0)
object.c:                            ch->specials.act_wait = number(3,5);
object.c:                    if ((obj_object = get_obj_in_list_vis(ch, arg1, ch->in_room->contents)) == NULL) {
object.c:    if (ch->specials.riding) {
object.c:    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
object.c:    skill = ch->skills[SKILL_STEAL] ? ch->skills[SKILL_STEAL]->learned : 0;
object.c:    if (IS_SET(ch->in_room->room_flags, RFL_POPULATED))
object.c:    if (IS_SET(ch->in_room->room_flags, RFL_INDOORS))
object.c:            obj_to_room(obj, ch->in_room);
object.c:            if (!(item = get_object_in_equip_vis(ch, item_name, tar_ch->equipment, &eq_pos))) {
object.c:            for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
object.c:            REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
object.c:                if ((ct = room_in_city(ch->in_room)) == CITY_NONE)
object.c:                else if (!IS_SET(tar_ch->specials.act, CFL_SENTINEL))
object.c:                } else if (!IS_SET(tar_ch->specials.act, CFL_SENTINEL)) {
object.c:        if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
object.c:    if (!(obj = get_obj_in_list_vis(ch, obj_name, ch->carrying))) {
object.c:    if (ch->lifting) {
object.c:        sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
object.c:        if (!drop_lifting(ch, ch->lifting))
object.c:    if (!(temp = get_obj_in_list_vis(ch, buf, ch->carrying))) {
object.c:            if (!(temp = get_obj_in_list_vis(ch, buf, ch->in_room->contents))) {
object.c:            tmp_af = ch->affected;
object.c:            for (hjp = ch->affected; hjp; hjp = next_hjp) {
object.c:    if (ch->lifting) {
object.c:        cprintf(ch, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
object.c:        if (!drop_lifting(ch, ch->lifting))
object.c:            ch->points.hit = MAX(1, ch->points.hit - 10);
object.c:            ch->points.move = MAX(1, ch->points.move - 10);
object.c:    if (!(from_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
object.c:                 IS_NPC(ch) ? "" : ch->account, IS_NPC(ch) ? "" : ")");
object.c:        if (!ch->in_room)
object.c:        if ((IS_SET(ch->in_room->room_flags, RFL_PLANT_SPARSE)
object.c:             || IS_SET(ch->in_room->room_flags, RFL_PLANT_HEAVY)) && is_water) {
object.c:                if (wn->zone == ch->in_room->zone)
object.c:                    ch->specials.eco = MIN(ch->specials.eco + 1, 100);
object.c:         IS_NPC(ch) ? "" : ch->account, IS_NPC(ch) ? "" : ")");
object.c:                            extinguish_light(to_obj, ch->in_room);
object.c:                            extinguish_light(to_obj, ch->in_room);
object.c:                            extinguish_light(to_obj, ch->in_room);
object.c:    if (!(from_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
object.c:                 IS_NPC(ch) ? "" : ch->account, IS_NPC(ch) ? "" : ")");
object.c:        if (!ch->in_room)
object.c:           obj_to_room(temp_obj, ch->in_room);
object.c:         IS_NPC(ch) ? "" : ch->account, IS_NPC(ch) ? "" : ")");
object.c:             IS_NPC(ch) ? "" : " (", IS_NPC(ch) ? "" : ch->account, IS_NPC(ch) ? "" : ")");
object.c:  if (!(temp = get_obj_in_list_vis(ch, arg, ch->carrying)))
object.c:    if (!(temp = get_obj_in_list_vis(ch, arg, ch->in_room->contents))) {
object.c:            tmp_desc = find_ex_description(wear_edesc[i].edesc_name, ch->ex_description, TRUE);
object.c:    send_to_room_parsed(ch, ch->in_room, message, FALSE);
object.c:        if (ch->equipment[WEAR_BELT])
object.c:        if ((ch->equipment[WEAR_FINGER_L]) && (ch->equipment[WEAR_FINGER_R])
object.c:         && (ch->equipment[WEAR_FINGER_L2]) && (ch->equipment[WEAR_FINGER_R2])
object.c:         && (ch->equipment[WEAR_FINGER_L3]) && (ch->equipment[WEAR_FINGER_R3])
object.c:         && (ch->equipment[WEAR_FINGER_L4]) && (ch->equipment[WEAR_FINGER_R4])
object.c:         && (ch->equipment[WEAR_FINGER_L5]) && (ch->equipment[WEAR_FINGER_R5]))
object.c:        if (ch->equipment[WEAR_NECK]) 
object.c:        if (ch->equipment[WEAR_BODY]) 
object.c:        if (ch->equipment[WEAR_HEAD])
object.c:        if (ch->equipment[WEAR_LEGS])
object.c:        if (ch->equipment[WEAR_FEET])
object.c:        if (ch->equipment[WEAR_HANDS])
object.c:        if (ch->equipment[WEAR_ARMS])
object.c:        if (ch->equipment[WEAR_ABOUT]) 
object.c:        if (ch->equipment[WEAR_WAIST])
object.c:        if ((ch->equipment[WEAR_WRIST_L]) && (ch->equipment[WEAR_WRIST_R]))
object.c:        if (ch->equipment[WEAR_WRIST_R])
object.c:        if (ch->equipment[WEAR_WRIST_L])
object.c:        if (ch->equipment[EP])
object.c:        if (ch->equipment[ES])
object.c:        if (ch->equipment[WEAR_BACK])
object.c:        if (ch->equipment[WEAR_ON_BELT_1] && ch->equipment[WEAR_ON_BELT_2])
object.c:        if (ch->equipment[ETWO])
object.c:        if (ch->equipment[WEAR_IN_HAIR])
object.c:        if (ch->equipment[WEAR_FACE])
object.c:        if (ch->equipment[WEAR_ANKLE] && ch->equipment[WEAR_ANKLE_L])
object.c:        if (ch->equipment[WEAR_ANKLE])
object.c:        if (ch->equipment[WEAR_ANKLE_L])
object.c:        if (ch->equipment[WEAR_LEFT_EAR])
object.c:        if (ch->equipment[WEAR_RIGHT_EAR])
object.c:        if (ch->equipment[WEAR_FOREARMS])
object.c:        if (ch->equipment[WEAR_ABOUT_HEAD])
object.c:        if (ch->equipment[WEAR_ABOUT_THROAT])
object.c:        if (ch->equipment[WEAR_SHOULDER_R] && ch->equipment[WEAR_SHOULDER_L])
object.c:        if (ch->equipment[WEAR_SHOULDER_R])
object.c:        if (ch->equipment[WEAR_SHOULDER_L])
object.c:        if (ch->equipment[WEAR_OVER_SHOULDER_R] && ch->equipment[WEAR_OVER_SHOULDER_L])
object.c:        if (ch->equipment[WEAR_OVER_SHOULDER_R])
object.c:        if (ch->equipment[WEAR_OVER_SHOULDER_L])
object.c:                if (!ch->equipment[WEAR_FINGER_L]) {
object.c:                } else if (!ch->equipment[WEAR_FINGER_R]) {
object.c:                } else if (!ch->equipment[WEAR_FINGER_L2]) {
object.c:                } else if (!ch->equipment[WEAR_FINGER_R2]) {
object.c:                } else if (!ch->equipment[WEAR_FINGER_L3]) {
object.c:                } else if (!ch->equipment[WEAR_FINGER_R3]) {
object.c:                } else if (!ch->equipment[WEAR_FINGER_L4]) {
object.c:                } else if (!ch->equipment[WEAR_FINGER_R4]) {
object.c:                } else if (!ch->equipment[WEAR_FINGER_L5]) {
object.c:                } else if (!ch->equipment[WEAR_FINGER_R5]) {
object.c:                    REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_SNEAK);
object.c:                if (ch->equipment[WEAR_WRIST_R]) {
object.c:                    if (ch->specials.subduing != (struct char_data *) 0) {
object.c:                            ch->specials.subduing, TO_NOTVICT);
object.c:                            ch->specials.subduing, TO_VICT);
object.c:                            ch->specials.subduing, TO_CHAR);
object.c:                        REMOVE_BIT(ch->specials.subduing->specials.affected_by, CHAR_AFF_SUBDUED);
object.c:                        ch->specials.subduing = (struct char_data *) 0;
object.c:                    if (ch->specials.subduing != (struct char_data *) 0) {
object.c:                        REMOVE_BIT(ch->specials.subduing->specials.affected_by, CHAR_AFF_SUBDUED);
object.c:                        ch->specials.subduing = (struct char_data *) 0;
object.c:                if (ch->equipment[WEAR_BELT]) {
object.c:                    find_obj_keyword(ch->equipment[WEAR_BELT],
object.c:                    if (ch->equipment[WEAR_ON_BELT_1])
object.c:                if (!ch->equipment[WEAR_ANKLE]) {
object.c:                if (!ch->equipment[WEAR_SHOULDER_L]) {
object.c:                if (!ch->equipment[WEAR_OVER_SHOULDER_L]) {
object.c:        for (obj = ch->carrying; obj; obj = next_obj) {
object.c:                        if (ch->specials.act_wait <= 0)
object.c:                            ch->specials.act_wait = number(3,5);
object.c:        for (obj = ch->carrying; obj; obj = next_obj) {
object.c:                        if (ch->specials.act_wait <= 0)
object.c:                             ch->specials.act_wait = number(3,5);
object.c:        obj_object = get_obj_in_list_vis(ch, arg1, ch->carrying);
object.c:    if ((obj = ch->equipment[ETWO])) {
object.c:    if ((obj = ch->equipment[EP])) {
object.c:    if ((obj = ch->equipment[ES])) {
object.c:        obj = get_obj_in_list_vis(ch, buf, ch->carrying);
object.c:            if (ch->equipment[EP] || ch->equipment[ES]) {
object.c:            if (ch->lifting) {
object.c:                sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
object.c:                if (!drop_lifting(ch, ch->lifting))
object.c:        obj_object = get_obj_in_list(ch, buf, ch->carrying);
object.c:            if (ch->equipment[ETWO]) {
object.c:                act("You have enough problems holding onto $p.", FALSE, ch, ch->equipment[ETWO], 0,
object.c:            if (ch->lifting) {
object.c:                sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
object.c:                if (!drop_lifting(ch, ch->lifting))
object.c:        obj_object = get_obj_in_list(ch, buf, ch->carrying);
object.c:            if (ch->equipment[ETWO]) {
object.c:                act("You have enough trouble holding onto $p.", FALSE, ch, ch->equipment[ETWO], 0,
object.c:            if (ch->lifting) {
object.c:                sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
object.c:                if (!drop_lifting(ch, ch->lifting))
object.c:        obj_object = get_object_in_equip(arg1, ch->equipment, &j);
object.c:                obj_to_room(unequip_char(ch, j), ch->in_room);
object.c:                    if (drop_light(obj_object, ch->in_room))
object.c:                    if (ch->equipment[WEAR_ON_BELT_1]) {
object.c:                                OSTR(ch->equipment[WEAR_ON_BELT_1], short_descr));
object.c:                        if (ch->equipment[WEAR_ON_BELT_2]) {
object.c:                                    OSTR(ch->equipment[WEAR_ON_BELT_2], short_descr));
object.c:                            find_ex_description(wear_edesc[i].edesc_name, ch->ex_description, TRUE);
object.c:    if (!(temp = get_obj_in_list_vis(ch, arg, ch->carrying))) {
object.c:        for (from = ch->in_room->contents; from; from = from->next_content)
object.c:            if (ch->in_room)
object.c:                switch (ch->in_room->sector_type) {
object.c:    if ((hood = get_object_in_equip_vis(ch, arg, ch->equipment, &j)) == NULL) {
object.c:            tmp = ch->equipment[j];
object.c:        tmp = ch->equipment[WEAR_ABOUT];
object.c:        tmp = ch->equipment[WEAR_ABOUT];
object.c:    if ((hood = get_object_in_equip_vis(ch, arg, ch->equipment, &j)) == NULL) {
object.c:            tmp = ch->equipment[j];
object.c:    tmp = ch->equipment[WEAR_ABOUT];
object.c:    if ((hood = get_object_in_equip_vis(ch, arg, ch->equipment, &j)) == NULL) {
object.c:            tmp = ch->equipment[j];
object.c:    tmp = ch->equipment[WEAR_ABOUT];
object.c:    target = get_obj_in_list_vis(ch, buf, ch->carrying);
object.c:    if (!ch->specials.to_process) {
object.c:            obj_to_room(result, ch->in_room);
object.c:      if (ch->equipment[eq_index]) {
object.c:        current_obj = ch->equipment[eq_index];
object.c:      current_obj = ch->carrying;
object.c:      current_obj = ch->in_room->contents;
object.c:    OBJ_DATA *current_obj = ch->in_room->contents;
object.c:  if (!ch->specials.to_process) {
object.c:        (ch->skills[make_item_list[recipe_index].skill]->learned -
object.c:  bonus = get_room_skill_bonus(ch->in_room, make_item_list[recipe_index].skill);
object.c:  if (get_room_skill_bonus_msg(ch->in_room, make_item_list[recipe_index].skill, bonus_msg)) {
object.c:  if (ch->player.level > 0) {
object.c:    cprintf(ch, "Your skill: %d\n\r", ch->skills[make_item_list[recipe_index].skill]->learned);
object.c:            ch->skills[make_item_list[recipe_index].skill]->learned + bonus);
object.c:        (ch->skills[make_item_list[recipe_index].skill]->learned + bonus)) {
object.c:  worked = ((make_item_list[recipe_index].percentage_mod + die_roll) < (ch->skills[make_item_list[recipe_index].skill]->learned + bonus));
object.c:        obj_to_room(new_obj[i], ch->in_room);
object.c:      int chSkill = ch->skills[recipe.skill]->learned;
object.c:                obj_to_room(obj_vec[i], ch->in_room);
object.c:        if ((ch->skills[make_item_list[i].skill])
object.c:            && (ch->skills[make_item_list[i].skill]->learned >= make_item_list[i].percentage_min)
object.c:        if ((ch->skills[make_item_list[i].skill])
object.c:            && (ch->skills[make_item_list[i].skill]->learned >= make_item_list[i].percentage_min)
object.c:                ch->skills[make_item_list[i].skill]->learned < make_item_list[i].percentage_min) {
ocreation.c:        if( (obj = get_obj_in_list_vis( ch, buf1, ch->carrying ) ) == NULL ) {
ocreation.c:        obj_to_room(obj, ch->in_room);
ocreation.c:    if (!ch->desc)
ocreation.c:        if (ch->player.level < 4) {
ocreation.c:        zone = ch->in_room->zone;
ocreation.c:    page_string(ch->desc, output, 1);
other.c:        if (IS_SET(ch->specials.mercy, (1 << (new - 3))))
other.c:            ch->specials.mercy = 0;
other.c:            ch->specials.mercy = ~0;
other.c:            if (IS_SET(ch->specials.mercy, flag)) {
other.c:                REMOVE_BIT(ch->specials.mercy, flag);
other.c:                MUD_SET_BIT(ch->specials.mercy, flag);
other.c:        if (!(dirty_obj = get_obj_in_list_vis(ch, arg1, ch->carrying)))
other.c:    //    if (!ch->specials.to_process) {
other.c:                if ((ch->equipment[counter])
other.c:                    && (IS_SET(ch->equipment[counter]->obj_flags.state_flags, OST_DUSTY))) {
other.c:                    REMOVE_BIT(ch->equipment[counter]->obj_flags.state_flags, OST_DUSTY);
other.c:                if ((dirty_ch->equipment[counter])
other.c:                    && (IS_SET(dirty_ch->equipment[counter]->obj_flags.state_flags, OST_DUSTY))) {
other.c:                    REMOVE_BIT(dirty_ch->equipment[counter]->obj_flags.state_flags, OST_DUSTY);
other.c:            if ((ch->skills[new])
other.c:                    ch->specials.language = i;
other.c:                if (has_skill(ch, new) && ch->skills[new]->learned >= MIN_ACCENT_LEVEL) {
other.c:                        ch->specials.accent = new;
other.c:                    ch->specials.accent = new;
other.c:            if (has_skill(ch, acc) && ch->skills[acc]->learned >= MIN_ACCENT_LEVEL) {
other.c:                        one_obj = ch->equipment[hands[old].pos];
other.c:                        two_obj = ch->equipment[hands[new].pos];
other.c:                        if (hands[new].pos == ETWO && ch->equipment[EP] && ch->equipment[ES]) {
other.c:                        if (ch->equipment[hands[new].pos] == one_obj) {
other.c:                if (!ch->desc || ch->desc->snoop.snooping) {
other.c:                if ((beast) && (ch->desc)) {
other.c:                    if (ch->desc->snoop.snoop_by) {
other.c:                        ch->desc->snoop.snoop_by->desc->snoop.snooping = 0;
other.c:                        ch->desc->snoop.snoop_by = 0;
other.c:                    char_to_room(beast, ch->in_room);
other.c:                    if (!ch->desc->original)
other.c:                        ch->desc->original = ch;
other.c:                    ch->desc->character = beast;
other.c:                    beast->desc = ch->desc;
other.c:                    ch->desc = 0;
other.c:                    sprintf(new_ld, "Your new objective is:\n\r%s\n\r", ch->player.info[1]);
other.c:            if (!ch->specials.fighting) {
other.c:            if ((ch->specials.fighting->specials.guarding == target)
other.c:                && has_skill(ch->specials.fighting, SKILL_RESCUE)) {
other.c:                if (get_skill_percentage(ch->specials.fighting, SKILL_RESCUE) > number(1, 101)) {
other.c:                        FALSE, ch, 0, ch->specials.fighting, TO_CHAR);
other.c:                    act(msg, FALSE, ch, 0, ch->specials.fighting, TO_VICT);
other.c:            for (beast = ch->in_room->people; beast; beast = beast->next_in_room) {
other.c:                    if (beast == ch->specials.fighting) {
other.c:                    } /* end if beast = ch->specials.fighting */
other.c:                                PERS(beast, ch->specials.fighting));
other.c:                        sprintf(msg, "%s.\n\r", PERS(beast, ch->specials.fighting));
other.c:            ch->specials.fighting = target;
other.c:            ch->specials.alt_fighting = 0;
other.c:                if (!IS_SET(ch->in_room->room_flags, RFL_SAFE)
other.c:                } else if (!IS_SET(ch->in_room->room_flags, RFL_SAFE)
other.c:                    if (ch->in_room->number == 1023) {
other.c:                    if (ch->in_room->number == 1012) {
other.c:                    if (room_in_city(ch->in_room)) {
other.c:                    } else if (ch->in_room->sector_type == SECT_SILT) {
other.c:                    } else if (ch->in_room->sector_type == SECT_CITY) {
other.c:                sprintf(buf, "%d", ch->in_room->number);
other.c:             || ch->specials.fighting) {
other.c:            if (!IS_SET(ch->in_room->room_flags, RFL_SAFE)
other.c:            } else if (!IS_SET(ch->in_room->room_flags, RFL_SAFE)
other.c:                if (ch->in_room->number == 1012) {
other.c:                if (ch->in_room->number == 1023) {
other.c:                if (room_in_city(ch->in_room)) {
other.c:                } else if (ch->in_room->sector_type == SECT_SILT) {
other.c:                } else if (ch->in_room->sector_type == SECT_CITY) {
other.c:            sprintf(buf, "%d", ch->in_room->number);
other.c:                gamelogf("%s (%s) is viewing the arena games.", ch->name, ch->account);
other.c:    object = get_obj_in_list_vis(ch, arg, ch->carrying);
other.c:                (ch->abilities.off + GET_AGL(ch) + number(1, 100)) >=
other.c:                if (ch->in_room != person->in_room)
other.c:            (ch->abilities.off + GET_AGL(ch) + number(1, 100)) >=
other.c:        if (IS_SET(ch->specials.nosave, (1 << (new - 3))))
other.c:            ch->specials.nosave = 0;
other.c:            ch->specials.nosave = ~0;
other.c:            if (IS_SET(ch->specials.nosave, flag)) {
other.c:                REMOVE_BIT(ch->specials.nosave, flag);
other.c:                MUD_SET_BIT(ch->specials.nosave, flag);
other.c:        if (IS_SET(ch->specials.nosave, NOSAVE_PSIONICS) && affected_by_spell(ch, PSI_BARRIER)) {
other.c:        if (IS_SET(ch->specials.nosave, NOSAVE_PSIONICS) && affected_by_spell(ch, PSI_DOME)) {
other.c:       if (ch->player.prompt
other.c:        && strcmp("(null)", ch->player.prompt)) {
other.c:          free(ch->last_prompt);
other.c:          ch->last_prompt = NULL;
other.c:    DESTROY(ch->player.prompt);
other.c:        ch->player.prompt = strdup(">");
other.c:        ch->player.prompt = NULL;
other.c:        ch->player.prompt = strdup(prompt + 1);
other.c:    if (!ch->in_room)
other.c:    if (IS_NPC(ch) || !ch->desc)
other.c:        } else if (!IS_SET(ch->in_room->room_flags, RFL_SAFE)
other.c:        } else if (IS_SET(ch->in_room->room_flags, RFL_SAFE)) {
other.c:        if (room_in_city(ch->in_room)) {
other.c:        } else if (ch->in_room->sector_type == SECT_CITY) {
other.c:                !IS_NPC(ch) ? "(" : "", !IS_NPC(ch) ? ch->account : "", !IS_NPC(ch) ? ") " : "",
other.c:                ch->in_room->number);
other.c:            struct time_info_data playing_time = real_time_passed((time(0) - ch->player.time.logon)
other.c:                                                                  + ch->player.time.played, 0);
other.c:                 || (ch->player.dead && !strcmp(ch->player.dead, "rebirth")))
other.c:                && !IS_SET(ch->specials.act, CFL_NO_DEATH)) {
other.c:                if (ch->player.info[1])
other.c:                    free(ch->player.info[1]);
other.c:                ch->player.info[1] = strdup(buf);
other.c:                (ch->in_room->room_flags, RFL_SAFE) {
other.c:            for (tch = ch->in_room->people; tch; tch = tch->next_in_room)
other.c:                if (tch->specials.subduing == ch)
other.c:                tch->specials.subduing = (CHAR_DATA *) 0;
other.c:            REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_SUBDUED);
other.c:        if( IS_SET(ch->quit_flags, QUIT_OOC_REVOKED)) {
other.c:        if( IS_SET(ch->quit_flags, QUIT_OOC) ) {
other.c:        if ( ch->in_room && ch->in_room->zone == RESERVED_Z ) {
other.c:        MUD_SET_BIT(ch->quit_flags, QUIT_OOC);
other.c:        db_escape_string(account, ch->account, sizeof(account));
other.c:         character, account, reason, ch->in_room->number, 
other.c:         ch->desc && ch->desc->player_info ? ch->desc->player_info->name
other.c:        if (!IS_SET(ch->in_room->room_flags, RFL_SAFE) && (GET_GUILD(ch) != GUILD_RANGER)) {
other.c:        } else if (!IS_SET(ch->in_room->room_flags, RFL_SAFE) && GET_GUILD(ch) == GUILD_RANGER) {
other.c:            if (room_in_city(ch->in_room)) {
other.c:            } else if (ch->in_room->sector_type == SECT_SILT) {
other.c:            } else if (ch->in_room->sector_type == SECT_CITY) {
other.c:    REMOVE_BIT(ch->quit_flags, QUIT_OOC);
other.c:             GET_NAME(ch), ch->in_room->number, ch->in_room->name, GET_HIT(ch), GET_STUN(ch),
other.c:             guild[(int) ch->player.guild].name);
other.c:    if (ch->desc) {
other.c:        for (pCl = ch->desc->monitoring; pCl; pCl = pCl_next) {
other.c:        ch->desc->monitoring = NULL;
other.c:        ch->desc->monitoring_all = FALSE;
other.c:        ch->desc->monitor_all_show = 0;
other.c:    sprintf(buf, "%s (%s) has left the world in room #%d (%s).", GET_NAME(ch), ch->desc
other.c:            && ch->desc->player_info ? ch->desc->player_info->name : "(Unknown)",
other.c:            ch->in_room->number, ch->in_room->name);
other.c:    sprintf(buf, "/* %s (%s) has left the world in room #%d (%s). */\n\r", GET_NAME(ch), ch->desc
other.c:            && ch->desc->player_info ? ch->desc->player_info->name : "(Unknown)",
other.c:            ch->in_room->number, ch->in_room->name);
other.c:    if(ch->desc)
other.c:       ch->desc->connected = CON_SLCT;
other.c:    if (ch->in_room)
other.c:            sprintf(buf, "Offense: %d (%d natural)\n\r", (int) (ch->tmpabilities.off),
other.c:                    (int) (ch->abilities.off));
other.c:            sprintf(buf, "Defense: %d (%d natural)\n\r", (int) (ch->tmpabilities.def),
other.c:                    (int) (ch->abilities.def));
other.c:                    ((ch->skills[SKILL_WILLPOWER]) ? ch->skills[SKILL_WILLPOWER]->learned : 0));
other.c:                            ch->skills[skill_weap_rtype[0][w]] ? ch->
other.c:                            ch->skills[skill_weap_rtype[1][w]] ? ch->
other.c:                            ch->skills[skill_weap_rtype[2][w]] ? ch->
other.c:                            ch->skills[skill_weap_rtype[3][w]] ? ch->
other.c:                            ch->skills[skill_weap_rtype[4][w]] ? ch->
other.c:                            ch->skills[skill_weap_rtype[5][w]] ? ch->
other.c:                            ch->skills[skill_weap_rtype[6][w]] ? ch->
other.c:                            ch->skills[skill_weap_rtype[7][w]] ? ch->
other.c:                            ch->skills[skill_weap_rtype[8][w]] ? ch->
other.c:            if ((ch->skills[i] && (skill[i].sk_class == sk_class))
other.c:        if (ch->skills[i] && (skill[i].sk_class == sk_class)) {
other.c:                        if (accent_table[j].skillnum == i && ch->skills[i]->learned >= MIN_ACCENT_LEVEL) {
other.c:                    sprintf(buf, "%3d:%3d", ch->skills[i]->learned, maxval);
other.c:		} else if( ch->skills[i]->learned == raw ) {
other.c:                    sprintf(buf, "%3d    ", ch->skills[i]->learned);
other.c:                    sprintf(buf, "%3d/%3d", ch->skills[i]->learned, raw);
other.c:            if (sk_class == CLASS_MAGICK && ch->skills[i]->rel_lev >= 0
other.c:                && ch->skills[i]->rel_lev < 7) {
other.c:                     toupper(Power[(int) ch->skills[i]->rel_lev][0]), 
other.c:                     Power[(int) ch->skills[i]->rel_lev], 
other.c:	    } else if (!IS_SET(ch->specials.brief, BRIEF_SKILLS) &&
other.c:                time_t nexttime = ch->skills[i]->last_gain + (wt * SECS_PER_REAL_MIN);
other.c:                if( ch->skills[i]->last_gain ) {
other.c:                     (char *) ctime(&ch->skills[i]->last_gain), "",
other.c:    if (ch->desc) {
other.c:        page_string(ch->desc, list, 1);
other.c:    if (ch->desc && ch->desc->original) {       // NPCs only report bugs as staff (or deny)
other.c:        rep_ch = ch->desc->original;
other.c:    rep_ch_account = (rep_ch->account ? rep_ch->account : "");
other.c:        if (IS_NPC(tar_ch) || !tar_ch->account) {
other.c:                     rep_ch_account, ch->in_room->number, arg1, npc_index[tar_ch->nr].vnum,
other.c:                     GET_NAME(ch), ch->account, ch->in_room->number, arg1,
other.c:                     npc_index[tar_ch->nr].vnum, argument);
other.c:                     esc_reporter_account, ch->in_room->number, reptype, esc_reported_text,
other.c:                     npc_index[tar_ch->nr].vnum);
other.c:                    ch->in_room->number, arg1, GET_NAME(tar_ch), tar_ch->account, argument);
other.c:            mysql_real_escape_string(armag_db, esc_reported_account, tar_ch->account,
other.c:                                     MIN(strlen(tar_ch->account), max_name_field_len));
other.c:                    ch->account, ch->in_room->number, arg1, GET_NAME(tar_ch), tar_ch->account,
other.c:                     esc_reporter_account, ch->in_room->number, reptype, esc_reported_text,
other.c:     || (tar_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
other.c:         ch->in_room->number, arg1, obj_index[tar_obj->nr].vnum, argument);
other.c:         rep_ch_account, ch->in_room->number, arg1, obj_index[tar_obj->nr].vnum, argument);
other.c:                 esc_reporter_account, ch->in_room->number, reptype, esc_reported_text,
other.c:                ch->in_room->number, arg1, argument);
other.c:        sprintf(typostr, "[%s]%s (%s)[%d]: %s %s\n\r", reptype, GET_NAME(ch), ch->account,
other.c:                ch->in_room->number, arg1, argument);
other.c:                 esc_reporter_account, ch->in_room->number, reptype, esc_reported_text);
other.c:                if (IS_SET(ch->specials.brief, (1 << (new - 2))))
other.c:            ch->specials.brief = 0;
other.c:            ch->specials.brief = ~0;
other.c:                REMOVE_BIT(ch->specials.brief, BRIEF_EQUIP);
other.c:                REMOVE_BIT(ch->specials.brief, BRIEF_STAFF_ONLY_NAMES);
other.c:            if (IS_SET(ch->specials.brief, flag)) {
other.c:                REMOVE_BIT(ch->specials.brief, flag);
other.c:                MUD_SET_BIT(ch->specials.brief, flag);
other.c:    if (IS_SET(ch->specials.act, CFL_INFOBAR)) {
other.c:        REMOVE_BIT(ch->specials.act, CFL_INFOBAR);
other.c:        MUD_SET_BIT(ch->specials.act, CFL_INFOBAR);
other.c:    if (IS_SET(ch->specials.act, CFL_COMPACT)) {
other.c:        REMOVE_BIT(ch->specials.act, CFL_COMPACT);
other.c:        MUD_SET_BIT(ch->specials.act, CFL_COMPACT);
other.c:            if ((tar_room = ch->in_room->direction[door]->to_room)) {
other.c:                                                                      ch->in_room->number)
other.c:    if (!(temp = get_obj_in_list_vis(ch, buf, ch->carrying))) {
other.c:        if (temp == ch->equipment[EP])
other.c:        else if (temp == ch->equipment[ES])
other.c:    bow = get_obj_in_list_vis(ch, arg1, ch->carrying);
other.c:    bolt = get_obj_in_list_vis(ch, arg2, ch->carrying);
other.c:    bow = get_obj_in_list_vis(ch, arg1, ch->carrying);
other.c:    if (ch && ch->in_room && !ch->in_room->direction[dir])
other.c:    if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_BLADE_BARRIER)) {
other.c:    if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_WIND_WALL)) {
other.c:    if (missile == ch->equipment[EP])
other.c:        obj_to_room(unequip_char(ch, EP), ch->in_room);
other.c:    else if (missile == ch->equipment[ES])
other.c:        obj_to_room(unequip_char(ch, ES), ch->in_room);
other.c:    bow = ch->equipment[ES];
other.c:      bow = ch->equipment[EP];
other.c:      if (!ch->equipment[EP]) { // No arrow!
other.c:      arrow = ch->equipment[EP];
other.c:        } else if (ch->equipment[EP])
other.c:        obj_to_room(arrow, ch->in_room);
other.c:            && (!IS_SET(ch->in_room->room_flags, RFL_INDOORS))) {
other.c:        send_to_room(buf, ch->in_room);
other.c:        if (ch->specials.fighting && ch->specials.fighting == victim)
other.c:	    } else if (ch->equipment[EP])
other.c:     && (!IS_SET(ch->in_room->room_flags, RFL_INDOORS))) {
other.c:    if (!ch->specials.to_process) {
other.c:        if (ch->in_room && victim->in_room && (ch->in_room != victim->in_room)) {
other.c:        offense = number(1, 100) + ch->skills[SKILL_ARCHERY]->learned;
other.c:           if (wn->zone == ch->in_room->zone) {
other.c:           if (ch->in_room != tar_room && wn->zone == tar_room->zone) {
other.c:    if (ch->specials.fighting && ch->specials.fighting == victim)
other.c:        if (ch->in_room != victim->in_room)
other.c:        if (ch->skills[SKILL_ARCHERY]) {
other.c:            dam += ch->skills[SKILL_ARCHERY]->learned / 7;
other.c:            if (number(0, 500) <= ch->skills[SKILL_ARCHERY]->learned)
other.c:        if (ch->in_room != victim->in_room)
other.c:    } else if (ch->equipment[EP])
other.c:            if (!ch->skills[language_table[i].spoken]) {
other.c:            ch->specials.language = i;
other.c:    if ((new_eco = ch->specials.eco - dec) < 0) {
other.c:    ch->specials.eco = new_eco;
other.c:        if (!(scroll = get_obj_in_list_vis(ch, buf, ch->carrying))) {
other.c:            if (is_cloak_open(ch, ch->equipment[WEAR_ABOUT]))
other.c:        skill = MAX(ch->abilities.off, 
other.c:        skill = ch->abilities.off;
other.c:        qroomlogf(QUIET_COMBAT, ch->in_room, "sheath delay is %d", delay);
other.c:        ch->specials.act_wait += delay;
other.c:    if (!ch->specials.to_process && cmd == CMD_STOW) {
other.c:    if (ch->equipment[ETWO] && isname(buf, OSTR(ch->equipment[ETWO], name))) {
other.c:        weapon = ch->equipment[ETWO];
other.c:    } else if (ch->equipment[EP] && isname(buf, OSTR(ch->equipment[EP], name))) {
other.c:        weapon = ch->equipment[EP];
other.c:    } else if (ch->equipment[ES] && isname(buf, OSTR(ch->equipment[ES], name))) {
other.c:        weapon = ch->equipment[ES];
other.c:        weapon = ch->equipment[EP];
other.c:        weapon = ch->equipment[ES];
other.c:        weapon = ch->equipment[ETWO];
other.c:    if ((cmd == CMD_STOW) && (ch->skills[SKILL_SLEIGHT_OF_HAND])) {
other.c:        if (skill_success(ch, NULL, ch->skills[SKILL_SLEIGHT_OF_HAND]->learned))
other.c:        if ((ch->equipment[WEAR_ON_BELT_1]) && (ch->equipment[WEAR_ON_BELT_2])) {
other.c:        if (!ch->equipment[WEAR_BELT]) {
other.c:        if (ch->equipment[WEAR_ON_BELT_1]) {
other.c://      if (ch->equipment[WEAR_BACK])
other.c:        if (ch->equipment[WEAR_ON_BACK]) {
other.c:       for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
other.c:    qroomlogf(QUIET_COMBAT, ch->in_room, "draw delay base: %d", delay);
other.c:    qroomlogf(QUIET_COMBAT, ch->in_room, "agility:         %d", delay);
other.c:        qroomlogf(QUIET_COMBAT, ch->in_room, "obj weight:      %d", delay);
other.c:        if( ch->equipment[WEAR_ON_BELT_1] == obj
other.c:         || ch->equipment[WEAR_ON_BELT_2] == obj) {
other.c:            if (is_cloak_open(ch, ch->equipment[WEAR_ABOUT]))
other.c:            qroomlogf(QUIET_COMBAT, ch->in_room, "worn on belt:    %d", delay);
other.c:        else if( ch->equipment[WEAR_ON_BACK] == obj ) {
other.c:            qroomlogf(QUIET_COMBAT, ch->in_room, "worn on back:    %d", delay);
other.c:        skill = MAX(ch->abilities.off, 
other.c:        skill = ch->abilities.off;
other.c:    qroomlogf(QUIET_COMBAT, ch->in_room, "skill:           %d", delay);
other.c:    qroomlogf(QUIET_COMBAT, ch->in_room, "limits:          %d", delay);
other.c:        qroomlogf(QUIET_COMBAT, ch->in_room, "draw delay is %d", delay);
other.c:        ch->specials.act_wait += delay;
other.c:    if (!ch->specials.to_process && cmd == CMD_READY) {
other.c:    if ((cmd == CMD_READY) && (ch->skills[SKILL_SLEIGHT_OF_HAND])) {
other.c:        if (skill_success(ch, NULL, ch->skills[SKILL_SLEIGHT_OF_HAND]->learned))
other.c:    if (ch->lifting) {
other.c:        sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
other.c:        if (!drop_lifting(ch, ch->lifting))
other.c:    if ((ch->equipment[EP] && ch->equipment[ES]) || (ch->equipment[ETWO])) {
other.c:    if (ch->equipment[WEAR_ON_BELT_1] && isname(buf, OSTR(ch->equipment[WEAR_ON_BELT_1], name))) {
other.c:        weapon = ch->equipment[WEAR_ON_BELT_1];
other.c:    } else if (ch->equipment[WEAR_ON_BELT_2]
other.c:               && isname(buf, OSTR(ch->equipment[WEAR_ON_BELT_2], name))) {
other.c:        weapon = ch->equipment[WEAR_ON_BELT_2];
other.c:    } else if (ch->equipment[WEAR_ON_BACK]
other.c:               && isname(buf, OSTR(ch->equipment[WEAR_ON_BACK], name))) {
other.c:        weapon = ch->equipment[WEAR_ON_BACK];
other.c:     * else if (ch->equipment[WEAR_BACK] &&
other.c:     * isname (buf, OSTR (ch->equipment[WEAR_BACK], name)))
other.c:     * weapon = ch->equipment[WEAR_BACK];
other.c:    if (two_hands && (ch->equipment[EP] || ch->equipment[ES])) {
other.c:    if (ch->equipment[ETWO]) {
other.c:        act("You have enough trouble holding on to $p.", FALSE, ch, ch->equipment[ETWO], 0,
other.c:    else if (ch->equipment[EP] || (!IS_SET(weapon->obj_flags.wear_flags, ITEM_EP)))
other.c:    if (newpos == ES && ch->equipment[ES]) {
other.c:    if (ch->specials.subduing != (struct char_data *) 0) {
other.c:        act("$n releases $N, who immediately moves away.", FALSE, ch, 0, ch->specials.subduing,
other.c:        act("$n releases you, and you immediately move away.", FALSE, ch, 0, ch->specials.subduing,
other.c:        act("You release $N, and $E immediately moves away.", FALSE, ch, 0, ch->specials.subduing,
other.c:        REMOVE_BIT(ch->specials.subduing->specials.affected_by, CHAR_AFF_SUBDUED);
other.c:        ch->specials.subduing = (struct char_data *) 0;
other.c:        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
other.c:	   for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
other.c:    free(ch->specials.gone);
other.c:    ch->specials.gone = 0;
other.c:    if ((ch->specials.gone) && (!*argument)) {
other.c:    free(ch->specials.gone);
other.c:    CREATE(ch->specials.gone, char, strlen(argument) + 1);
other.c:    strcpy(ch->specials.gone, (argument + 1));
other.c:    sprintf(buf, "Ok, you are gone %s.\n\r", ch->specials.gone);
other.c:    sprintf(buf, "$n is gone %s.", ch->specials.gone);
other.c:            if (ch->alias[i].text[0]) {
other.c:                sprintf(buf, "%-15s %s\n\r", ch->alias[i].alias, ch->alias[i].text);
other.c:            if (ch->alias[i].text[0])
other.c:                if (!strcmp(alias_ref, ch->alias[i].alias)) {
other.c:                    strcpy(ch->alias[i].text, "");
other.c:                    strcpy(ch->alias[i].alias, "");
other.c:        if (ch->alias[i].text[0])       /* redefine it..... */
other.c:            if (!strcmp(alias_ref, ch->alias[i].alias)) {
other.c:                strcpy(ch->alias[i].alias, alias_ref);
other.c:                strcpy(ch->alias[i].text, alias_text);
other.c:        if (!stricmp(alias_ref, ch->alias[i].text)) {
other.c:        if (!ch->alias[i].text[0]) {
other.c:            strcpy(ch->alias[i].alias, alias_ref);
other.c:            strcpy(ch->alias[i].text, alias_text);
other.c:    if (!ch->desc || !ch->desc->term)
other.c:    if (!IS_SET(ch->specials.act, CFL_INFOBAR)) {
other.c:        write_to_descriptor(ch->desc->descriptor, VT_HOMECLR);
other.c:        write_to_descriptor(ch->desc->descriptor, buf);
other.c:        setup_infobar(ch->desc);
other.c:        display_infobar(ch->desc);
other.c://  if (!IS_SET (ch->in_room->room_flags, RFL_MAIL_ROOM) && !IS_IMMORTAL (ch))
other.c:    sprintf(buf, "accountmail/%s/%s", ch->desc->player_info->name, name);
other.c:    page_string(ch->desc, all, 0);
other.c:        sprintf(buf, "accountmail/%s/%s", ch->desc->player_info->name, name);
other.c:        sprintf(buf2, "accountmail/%s/%s.new", ch->desc->player_info->name, name);
other.c:        sprintf(buf, "accountmail/%s/%s", ch->desc->player_info->name, name);
other.c:            ch->specials.il = 0;
other.c:        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
other.c:    if (!(obj = get_obj_in_list_vis(ch, buf, ch->carrying))) {
other.c:                        GET_NAME(ch), !IS_NPC(ch) ? "(" : "", !IS_NPC(ch) ? ch->account : "",
other.c:                        !IS_NPC(ch) ? ") " : "", ch->in_room->number);
other.c:                        real_time_passed((time(0) - ch->player.time.logon) + ch->player.time.played,
other.c:                         || (ch->player.dead && !strcmp(ch->player.dead, "rebirth")))
other.c:                        && !IS_SET(ch->specials.act, CFL_NO_DEATH)) {
other.c:                        if (ch->player.info[1])
other.c:                            free(ch->player.info[1]);
other.c:                        ch->player.info[1] = strdup(buf);
other.c:    if (ch->specials.guarding) {
other.c:        if (!ch->specials.guarding->guards) {
other.c:            gamelog("WARNING! (!ch->specials.guarding->guards) in stop_guard!");
other.c:        if (!ch->specials.guarding->guards->guard) {
other.c:            gamelog("WARNING! (!ch->specials.guarding->guards->guard) in stop_guard!");
other.c:    if (ch->specials.guarding) {
other.c:        if (ch != ch->specials.guarding) {
other.c:            if (ch->specials.guarding->guards->guard == ch) {
other.c:                who_guarding = ch->specials.guarding;
other.c:                temp_guard = ch->specials.guarding->guards;
other.c:                ch->specials.guarding->guards = temp_guard->next;
other.c:                ch->specials.guarding = (CHAR_DATA *) 0;
other.c:                for (temp_guard = ch->specials.guarding->guards;
other.c:                    who_guarding = ch->specials.guarding;
other.c:                    ch->specials.guarding = (CHAR_DATA *) 0;
other.c:            if (who_guarding->in_room == ch->in_room) {
other.c:        ch->specials.guarding = (CHAR_DATA *) 0;
other.c:    if (ch->specials.obj_guarding) {
other.c:        if (ch->specials.obj_guarding->guards->guard == ch) {
other.c:            temp_guard = ch->specials.obj_guarding->guards;
other.c:            ch->specials.obj_guarding->guards = temp_guard->next;
other.c:            for (temp_guard = ch->specials.obj_guarding->guards; temp_guard->next->guard != ch;
other.c:        act("You stop guarding $p.", TRUE, ch, ch->specials.obj_guarding, 0, TO_CHAR);
other.c:        act("$n stops guarding $p.", TRUE, ch, ch->specials.obj_guarding, 0, TO_NOTVICT);
other.c:        ch->specials.obj_guarding = (OBJ_DATA *) 0;
other.c:    if (ch->specials.dir_guarding > -1) {
other.c:        if (ch->specials.dir_guarding == DIR_OUT) {
other.c:            sprintf(buf, "You stop guarding the %s exit.\n\r", dirs[ch->specials.dir_guarding]);
other.c:            sprintf(buf, "$n stops guarding the %s exit.\n\r", dirs[ch->specials.dir_guarding]);
other.c:        ch->specials.dir_guarding = -1;
other.c:    if (ch->specials.dir_guarding == DIR_OUT) {
other.c:        ch->specials.dir_guarding = -1;
other.c:    sprintf(buf, "You stop guarding the %s exit.\n\r", dirs[ch->specials.dir_guarding]);
other.c:    sprintf(buf, "$n stops guarding the %s exit.\n\r", dirs[ch->specials.dir_guarding]);
other.c:    ch->specials.dir_guarding = -1;
other.c:    if (ch->specials.obj_guarding->guards->guard == ch) {
other.c:        temp_guard = ch->specials.obj_guarding->guards;
other.c:        ch->specials.obj_guarding->guards = temp_guard->next;
other.c:        for (temp_guard = ch->specials.obj_guarding->guards; temp_guard->next->guard != ch;
other.c:    if ((ch->specials.obj_guarding->in_room)
other.c:        && (ch->specials.obj_guarding->in_room == ch->in_room)) {
other.c:        act("You stop guarding $p.", TRUE, ch, ch->specials.obj_guarding, 0, TO_CHAR);
other.c:        act("$n stops guarding $p.", TRUE, ch, ch->specials.obj_guarding, 0, TO_NOTVICT);
other.c:    ch->specials.obj_guarding = (OBJ_DATA *) 0;
other.c:    if (!ch->specials.guarding) {
other.c:        gamelog("WARNING: stop_ch_guard, ch->specials.guarding is null.");
other.c:    who_guarding = ch->specials.guarding;
other.c:        ch->specials.guarding = (CHAR_DATA *) 0;
other.c:        if (who_guarding->in_room == ch->in_room) {
other.c:    ch->specials.guarding = (CHAR_DATA *) 0;
other.c:    if (ch->specials.guarding) {
other.c:        if (!ch->specials.guarding->guards) {
other.c:            gamelog("WARNING! (!ch->specials.guarding->guards) in stop_guard!");
other.c:        if (!ch->specials.guarding->guards->guard) {
other.c:            gamelog("WARNING! (!ch->specials.guarding->guards->guard) in stop_guard!");
other.c:    if (showFailure && !ch->specials.guarding && !ch->specials.obj_guarding
other.c:        && ch->specials.dir_guarding == -1) {
other.c:    if (ch->specials.guarding)
other.c:    if (ch->specials.obj_guarding)
other.c:    if (ch->specials.dir_guarding > -1)
other.c:    for (temp_guard = ch->guards; temp_guard; temp_guard = another_guard) {
other.c:                && (wagon->obj_flags.value[0] == ch->in_room->number))
other.c:        ch->specials.dir_guarding = DIR_OUT;
other.c:    if (!ch->in_room->direction[exit_to_guard])
other.c:        ch->specials.dir_guarding = exit_to_guard;      /* set the value on the guard */
other.c:        MUD_SET_BIT(ch->in_room->direction[exit_to_guard]->exit_info, EX_GUARDED);
other.c:    ch->specials.obj_guarding = tar_obj;
other.c:    ch->specials.guarding = victim;
other.c:        if ((ch->specials.guarding) && (ch->specials.guarding != ch)) {
other.c:            act("You are guarding $N.", TRUE, ch, 0, ch->specials.guarding, TO_CHAR);
other.c:        } else if (ch->specials.dir_guarding > -1) {
other.c:            cprintf(ch, "You are guarding the %s exit.\n\r", dirs[ch->specials.dir_guarding]);
other.c:        } else if (ch->specials.obj_guarding) {
other.c:            act("You are guarding $p.", TRUE, ch, ch->specials.obj_guarding, 0, TO_CHAR);
other.c:    if (ch->specials.subduing) {
other.c:    if ((guard_obj = get_obj_in_list_vis(ch, arg1, ch->in_room->contents))) {
other.c:            if (!ch->specials.subduing)
other.c:                    MSTR(ch->specials.subduing, short_descr), dirs[dir],
other.c:                    ((GET_SEX(ch->specials.subduing) ==
other.c:                      SEX_MALE) ? "he" : ((GET_SEX(ch->specials.subduing) ==
other.c:                    MSTR(ch->specials.subduing, short_descr),
other.c:                    ((GET_SEX(ch->specials.subduing) ==
other.c:                      SEX_MALE ? "he" : ((GET_SEX(ch->specials.subduing) == SEX_FEMALE) ? "she" :
other.c:                    MSTR(ch->specials.subduing, short_descr), dirs[dir],
other.c:                    (GET_SEX(ch->specials.subduing) ==
other.c:                     SEX_MALE ? "he" : ((GET_SEX(ch->specials.subduing) == SEX_FEMALE) ? "she" :
other.c:    if (!(IS_SET((ch->in_room->direction[dir]->exit_info), EX_GUARDED)))
other.c:    for (guard = ch->in_room->people; guard; guard = guard->next_in_room) {     /* being loop searching room for guard */
other.c: *      REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_GUARDED);
other.c:    for (guard = ch->in_room->people; guard; guard = guard->next_in_room) {
other.c:    if (ch->master == guard)
other.c:        for (guard = ch->in_room->people; guard; guard = guard->next_in_room) {
other.c:    if (room_in_city(ch->in_room) != ct) {
other.c:    if (!IS_IMMORTAL(ch) && room_in_city(ch->in_room) != ct) {
other.c:        ct = room_in_city(ch->in_room);
other.c:    if (ch->skills[SKILL_SKINNING])
other.c:        chance = ch->skills[SKILL_SKINNING]->learned;
other.c:    knife = ch->equipment[EP];
other.c:    if (ch->specials.riding) {
other.c:        act("It will be hard to skin while mounted on $r.", FALSE, ch, 0, ch->specials.riding,
other.c:    if (!(body = get_obj_in_list_vis(ch, arg1, ch->in_room->contents))) {
other.c:            obj_to_room(obj, ch->in_room);
other.c:            obj_to_room(obj, ch->in_room);
other.c:          obj_to_room(obj, ch->in_room);
other.c:          if (ch->skills[SKILL_SKINNING])
other.c:    if (ch->equipment[WEAR_HANDS])
other.c:        sflag_to_obj(ch->equipment[WEAR_HANDS], OST_BLOODY);
other.c:        obj_to_room(tmp, ch->in_room);
other.c:    weapon = ch->equipment[EP];
other.c:        weapon = ch->equipment[ETWO];
other.c:    if (!(body = get_obj_in_list_vis(ch, arg1, ch->in_room->contents))) {
other.c:    if (!ch->equipment[ES]) {
other.c:    obj = ch->equipment[ES];
other.c:    if (!ch->desc)
other.c:    ch->pagelength = atoi(arg);
other.c:    if (ch->pagelength < 0 || ch->pagelength > 100) {
other.c:        ch->pagelength = 0;
other.c:    if (!ch || !ch->in_room)
other.c:    if( ch->temp_description ) {
other.c:        free(ch->temp_description);
other.c:        ch->temp_description = NULL;
other.c:    ch->temp_description = strdup("");
other.c:    string_edit(ch, &ch->temp_description, 320);
other.c:    if (!ch || !ch->in_room)
other.c:    switch (ch->in_room->sector_type) {
other.c:    if (ch->in_room->sector_type != SECT_DESERT) {
other.c:        chalk = ch->equipment[ES];
other.c:                if (!isname("chalk", OSTR(ch->equipment[ES], name))) {
other.c:        sprintf(buf, "%s %s [%s (%s)]", what, argument, ch->name, ch->account);
other.c:    if (ch->in_room->sector_type == SECT_DESERT) {
other.c:    obj_to_room(obj, ch->in_room);
other.c:    if (isname(arg, MSTR(ch, name)) || isname(arg, ch->player.extkwds)) {
other.c:        if( ch->name == NULL ) {
other.c:            ch->name = strdup( npc_default[ch->nr].name );
other.c:        keyword_ptr = &ch->name;
other.c:        if (!ch->player.extkwds)
other.c:            ch->player.extkwds = strdup("");
other.c:        keyword_ptr = &ch->player.extkwds;
other.c:        for (c = ch->desc->player_info->characters; c; c = c->next) {
other.c:            gamelogf("%s (%s) tried to add an old character's name '%s' as a keyword", ch->name,
other.c:                     ch->account, arg);
other.c:         npc_index[ch->nr].vnum, arg);
other.c:        gamelogf("%s (%s) added keyword '%s'", ch->name, ch->account, arg);
parser.c:    if( IS_NPC(ch) && ch->desc && ch->desc->original && IS_IMMORTAL(ch->desc->original) ) {
parser.c:        brain = ch->desc->original;
parser.c:    if (is_in_command_q(ch) && !ch->specials.to_process
parser.c:    if (ch->specials.gone && (cmd_info[cmd].command_pointer != cmd_gone))
parser.c:    if (GET_LEVEL(ch) < OVERLORD && IS_SET(ch->specials.act, CFL_FROZEN)
parser.c:        for (subduer = ch->in_room->people; subduer; subduer = subduer->next_in_room) {
parser.c:            REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_SUBDUED);
parser.c:    if (affected_by_spell(ch, PSI_CONTACT) && !ch->specials.contact)
parser.c:    if (ch->desc && ch->desc->str && !IS_IMMORTAL(ch)
parser.c:        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
parser.c:    if (ch->specials.subduing && (hands_free(ch) < 1) && (GET_RACE(ch) != RACE_MANTIS)) {
parser.c:        if (ch->equipment[ETWO])
parser.c:            obj = ch->equipment[ETWO];
parser.c:        if (ch->equipment[ES])
parser.c:            obj = ch->equipment[ES];
parser.c:        if (ch->equipment[EP])
parser.c:            obj = ch->equipment[EP];
parser.c:            ch->specials.subduing, TO_NOTVICT);
parser.c:            ch->specials.subduing, TO_VICT);
parser.c:        REMOVE_BIT(ch->specials.subduing->specials.affected_by, CHAR_AFF_SUBDUED);
parser.c:        ch->specials.subduing = (CHAR_DATA *) 0;
parser.c:    ch->player.orig_level = -1;
parser.c:        && has_extra_cmd(ch->granted_commands, cmd, cmd_info[cmd].minimum_level, TRUE)
parser.c:        && granted_cmd_level(ch->granted_commands, cmd) != -1) {
parser.c:        ch->player.orig_level = ch->player.level;
parser.c:        ch->player.level = granted_cmd_level(ch->granted_commands, cmd);
parser.c:        ch->player.level = ch->player.orig_level;
parser.c:        if (!stricmp(ch->alias[i].alias, com))
parser.c:    strcpy(buf, ch->alias[i].text);
parser.c:        if (strcmp(arg, ch->alias[i].alias) == 0)
parser.c:            return ch->alias[i].alias;
parser.c:    for( qcmd = ch->queued_commands; qcmd; qcmd = qcmd->next )
parser.c:    for( qcmd = ch->queued_commands; qcmd; qcmd = qcmd->next ) {
parser.c:    for (qcmd = ch->queued_commands; qcmd; qcmd = next_qcmd) {
parser.c:    ch->queued_commands = head;
parser.c:    if( ch->queued_commands ) {
parser.c:	    qcmd->next = ch->queued_commands;
parser.c:            ch->queued_commands = qcmd;
parser.c:            for( last = ch->queued_commands; last->next != NULL; last = last->next);
parser.c:        ch->queued_commands = qcmd;
parser.c:    if( !ch || !ch->queued_commands ) return buf;
parser.c:    qcmd = ch->queued_commands;
parser.c:    ch->queued_commands = qcmd->next;
parser.c:    if (ch->in_room == NULL)
parser.c:    if (ch && !is_cmd_oob_command(ch, com) && ch->specials.act_wait > 0) {
parser.c:    if (ch && ch->desc ) {
parser.c:                ch->in_room ? ch->in_room->number : 0, 
parser.c:                ch->desc && ch->desc->player_info ? ch->desc->player_info->name : "Unknown",
parser.c:    if (ch->specials.act_wait <= 0 && !IS_IMMORTAL(ch)) {
parser.c:        ch->specials.act_wait = 1;
parser.c:    if (execute_room_program(ch->in_room, ch, cmd, arg))
parser.c:        if (ch->equipment[j] != NULL) {
parser.c:            if (execute_obj_program(ch->equipment[j], ch, 0, cmd, arg)) {
parser.c:    for (i = ch->carrying; i; i = next_obj) {
parser.c:    if (!ch->in_room)
parser.c:    for (k = ch->in_room->people; k; k = next_char) {
parser.c:    for (i = ch->in_room->contents; i; i = next_obj) {
parser.c:    struct room_data *r = ch->specials.was_in_room;
parser.c:        r = get_room_num(city[ch->player.start_city].room);
parser.c:                 GET_NAME(ch), ch->account);
parser.c:    PLAYER_INFO *pPInfo = ch->desc->player_info;
parser.c:    if(ch->desc->player_info->tempKarmaGuilds ) {
parser.c:        for (tmp_ch = character_list; tmp_ch; tmp_ch = tmp_ch->next) {
parser.c:                && !strcmp(tmp_ch->player.info[0], d->player_info->email)) {
parser.c:                if (tmp_ch->desc)
parser.c:                    close_socket(tmp_ch->desc);
parser.c:                tmp_ch->specials.timer = 0;
parser.c:                tmp_ch->desc = d;
parser.c:                    for (tmp_ch = character_list; tmp_ch; tmp_ch = tmp_ch->next) {
parser.c:                            && tmp_ch->account && !strcmp(tmp_ch->account, d->player_info->name)) {
parser.c:                            sprintf(buf, "Reconnecting to %s...\n\r", tmp_ch->name);
parser.c:                            menu_interpreter(d, tmp_ch->name);
parser.c:                    tch->name = name;
parser.c:                    gamelogf("menu_change_objective: Unable to open char file" " for '%s'.", tch->name);
parser.c:    MUD_SET_BIT(ch->specials.nosave, NOSAVE_ARREST);
parser.c:            if (guild[(int) ch->player.guild].skill_prev[i] == SPELL_NONE)
parser.c:                init_skill(ch, i, guild[(int) ch->player.guild].skill_percent[i]);
parser.c:            else if (sub_guild[(int) ch->player.sub_guild].skill_prev[i] == SPELL_NONE) {
parser.c:                init_skill(ch, i, sub_guild[(int) ch->player.sub_guild].skill_percent[i]);
parser.c:    if( ch->skills[PSI_CONTACT] ) {
parser.c:       if( ch->skills[PSI_CONTACT]->learned < guild[(int) ch->player.guild].skill_percent[PSI_CONTACT]) {
parser.c:           ch->skills[PSI_CONTACT]->learned = guild[(int) ch->player.guild].skill_percent[PSI_CONTACT];
parser.c:    if (!ch->skills[TOL_ALCOHOL])
parser.c:    if (!ch->skills[TOL_PAIN]) {
parser.c:            && ch->skills[accent_table[i].skillnum]->learned >= MIN_ACCENT_LEVEL) {
parser.c:                ch->specials.accent = accent_table[i].skillnum;
parser.c:            ch->specials.accent = accent;
parser.c:    if (charbios == 0 && ch->background) {
parser.c:        entry->account = strdup(ch->account);
parser.c:        entry->author = strdup(ch->name);
parser.c:        entry->date = ch->player.time.starting_time;
parser.c:        entry->text = strdup(ch->background);
parser.c:        ch->abilities.str = st;
parser.c:        ch->abilities.wis = wi;
parser.c:        ch->abilities.agl = ag;
parser.c:        ch->specials.il = GET_LEVEL(ch);
parser.c:    PLAYER_INFO *pInfo = ch->desc->player_info;
pather.c:    if (!from && from_ch && from_ch->in_room)
pather.c:        from = from_ch->in_room;
pather.c:    if (to_ch && to_ch->in_room)
pather.c:        to = to_ch->in_room;
pc_file_game.c:        if (ch->skills[i] && strlen(skill_name[i])) {
pc_file_game.c:            write_char_field_f("CHAR", ref, name, "%d %d %d %d", ch->skills[i]->learned,
pc_file_game.c:                               ch->skills[i]->rel_lev, ch->skills[i]->taught_flags,
pc_file_game.c:                               (int) ch->skills[i]->last_gain);
pc_file_game.c:    if (!ch->specials.programs)
pc_file_game.c:    for (i = 0; i < ch->specials.programs->count; i++) {
pc_file_game.c:        prog = &ch->specials.programs->specials[i];
pc_file_game.c:    for (obj = ch->carrying; obj; obj = obj->next_content)
pc_file_game.c:        if (ch->equipment[i])
pc_file_game.c:            write_char_obj(ch->equipment[i]);
pc_file_game.c:    if (ch->specials.riding)
pc_file_game.c:        riding = ch->specials.riding;
pc_file_game.c:    for (hitch = ch->followers; hitch; hitch = hitch->next) {
pc_file_game.c:        if (IS_SET(hitch->follower->specials.act, CFL_MOUNT) && ch->in_room
pc_file_game.c:            && hitch->follower->in_room && (ch->in_room == hitch->follower->in_room)
pc_file_game.c:            && riding != hitch->follower) {
pc_file_game.c:            write_char_mnt(hitch->follower, 0);
pc_file_game.c:            write_char_hitched(hitch->follower);
pc_file_game.c:    if (ch->specials.riding) {
pc_file_game.c:        write_char_mnt(ch->specials.riding, 1);
pc_file_game.c:        write_char_hitched(ch->specials.riding);
pc_file_game.c:    if (!ch->account) {
pc_file_game.c:       gamelogf("Unable to save character '%s' without an account on the ch", ch->name);
pc_file_game.c:    db_escape_string(o_name, ch->name, sizeof(o_name));
pc_file_game.c:    db_escape_string(o_account, ch->account, sizeof(o_account));
pc_file_game.c:    db_escape_string(o_sdesc, ch->short_descr, sizeof(o_sdesc));
pc_file_game.c:    db_escape_string(o_desc, ch->description, sizeof(o_desc));
pc_file_game.c:    db_escape_string(o_keywords, ch->player.extkwds, sizeof(o_keywords));
pc_file_game.c:    db_escape_string(o_race, race[(int)ch->player.race].name, sizeof(o_race));
pc_file_game.c:    db_escape_string(o_guild, guild[(int)ch->player.guild].name, sizeof(o_guild));
pc_file_game.c:    db_escape_string(o_subguild, sub_guild[ch->player.sub_guild].name, sizeof(o_subguild));
pc_file_game.c:    if( ch->id ) {
pc_file_game.c:         ch->application_status, ch->in_room ? ch->in_room->number : 1003, ch->player.level,
pc_file_game.c:         ch->id);
pc_file_game.c:             o_name, ch->account, sql);
pc_file_game.c:         ch->application_status, ch->in_room ? ch->in_room->number : 1003, ch->player.level);
pc_file_game.c:             o_name, ch->account, sql);
pc_file_game.c:        ch->id = db_insert_id();
pc_file_game.c:        if (ch->equipment[i])
pc_file_game.c:    for (af = ch->affected; af != NULL; af = af->next)
pc_file_game.c:    write_char_field_f("CHAR", ref, "NAME", "%s", ch->name);
pc_file_game.c:    write_char_field_f("CHAR", ref, "SDESC", "%s", ch->short_descr);
pc_file_game.c:    write_char_field_f("CHAR", ref, "DESC", "%s", ch->description);
pc_file_game.c:    write_char_field_f("CHAR", ref, "TDESC", "%s", ch->temp_description);
pc_file_game.c:    write_char_field_f("CHAR", ref, "KEYWORDS", "%s", ch->player.extkwds);
pc_file_game.c:    write_char_field_f("CHAR", ref, "PREVIOUS CHARACTER", "%s", ch->player.dead);
pc_file_game.c:        if (!ch->player.info[i])
pc_file_game.c:            ch->player.info[i] = strdup("");
pc_file_game.c:        write_char_field_f("CHAR", ref, buf, "%s", ch->player.info[i]);
pc_file_game.c:    write_char_field_f("CHAR", ref, "BACKGROUND", "%s", ch->background);
pc_file_game.c:    write_char_field_f("CHAR", ref, "APPLICATIONSTATUS", "%d", ch->application_status);
pc_file_game.c:    if (ch->player.deny)
pc_file_game.c:        write_char_field_f("CHAR", ref, "DENY", "%s", ch->player.deny);
pc_file_game.c:                       (ch->player.sex ==
pc_file_game.c:                        SEX_MALE) ? "male" : ((ch->player.sex ==
pc_file_game.c:    write_char_field_f("CHAR", ref, "GUILD", "%s", guild[(int) (ch->player.guild)].name);
pc_file_game.c:                       sub_guild[(int) (ch->player.sub_guild)].name);
pc_file_game.c:    write_char_field_f("CHAR", ref, "RACE", "%s", race[(int) ch->player.race].name);
pc_file_game.c:    if ((ch->player.level > 0) && (ch->player.level < 6))
pc_file_game.c:        write_char_field_f("CHAR", ref, "LEVEL", "%s", level_name[(int) ch->player.level]);
pc_file_game.c:    for (pCmd = ch->granted_commands; pCmd; pCmd = pCmd->next, i++) {
pc_file_game.c:    for (pCmd = ch->revoked_commands; pCmd; pCmd = pCmd->next, i++) {
pc_file_game.c:    if ((ch->player.hometown > 0) && (ch->player.hometown < MAX_CITIES))
pc_file_game.c:        write_char_field_f("CHAR", ref, "HOMETOWN", "%s", city[ch->player.hometown].name);
pc_file_game.c:    if ((ch->player.start_city > 0) && (ch->player.start_city < MAX_CITIES))
pc_file_game.c:        write_char_field_f("CHAR", ref, "STARTCITY", "%s", city[ch->player.start_city].name);
pc_file_game.c:        write_char_field_f("CHAR", ref, "STARTCITY", "%s", city[ch->player.hometown].name);
pc_file_game.c:    if (ch->account)
pc_file_game.c:        write_char_field_f("CHAR", ref, "ACCOUNT", "%s", ch->account);
pc_file_game.c:    if ((ch->player.tribe > 0) && (ch->player.tribe < MAX_CLAN))
pc_file_game.c:        write_char_field_f("CHAR", ref, "CLAN", "%s", clan_table[ch->player.tribe].name);
pc_file_game.c:    if (ch->pagelength)
pc_file_game.c:        write_char_field_f("CHAR", ref, "PAGELEN", "%d", ch->pagelength);
pc_file_game.c:    if (ch->clan)
pc_file_game.c:        write_char_clans(ch->clan, ref, 0);
pc_file_game.c:    write_char_field_f("CHAR", ref, "LUCK", "%d", ch->player.luck);
pc_file_game.c:    write_char_field_f("CHAR", ref, "WEIGHT", "%d", ch->player.weight);
pc_file_game.c:    write_char_field_f("CHAR", ref, "HEIGHT", "%d", ch->player.height);
pc_file_game.c:    write_char_field_f("CHAR", ref, "THIRST", "%d", ch->specials.conditions[THIRST]);
pc_file_game.c:    write_char_field_f("CHAR", ref, "FULL", "%d", ch->specials.conditions[FULL]);
pc_file_game.c:    write_char_field_f("CHAR", ref, "DRUNK", "%d", ch->specials.conditions[DRUNK]);
pc_file_game.c:    write_char_field_f("CHAR", ref, "ECO", "%d", ch->specials.eco);
pc_file_game.c:    write_char_field_f("CHAR", ref, "CFLAGS", "%s", str_from_flags(char_flag, ch->specials.act));
pc_file_game.c:    write_char_field_f("CHAR", ref, "QFLAGS", "%s", str_from_flags(quit_flag, ch->quit_flags));
pc_file_game.c:    write_char_field_f("CHAR", ref, "BRIEF", "%s", str_from_flags(brief_flag, ch->specials.brief));
pc_file_game.c:                       str_from_flags(nosave_flag, ch->specials.nosave));
pc_file_game.c:                       str_from_flags(mercy_flag, ch->specials.mercy));
pc_file_game.c:                       str_from_flags(affect_flag, ch->specials.affected_by));
pc_file_game.c:    write_char_field_f("CHAR", ref, "UID", "%d", ch->specials.uid);
pc_file_game.c:    write_char_field_f("CHAR", ref, "GROUP", "%d", ch->specials.group);
pc_file_game.c:    write_char_field_f("CHAR", ref, "POOFIN", "%s", ch->player.poofin);
pc_file_game.c:    write_char_field_f("CHAR", ref, "POOFOUT", "%s", ch->player.poofout);
pc_file_game.c:    write_char_field_f("CHAR", ref, "PROMPT", "%s", ch->player.prompt);
pc_file_game.c:        write_char_field_f("CHAR", ref, buf, "%s %s", ch->alias[i].alias, ch->alias[i].text);
pc_file_game.c:    write_char_field_f("CHAR", ref, "STR", "%d", ch->abilities.str);
pc_file_game.c:    write_char_field_f("CHAR", ref, "END", "%d", ch->abilities.end);
pc_file_game.c:    write_char_field_f("CHAR", ref, "AGL", "%d", ch->abilities.agl);
pc_file_game.c:    write_char_field_f("CHAR", ref, "WIS", "%d", ch->abilities.wis);
pc_file_game.c:    write_char_field_f("CHAR", ref, "MANA", "%d", ch->points.mana);
pc_file_game.c:    write_char_field_f("CHAR", ref, "HITS", "%d", ch->points.hit);
pc_file_game.c:    write_char_field_f("CHAR", ref, "MAX HITS", "%d", ch->points.max_hit);
pc_file_game.c:    write_char_field_f("CHAR", ref, "STUN", "%d", ch->points.stun);
pc_file_game.c:    write_char_field_f("CHAR", ref, "MAX STUN", "%d", ch->points.max_stun);
pc_file_game.c:    write_char_field_f("CHAR", ref, "MOVES", "%d", ch->points.move);
pc_file_game.c:    write_char_field_f("CHAR", ref, "ARMOR", "%d", ch->tmpabilities.armor);
pc_file_game.c:    write_char_field_f("CHAR", ref, "OBSIDIAN", "%d", ch->points.obsidian);
pc_file_game.c:    write_char_field_f("CHAR", ref, "IN BANK", "%d", ch->points.in_bank);
pc_file_game.c:    write_char_field_f("CHAR", ref, "OFFENSE", "%d", ch->tmpabilities.off);
pc_file_game.c:    write_char_field_f("CHAR", ref, "OFFENSE LAST GAIN", "%d", (int) ch->abilities.off_last_gain);
pc_file_game.c:    write_char_field_f("CHAR", ref, "DEFENSE", "%d", ch->tmpabilities.def);
pc_file_game.c:    write_char_field_f("CHAR", ref, "DEFENSE LAST GAIN", "%d", (int) ch->abilities.def_last_gain);
pc_file_game.c:    write_char_field_f("CHAR", ref, "DAMAGE", "%d", ch->tmpabilities.damroll);
pc_file_game.c:    write_char_field_f("CHAR", ref, "INVIS LEVEL", "%d", ch->specials.il);
pc_file_game.c:    write_char_field_f("CHAR", ref, "QUIET LEVEL", "%d", ch->specials.quiet_level);
pc_file_game.c:    if (ch->in_room) {
pc_file_game.c:        write_char_field_f("CHAR", ref, "LOAD ROOM", "%d", ch->in_room->number);
pc_file_game.c:    write_char_field_f("CHAR", ref, "LAST LOGON", "%d", (int) ch->player.time.logon);
pc_file_game.c:    write_char_field_f("CHAR", ref, "STARTING TIME", "%d", (int) ch->player.time.starting_time);
pc_file_game.c:    write_char_field_f("CHAR", ref, "STARTING AGE", "%d", ch->player.time.starting_age);
pc_file_game.c:                       ch->player.time.played + (int) (time(0) - ch->player.time.logon));
pc_file_game.c:    write_char_affects(ref, ch->affected);
pc_file_game.c:    write_char_edescs(ref, ch->ex_description);
pc_file_game.c:    for (af = ch->affected; af != NULL; af = af->next) 
pc_file_game.c:    sprintf(buf, "%s/%s", ACCOUNT_DIR, ch->account);
pc_file_game.c:    ch->affected = NULL;
pc_file_game.c:    ch->ex_description = NULL;
pc_file_game.c:    if (!ch->in_room) {
pc_file_game.c:    char_to_room(mnt, ch->in_room);
pc_file_game.c:        ch->specials.riding = mnt;
pc_file_game.c:     * while (current.ch->followers)
pc_file_game.c:     * extract_char(current.ch->followers->follower);
pc_file_game.c:     * if (ch->specials.riding)
pc_file_game.c:     * extract_char(current.ch->specials.riding); */
pc_file_game.c:            ch->skills[i] = (struct char_skill_data *) malloc(sizeof *ch->skills[i]);
pc_file_game.c:            ch->skills[i]->learned = learned;
pc_file_game.c:            ch->skills[i]->rel_lev = rel_lev;
pc_file_game.c:            ch->skills[i]->taught_flags = taught;
pc_file_game.c:            ch->skills[i]->last_gain = last_gain;
pc_file_game.c:    ch->specials.programs = NULL;
pc_file_game.c:        ch->specials.programs = set_prog(NULL, ch->specials.programs, field);
pc_file_game.c:    ch->tmpabilities = ch->abilities;
pc_file_game.c:    ch->specials.carry_items = 0;
pc_file_game.c:    ch->specials.dir_guarding = -1;
pc_file_game.c:    ch->specials.guarding = (CHAR_DATA *) 0;
pc_file_game.c:    ch->specials.harnessed_to = (OBJ_DATA *) 0;
pc_file_game.c:    ch->specials.obj_guarding = (OBJ_DATA *) 0;
pc_file_game.c:    ch->obj_master = NULL;
pc_file_game.c:    ch->guards = 0;
pc_file_game.c:    ch->jsobj = 0;
pc_file_game.c:     ch->tmpabilities.armor = race[(int)GET_RACE(ch)].natural_armor;
pc_file_game.c:     ch->abilities.armor = race[(int)GET_RACE(ch)].natural_armor;
pc_file_game.c:     ch->tmpabilities.damroll = 0;
pc_file_game.c:     ch->abilities.damroll = 0;
pc_file_game.c:    if (ch->desc) {
pc_file_game.c:                sprintf(ch->desc->path, "%s/immortals/users/%s", cwd, buf);
pc_file_game.c:                strcpy(ch->desc->path, "");
pc_file_game.c:            sprintf(ch->desc->path, "%s/immortals/users/%s", cwd, buf);
pc_file_game.c:            strcpy(ch->desc->path, "");
pc_file_game.c:    ch->long_descr = NULL;
pc_file_game.c:    gain_condition(ch, DRUNK, -mud_hours_passed(ch->player.time.logon, time(0)));
pc_file_game.c:    ch->player.time.logon = time(0);
pc_file_game.c:    ch->in_room = (struct room_data *) 0;
pc_file_game.c:    ch->specials.act_wait = 0;
pc_file_game.c:    ch->name = strdup(name);
pc_file_game.c:    if (ch->desc)
pc_file_game.c:        sprintf(buf, "%s/%s", ACCOUNT_DIR, ch->desc->player_info->name);
pc_file_game.c:        sprintf(buf, "%s/%s", ACCOUNT_DIR, ch->player.info[0]);
pc_file_game.c:    ch->player.luck = read_char_field_num("CHAR", 1, "LUCK");
pc_file_game.c:    free(ch->name);
pc_file_game.c:    read_char_field_f("CHAR", 1, "NAME", "%s", &ch->name);
pc_file_game.c:    read_char_field_f("CHAR", 1, "SDESC", "%s", &ch->short_descr);
pc_file_game.c:    read_char_field_f("CHAR", 1, "DESC", "%s", &ch->description);
pc_file_game.c:    read_char_field_f("CHAR", 1, "TDESC", "%s", &ch->temp_description);
pc_file_game.c:    read_char_field_f("CHAR", 1, "KEYWORDS", "%s", &ch->player.extkwds);
pc_file_game.c:    read_char_field_f("CHAR", 1, "PREVIOUS CHARACTER", "%s", &ch->player.dead);
pc_file_game.c:    read_char_field_f("CHAR", 1, "ACCOUNT", "%s", &ch->account);
pc_file_game.c:    if (ch->player.dead == NULL) {
pc_file_game.c:        ch->player.dead = strdup("born");
pc_file_game.c:        read_char_field_f("CHAR", 1, field, "%s", &ch->player.info[i]);
pc_file_game.c:    ch->pagelength = 0;
pc_file_game.c:    ch->pagelength = read_char_field_num("CHAR", 1, "PAGELEN");
pc_file_game.c:    if (ch->pagelength == 0 && !ch->desc)
pc_file_game.c:        ch->pagelength = 24;
pc_file_game.c:    else if (ch->pagelength == 0 && ch->desc)
pc_file_game.c:        ch->pagelength = ch->desc->pagelength;
pc_file_game.c:    read_char_field_f("CHAR", 1, "BACKGROUND", "%s", &ch->background);
pc_file_game.c:    ch->application_status = APPLICATION_NONE;
pc_file_game.c:    ch->application_status = read_char_field_num("CHAR", 1, "APPLICATIONSTATUS");
pc_file_game.c:    read_char_field_f("CHAR", 1, "DENY", "%s", &ch->player.deny);
pc_file_game.c:    ch->player.sex = read_char_sex("CHAR", 1);
pc_file_game.c:    ch->player.guild = i;
pc_file_game.c:    ch->player.sub_guild = j;
pc_file_game.c:    ch->player.race = read_char_race("CHAR", 1);
pc_file_game.c:    ch->player.level = old_search_block(buf, 0, strlen(buf), level_name, 0) - 1;
pc_file_game.c:        pCmd->next = ch->granted_commands;
pc_file_game.c:        ch->granted_commands = pCmd;
pc_file_game.c:        pCmd->next = ch->revoked_commands;
pc_file_game.c:        ch->revoked_commands = pCmd;
pc_file_game.c:    ch->player.hometown = i;
pc_file_game.c:        ch->player.start_city = i;
pc_file_game.c:        ch->player.hometown = i;
pc_file_game.c:    ch->player.tribe = lookup_clan_by_name(buf);
pc_file_game.c:        if (!ch->clan) {
pc_file_game.c:            pClan->next = ch->clan;
pc_file_game.c:            ch->clan = pClan;
pc_file_game.c:            for (pClan2 = ch->clan; pClan2->next; pClan2 = pClan2->next);
pc_file_game.c:    ch->player.luck = read_char_field_num("CHAR", 1, "LUCK");
pc_file_game.c:    ch->player.weight = read_char_field_num("CHAR", 1, "WEIGHT");
pc_file_game.c:    ch->player.height = read_char_field_num("CHAR", 1, "HEIGHT");
pc_file_game.c:    ch->specials.language = old_search_block(buf, 0, strlen(buf), skill_name, 0) - 1;
pc_file_game.c:        if (language_table[i].spoken == (int) ch->specials.language)
pc_file_game.c:            ch->specials.language = i;
pc_file_game.c:    if (ch->specials.language > MAX_TONGUES || ch->specials.language < 0)
pc_file_game.c:        ch->specials.language = 0;
pc_file_game.c:    ch->specials.accent = old_search_block(buf, 0, strlen(buf), skill_name, 0) - 1;
pc_file_game.c:    if (ch->specials.accent < 0)
pc_file_game.c:        ch->specials.accent = LANG_NO_ACCENT;
pc_file_game.c:    ch->specials.conditions[THIRST] = read_char_field_num("CHAR", 1, "THIRST");
pc_file_game.c:    ch->specials.conditions[FULL] = read_char_field_num("CHAR", 1, "FULL");
pc_file_game.c:    ch->specials.conditions[DRUNK] = read_char_field_num("CHAR", 1, "DRUNK");
pc_file_game.c:    ch->specials.eco = read_char_field_num("CHAR", 1, "ECO");
pc_file_game.c:    ch->specials.act = vector_from_flags(char_flag, buf);
pc_file_game.c:    ch->quit_flags = vector_from_flags(quit_flag, buf);
pc_file_game.c:        ch->specials.brief = vector_from_flags(brief_flag, buf);
pc_file_game.c:        ch->specials.brief = 0;
pc_file_game.c:    if (IS_SET(ch->specials.act, CFL_BRIEF)) {
pc_file_game.c:        MUD_SET_BIT(ch->specials.brief, BRIEF_ROOM);
pc_file_game.c:        REMOVE_BIT(ch->specials.act, CFL_BRIEF);
pc_file_game.c:        ch->specials.nosave = vector_from_flags(nosave_flag, buf);
pc_file_game.c:        ch->specials.nosave = 0;
pc_file_game.c:        ch->specials.mercy = vector_from_flags(mercy_flag, buf);
pc_file_game.c:        char *message = find_ex_description("[MERCY_FLAG]", ch->ex_description, TRUE);
pc_file_game.c:        ch->specials.mercy = 0;
pc_file_game.c:           ch->specials.mercy = 1;
pc_file_game.c:    if (IS_SET(ch->specials.act, CFL_NOSAVE)) {
pc_file_game.c:        MUD_SET_BIT(ch->specials.nosave, NOSAVE_ARREST);
pc_file_game.c:        REMOVE_BIT(ch->specials.act, CFL_NOSAVE);
pc_file_game.c:    if (!IS_TRIBE(ch, ch->player.tribe) && ch->player.tribe) {
pc_file_game.c:        add_clan(ch, ch->player.tribe);
pc_file_game.c:        /* convert the CFL_CLANLEADER flag to CJOB_LEADER for ch->tribe */
pc_file_game.c:        if (IS_SET(ch->specials.act, CFL_CLANLEADER))
pc_file_game.c:            set_clan_flag(ch->clan, ch->player.tribe, CJOB_LEADER);
pc_file_game.c:        ch->specials.affected_by = vector_from_flags(affect_flag, buf);
pc_file_game.c:        ch->specials.affected_by = 0;
pc_file_game.c:    ch->specials.uid = read_char_field_num("CHAR", 1, "UID");
pc_file_game.c:    ch->specials.group = read_char_field_num("CHAR", 1, "GROUP");
pc_file_game.c:    read_char_field_f("CHAR", 1, "POOFIN", "%s", &ch->player.poofin);
pc_file_game.c:    read_char_field_f("CHAR", 1, "POOFOUT", "%s", &ch->player.poofout);
pc_file_game.c:    read_char_field_f("CHAR", 1, "PROMPT", "%s", &ch->player.prompt);
pc_file_game.c:        read_char_field_f("CHAR", 1, field, "%a %a", ch->alias[i].alias, ch->alias[i].text);
pc_file_game.c:    ch->abilities.str = read_char_field_num("CHAR", 1, "STR");
pc_file_game.c:    ch->abilities.end = read_char_field_num("CHAR", 1, "END");
pc_file_game.c:    ch->abilities.agl = read_char_field_num("CHAR", 1, "AGL");
pc_file_game.c:    ch->abilities.wis = read_char_field_num("CHAR", 1, "WIS");
pc_file_game.c:    ch->points.mana = read_char_field_num("CHAR", 1, "MANA");
pc_file_game.c:    ch->points.hit = read_char_field_num("CHAR", 1, "HITS");
pc_file_game.c:    ch->points.max_hit = read_char_field_num("CHAR", 1, "MAX HITS");
pc_file_game.c:    ch->points.stun = read_char_field_num("CHAR", 1, "STUN");
pc_file_game.c:    ch->points.max_stun = read_char_field_num("CHAR", 1, "MAX STUN");
pc_file_game.c:    ch->points.move = read_char_field_num("CHAR", 1, "MOVES");
pc_file_game.c:    ch->points.obsidian = read_char_field_num("CHAR", 1, "OBSIDIAN");
pc_file_game.c:    ch->points.in_bank = read_char_field_num("CHAR", 1, "IN BANK");
pc_file_game.c:    ch->specials.il = read_char_field_num("CHAR", 1, "INVIS LEVEL");
pc_file_game.c:    ch->specials.quiet_level = read_char_field_num("CHAR", 1, "QUIET LEVEL");
pc_file_game.c:    ch->tmpabilities.off = ch->abilities.off = read_char_field_num("CHAR", 1, "OFFENSE");
pc_file_game.c:    ch->tmpabilities.off_last_gain = ch->abilities.off_last_gain = read_char_field_num("CHAR", 1, "OFFENSE LAST GAIN");
pc_file_game.c:    ch->tmpabilities.def = ch->abilities.def = read_char_field_num("CHAR", 1, "DEFENSE");
pc_file_game.c:    ch->tmpabilities.def_last_gain = ch->abilities.def_last_gain = read_char_field_num("CHAR", 1, "DEFENSE LAST GAIN");
pc_file_game.c:    ch->tmpabilities.damroll = ch->abilities.damroll = read_char_field_num("CHAR", 1, "DAMAGE");
pc_file_game.c:    ch->tmpabilities.armor = ch->abilities.armor = read_char_field_num("CHAR", 1, "ARMOR");
pc_file_game.c:    ch->specials.was_in_room = get_room_num(read_char_field_num("CHAR", 1, "LOAD ROOM"));
pc_file_game.c:    ch->player.time.logon = read_char_field_num("CHAR", 1, "LAST LOGON");
pc_file_game.c:    ch->player.time.starting_time = read_char_field_num("CHAR", 1, "STARTING TIME");
pc_file_game.c:    ch->player.time.starting_age = read_char_field_num("CHAR", 1, "STARTING AGE");
pc_file_game.c:    ch->player.time.played = read_char_field_num("CHAR", 1, "PLAYING TIME");
pc_file_game.c:    db_escape_string(esc_name, ch->name, sizeof(esc_name));
pc_file_game.c:    db_escape_string(esc_account, ch->account, sizeof(esc_account));
pc_file_game.c:        ch->id = atoi(row[0]);
pc_file_game.c:        if( ch->short_descr) free(ch->short_descr);
pc_file_game.c:        ch->short_descr = strdup(row[2]);
pc_file_game.c:        if( ch->player.extkwds) free(ch->player.extkwds);
pc_file_game.c:        ch->player.extkwds = strdup(row[3]);
pc_file_game.c:        if( ch->description) free(ch->description);
pc_file_game.c:        ch->description = strdup(row[4]);
pc_file_game.c:        ch->player.race = i;
pc_file_game.c:        ch->player.guild = i;
pc_file_game.c:        ch->player.sub_guild = i;
pc_file_game.c:        ch->application_status = atoi(row[8]);
pc_file_game.c:        ch->specials.was_in_room = get_room_num(atoi(row[9]));
pc_file_game.c:        //ch->player.time.logon = atol(row[10]);
pc_file_game.c:        ch->player.level = atoi(row[11]);
pc_file_game.c:        ch->player.level_id = atoi(row[12]);
pc_file_game.c:    if (ch->desc)
pc_file_game.c:        sprintf(buf, "%s/%s", ACCOUNT_DIR, ch->desc->player_info->name);
pc_file_game.c:        sprintf(buf, "%s/%s", ACCOUNT_DIR, ch->account);
pc_file_game.c:    if (!ch->name || !*ch->name) {
pc_file_game.c:    if (!ch->desc)
pc_file_game.c:    else if (!ch->desc->player_info)
pc_file_game.c:    else if (!ch->desc->player_info->name)
pc_file_game.c:    sprintf(buf, "%s/%s", ACCOUNT_DIR, ch->desc->player_info->name);
pc_file_game.c:    if (!ch->name || !*ch->name) {
pc_file_game.c:    if (!ch->desc)
pc_file_game.c:    else if (!ch->desc->player_info)
pc_file_game.c:    else if (!ch->desc->player_info->name)
pc_file_game.c:    sprintf(buf, "%s/%s", ACCOUNT_DIR, ch->desc->player_info->name);
pc_file_raw.c:    if (!(ch->name) || !strlen(ch->name)) {
pc_file_raw.c:                "open_char_file: tried to open char '%s' before closing %s first.", ch->name,
pc_file_raw.c:    current.name = strdup(ch->name);
pc_file_raw.c:    first_name(current.ch->name, buf);
pc_file_raw.c:    first_name(current.ch->name, buf);
playable.c:    if ((obj = ch->equipment[ES]) == NULL) {
playable.c:        for (obj = ch->carrying; obj; obj = obj->next_content) {
playable.c:        if ((table = get_obj_in_list_vis(ch, arg2, ch->in_room->contents))
playable.c:        if (obj == ch->equipment[ES])
playable.c:            obj_to_room(obj, ch->in_room);
playable.c:        if (obj == ch->equipment[ES])
playable.c:            obj_to_room(obj, ch->in_room);
playable.c:        if (obj == ch->equipment[ES])
playable.c:            obj_to_room(obj, ch->in_room);
playable.c:        for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
plyr_list.c:    if (ch->on_obj) {
plyr_list.c:        if (obj == ch->on_obj)
plyr_list.c:            remove_occupant(ch->on_obj, ch);
plyr_list.c:    ch->on_obj = obj;
plyr_list.c:        ch->on_obj = NULL;
plyr_list.c:        ch->on_obj = NULL;
plyr_list.c:    ch->on_obj = NULL;
plyr_list.c:    ch->lifting = obj;
plyr_list.c:                pPl->ch->lifting = 0;
plyr_list.c:    ch->lifting = NULL;
psionics.c:    if (!ch->skills[PSI_HEAR])
psionics.c:    skill_level = (has_skill(ch, sk) ? ch->skills[sk]->learned : 1);
psionics.c:    if (ch->specials.contact) {
psionics.c:        CHAR_DATA *temp = ch->specials.contact;
psionics.c:            || !is_on_same_plane(temp->in_room, ch->in_room)
psionics.c:    if (ch->in_room && IS_SET(ch->in_room->room_flags, RFL_NO_PSIONICS)) {
psionics.c:        if (ch->desc && ch->desc->original && has_skill(ch->desc->original, PSI_SHADOW_WALK)) {
psionics.c:            generic_damage(ch->desc->original, 0, 0, 0, psi_drain(ch->desc->original, PSI_SHADOW_WALK));
psionics.c:            if (knocked_out(ch->desc->original)) {
psionics.c:        ((ch->skills[SKILL_WILLPOWER] ? ch->skills[SKILL_WILLPOWER]->learned : 1) +
psionics.c:         (ch->skills[sk] ? ch->skills[sk]->learned : 1)) / 2;
psionics.c:     * The base duration is here as a catch-all to ensure that any affect
psionics.c:        af.duration = MAX(af.duration, ch->skills[sk]->learned * wis_app[GET_WIS(ch)].learn / 100);
psionics.c:        if (ch->in_room == psi->in_room)
psionics.c:        if (ch->in_room == psi->in_room)
psionics.c:            && is_on_same_plane(d->character->in_room, ch->in_room)
psionics.c:            if (ch->skills[i] && (skill[i].sk_class == CLASS_PSIONICS)
psionics.c:      tmp_obj = get_obj_in_list_vis(ch, arg1, ch->carrying);
psionics.c:        if (ch->skills[i] && (skill[i].sk_class == CLASS_PSIONICS)) {
psionics.c:            if (ch->specials.contact && !affected_by_spell(ch, PSI_CONCEAL)) {
psionics.c:                if (has_skill(ch->specials.contact, PSI_TRACE)) {
psionics.c:                    if (psi_skill_success(ch->specials.contact, 0, PSI_TRACE, 0)) {
psionics.c:                        cprintf(ch->specials.contact, "You sense %s withdraw from your mind.\n\r",
psionics.c:                        cprintf(ch->specials.contact,
psionics.c:                        gain_skill(ch->specials.contact, PSI_TRACE, 1);
psionics.c:                    cprintf(ch->specials.contact,
psionics.c:    ch->specials.contact = NULL;
psionics.c:                    for (tar_ch = czCh->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
psionics.c:                            if (IS_SET(tar_ch->specials.act, CFL_UNDEAD))
psionics.c:                                if (tar_ch->master == czCh)
psionics.c:                for (tar_ch = czCh->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
psionics.c:                        if (IS_SET(tar_ch->specials.act, CFL_UNDEAD))
psionics.c:                            if (tar_ch->master == czCh)
psionics.c:    for (tmp_ch = tCh->in_room->people; tmp_ch; tmp_ch = tmp_ch->next)
rcreation.c:    if (!ch->desc)
rcreation.c:    rm = ch->in_room;
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    free(ch->in_room->name);
rcreation.c:    ch->in_room->name = strdup(argument);
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    if (zone != ch->in_room->zone)
rcreation.c:        ch->in_room->bdesc_index = index;
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    if (ch->in_room->description && strlen(ch->in_room->description) > 0) {
rcreation.c:        string_append(ch, &ch->in_room->description, MAX_DESC);
rcreation.c:        string_edit(ch, &ch->in_room->description, MAX_DESC);
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    for (tmp = ch->in_room->ex_description; tmp; tmp = tmp->next) {
rcreation.c:        newdesc->next = ch->in_room->ex_description;
rcreation.c:        ch->in_room->ex_description = newdesc;
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    if (!rem_room_extra_desc_value(ch->in_room, argument)) {
rcreation.c:    cha_rm = ch->in_room;
rcreation.c:    if (ch->in_room->direction[dir]) {
rcreation.c:        free(ch->in_room->direction[dir]->general_description);
rcreation.c:        free(ch->in_room->direction[dir]->keyword);
rcreation.c:        if (ch->in_room->direction[dir]->to_room->direction[rev_dir[dir]]) {
rcreation.c:            free(ch->in_room->direction[dir]->to_room->direction[rev_dir[dir]]->general_description);
rcreation.c:            free(ch->in_room->direction[dir]->to_room->direction[rev_dir[dir]]->keyword);
rcreation.c:            free(ch->in_room->direction[dir]->to_room->direction[rev_dir[dir]]);
rcreation.c:            ch->in_room->direction[dir]->to_room->direction[rev_dir[dir]] = 0;
rcreation.c:        free(ch->in_room->direction[dir]);
rcreation.c:        ch->in_room->direction[dir] = 0;
rcreation.c:    cha_rm = ch->in_room;
rcreation.c:        old_rm = ch->in_room->direction[dir]->to_room;
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    cha_rm = ch->in_room;
rcreation.c:    if (!ch->in_room->direction[dir]) {
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    cha_rm = ch->in_room;
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    if (!ch->in_room->direction[dir]) {
rcreation.c:    if (ch->in_room->direction[dir]->general_description
rcreation.c:        && strlen(ch->in_room->direction[dir]->general_description) > 0) {
rcreation.c:        string_append(ch, &ch->in_room->direction[dir]->general_description, MAX_DESC);
rcreation.c:        string_edit(ch, &ch->in_room->direction[dir]->general_description, MAX_DESC);
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    ch->in_room->sector_type = room_sector[num].val;
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    ch->in_room->city = num;
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    if (IS_SET(ch->in_room->room_flags, flags)) {
rcreation.c:        REMOVE_BIT(ch->in_room->room_flags, flags);
rcreation.c:        MUD_SET_BIT(ch->in_room->room_flags, flags);
rcreation.c:    if (!ch->in_room->direction[dir]) {
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    if (IS_SET(ch->in_room->direction[dir]->exit_info, flags)) {
rcreation.c:        REMOVE_BIT(ch->in_room->direction[dir]->exit_info, flags);
rcreation.c:        MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, flags);
rcreation.c:    if (!ch->in_room->direction[dir]) {
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_ISDOOR);
rcreation.c:    MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_RSCLOSED);
rcreation.c:    MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_RSLOCKED);
rcreation.c:    ch->in_room->direction[dir]->keyword = strdup(buf2);
rcreation.c:    if (!ch->in_room->direction[dir]) {
rcreation.c:        ch->in_room->direction[dir]->key = atoi(buf2);
rcreation.c:        ch->in_room->direction[dir]->key = -1;
rcreation.c:    bool had_pulse = has_special_on_cmd(ch->in_room->specials, NULL, CMD_PULSE);
rcreation.c:    ch->in_room->specials = set_prog(IS_IMMORTAL(ch) ? ch : 0, ch->in_room->specials, args);
rcreation.c:    if (!had_pulse && has_special_on_cmd(ch->in_room->specials, NULL, CMD_PULSE))
rcreation.c:        new_event(EVNT_ROOM_PULSE, PULSE_ROOM, 0, 0, 0, ch->in_room, 0);
rcreation.c:    if (set_room_to_watch_room(watched_room, ch->in_room, args, WATCH_VIEW)) {
rcreation.c:    if (set_room_to_watch_room(watched_room, ch->in_room, args, WATCH_LISTEN)) {
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:    ch->in_room->specials = unset_prog(ch, ch->in_room->specials, args);
rcreation.c:    if (set_room_not_watching_room(watched_room, ch->in_room, WATCH_VIEW)) {
rcreation.c:    if (set_room_not_watching_room(watched_room, ch->in_room, WATCH_LISTEN)) {
rcreation.c:    if (!has_privs_in_zone(ch, ch->in_room->zone, MODE_MODIFY)) {
rcreation.c:        target = ch->in_room;
rcreation.c:    if ((*buf2 && (atoi(buf1) == atoi(buf2))) || (!*buf2 && (atoi(buf1) == ch->in_room->number))) {
rcreation.c:    if (!ch->desc)
rcreation.c:        zone = ch->in_room->zone;
rcreation.c:    write_to_descriptor(ch->desc->descriptor, "Room save in progress...\n\r");
rcreation.c:    write_to_descriptor(ch->desc->descriptor, "Room save completed.\n\r");
rcreation.c:        zone = ch->in_room->zone;
rcreation.c:            next_ch = tch->next_in_room;
rcreation.c:        zone = ch->in_room->zone;
rcreation.c:    zone = ch->in_room->zone;
rcreation.c:    sprintf(buf, "Clearing room %d", ch->in_room->number);
rcreation.c:    rm = ch->in_room;
rcreation.c:        next_ch = tch->next_in_room;
rcreation.c:        if (!has_privs_in_zone(ch, (zone = ch->in_room->zone), MODE_STR_EDIT)
rcreation.c:    if (!ch->desc)
rcreation.c:    write_to_descriptor(ch->desc->descriptor, "World save in progress...\n\r");
rcreation.c:    write_to_descriptor(ch->desc->descriptor, "World save completed.\n\r");
rcreation.c:        zone = ch->in_room->zone;
rcreation.c:    write_to_descriptor(ch->desc->descriptor, "Background save in progress . . .\n\r");
rcreation.c:    write_to_descriptor(ch->desc->descriptor, "Background save done.\n\r");
rcreation.c:        room_num = ch->in_room->number;
rcreation.c:    if (IS_SET(ch->specials.quiet_level, QUIET_ZONE)) {
rcreation.c:        room_num = ch->in_room->number;
skills.c:                ct = room_in_city(ch->in_room);
skills.c:                 && IS_SET(ch->specials.act, city[ct].c_flag)) {
skills.c:  if ((tool = ch->equipment[EP])) {
skills.c:  if ((tool = ch->equipment[ES])) {
skills.c:    if (!ch->skills[SKILL_BANDAGE]) {
skills.c:        ch->specials.act_wait = 0;
skills.c:        ch->specials.act_wait = 0;
skills.c:        && (ch->skills[SKILL_BANDAGE]->learned >= 50)
skills.c:        && (skill_success(ch, 0, ch->skills[SKILL_BANDAGE]->learned))) {
skills.c:        && (ch->skills[SKILL_BANDAGE]->learned >= 50)
skills.c:        && (skill_success(ch, 0, ch->skills[SKILL_BANDAGE]->learned))) {
skills.c:    if ((GET_HIT(tar_ch) < ((GET_MAX_HIT(tar_ch) / 2) - ch->skills[SKILL_BANDAGE]->learned))
skills.c:    if (skill_success(ch, 0, ch->skills[SKILL_BANDAGE]->learned)) {
skills.c:            heal = number(tool->obj_flags.value[1], ch->skills[SKILL_BANDAGE]->learned / 3);
skills.c:    chance = (ch->skills[SKILL_BACKSTAB] ? ch->skills[SKILL_BACKSTAB]->learned : 1);
skills.c:          && !tar_ch->specials.fighting
skills.c:      && !tar_ch->specials.fighting
skills.c:    if (ch->skills[SKILL_BACKSTAB])
skills.c:        dam *= (2 + (ch->skills[SKILL_BACKSTAB]->learned / 7));
skills.c:    if (ch->specials.riding) {
skills.c:    if (ch->specials.fighting) {
skills.c:    tmp1 = ch->equipment[EP];
skills.c:    tmp2 = ch->equipment[ES];
skills.c:    tmp3 = ch->equipment[ETWO];
skills.c:   if ( !skill_success(ch, tar_ch, ch->skills[SKILL_BACKSTAB] ?
skills.c:   ch->skills[SKILL_BACKSTAB]->learned : 0) )
skills.c:    if (ch->skills[SKILL_SCAN])
skills.c:        af.duration = (ch->skills[SKILL_SCAN]->learned / 10) + 1;
skills.c:    message = find_ex_description("[SEARCH_MESSAGE]", ch->in_room->ex_description, TRUE);
skills.c:                 ch->skills[SKILL_SEARCH] ? ch->skills[SKILL_SEARCH]->learned : number(1, 5))) {
skills.c:    artifact_cache = find_artifact_cache(ch->in_room);
skills.c:		ch->skills[SKILL_SEARCH] ? ch->skills[SKILL_SEARCH]->learned : number(1, 5))) {
skills.c:	    qgamelogf(QUIET_DEBUG, "skill_search: %s discovered an artifact cache in room %d.\n\r", MSTR(ch, name), ch->in_room->number);
skills.c:    if (!ch->specials.to_process) {
skills.c:    if (!ch->specials.to_process) {
skills.c:    if ((tool1 = ch->equipment[EP]) && wagon_tool_ok(tool1)) {
skills.c:    if ((tool2 = ch->equipment[ES]) && wagon_tool_ok(tool2)) {
skills.c:    for (counter = 0, person = ch->in_room->people; person; person = next_guy) {
skills.c:        ch->specials.to_process = FALSE;
skills.c:    ch->specials.to_process = FALSE;
skills.c:    if ((broke_item = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
skills.c:    if ((repair_material = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
skills.c:    modifiers = get_room_skill_bonus(ch->in_room, SKILL_ARMOR_REPAIR);
skills.c:  //    modifiers = get_room_skill_bonus(ch->in_room, SKILL_WEAPON_REPAIR);
skills.c:  if (!ch->specials.to_process) {
skills.c:    if (!(tar_obj = get_obj_in_list_vis(ch, obj_name, ch->carrying))) {
skills.c:    sprintf(cost_edesc_name, "[%s(%s)_PERCEIVED_COST]", ch->name, ch->account);
skills.c:    sprintf(weight_edesc_name, "[%s(%s)_PERCEIVED_WEIGHT]", ch->name, ch->account);
skills.c:        if (ch->skills[SKILL_VALUE]) {
skills.c:            skill = ch->skills[SKILL_VALUE]->learned;
skills.c:    if (!showMaker || !(ch->skills[SKILL_VALUE]))
skills.c:    if (ch->skills[SKILL_VALUE]->learned > 5) {
skills.c:    if (ch->skills[SKILL_VALUE]->learned >= 41) {
skills.c:    if (ch->skills[SKILL_VALUE]->learned > 60) {
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_NOTVICT);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_VICT);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_CHAR);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_NOTVICT);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_VICT);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_CHAR);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_NOTVICT);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_VICT);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_CHAR);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_NOTVICT);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_VICT);
skills.c:    act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_CHAR);
skills.c:      if (!((dart = ch->equipment[EP]) || (dart = ch->equipment[ES]))
skills.c:      if (dart == ch->equipment[ES]
skills.c:                if ((dart == ch->equipment[EP]))
skills.c:                if ((dart == ch->equipment[ES]))
skills.c:            offense = number(1, 50) + ch->skills[SKILL_THROW]->learned;
skills.c:               if (wn->zone == ch->in_room->zone) {
skills.c:               if (ch->in_room != tar_room && wn->zone == tar_room->zone) {
skills.c:        if (ch->specials.fighting && ch->specials.fighting == victim)
skills.c:            if ((dart == ch->equipment[EP]))
skills.c:            if ((dart == ch->equipment[ES]))
skills.c:             && max_cond - 1.5 * 10 < ch->skills[SKILL_THROW]->learned) {
skills.c:            if (ch->skills[SKILL_THROW])
skills.c:                if (offense < (ch->skills[SKILL_THROW]->learned))
skills.c:        if ((dart = ch->equipment[EP]))
skills.c:    if (!(ch->specials.subduing == victim)) {
skills.c:                        && wagon->obj_flags.value[0] == ch->in_room->number)
skills.c:                    ch->specials.subduing = (CHAR_DATA *) 0;
skills.c:                    was_in = ch->in_room;
skills.c:            ch->specials.subduing = (CHAR_DATA *) 0;
skills.c:                was_in = ch->in_room;
skills.c:    if (!ch->in_room->direction[n]) {
skills.c:    tar_room = ch->in_room->direction[n]->to_room;
skills.c:    if ((IS_SET(ch->in_room->direction[n]->to_room->room_flags, RFL_NO_MOUNT))
skills.c:        was_in = ch->in_room;
skills.c:        act(buf, FALSE, ch->specials.subduing, 0, 0, TO_ROOM);
skills.c:        REMOVE_BIT(ch->specials.subduing->specials.affected_by, CHAR_AFF_SUBDUED);
skills.c:        ch->specials.subduing = (CHAR_DATA *) 0;
skills.c:        was_in = ch->in_room;
skills.c:        act(buf, FALSE, ch->specials.subduing, 0, 0, TO_ROOM);
skills.c:        REMOVE_BIT(ch->specials.subduing->specials.affected_by, CHAR_AFF_SUBDUED);
skills.c:        ch->specials.subduing = (CHAR_DATA *) 0;
skills.c:        REMOVE_BIT(ch->specials.subduing->specials.affected_by, CHAR_AFF_SUBDUED);
skills.c:        ch->specials.subduing = (CHAR_DATA *) 0;
skills.c:        act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_NOTVICT);
skills.c:        act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_VICT);
skills.c:        act(tmp, FALSE, ch, 0, ch->specials.subduing, TO_CHAR);
skills.c:        was_in = ch->in_room;
skills.c:        act(buf, FALSE, ch->specials.subduing, 0, 0, TO_ROOM);
skills.c:        REMOVE_BIT(ch->specials.subduing->specials.affected_by, CHAR_AFF_SUBDUED);
skills.c:        ch->specials.subduing = (CHAR_DATA *) 0;
skills.c:    if (!ch->specials.subduing) {
skills.c:        act("$n releases $N, who immediately moves away.", FALSE, ch, 0, ch->specials.subduing,
skills.c:        act("$n releases you, and you immediately move away.", FALSE, ch, 0, ch->specials.subduing,
skills.c:        act("You release $N, and $E immediately moves away.", FALSE, ch, 0, ch->specials.subduing,
skills.c:        REMOVE_BIT(ch->specials.subduing->specials.affected_by, CHAR_AFF_SUBDUED);
skills.c:        ch->specials.subduing = (CHAR_DATA *) 0;
skills.c:    if (victim != ch->specials.subduing) {
skills.c:    for (person = ch->in_room->people; person; person = person->next_in_room) {
skills.c:    ch->specials.subduing = (CHAR_DATA *) 0;
skills.c:    if (ch->specials.subduing) {
skills.c:        act("You already have $N subdued.", FALSE, ch, 0, ch->specials.subduing, TO_CHAR);
skills.c:    if (ch->skills[SKILL_SUBDUE]) {
skills.c:        learned += (ch->skills[SKILL_SUBDUE]->learned / 2);
skills.c:    if (ch->specials.riding) {
skills.c:        act("That would be pretty difficult while riding $r.", FALSE, ch, 0, ch->specials.riding,
skills.c:    if (ch->lifting) {
skills.c:        sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
skills.c:        if (!drop_lifting(ch, ch->lifting))
skills.c:    for (tch = ch->in_room->people; tch; tch = tch->next_in_room)
skills.c:        if (tch->specials.subduing == tar_ch)
skills.c:    if ((ch->specials.fighting) || (tar_ch->specials.fighting)) {
skills.c:        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_INVISIBLE);
skills.c:    if (ch->equipment[ES]) {
skills.c:        obj = ch->equipment[ES];
skills.c:        obj_to_room(unequip_char(ch, ES), ch->in_room);
skills.c:        drop_light(obj, ch->in_room);
skills.c:    if (ch->equipment[EP]) {
skills.c:        obj = ch->equipment[EP];
skills.c:        obj_to_room(unequip_char(ch, EP), ch->in_room);
skills.c:        drop_light(obj, ch->in_room);
skills.c:    if (ch->equipment[ETWO]) {
skills.c:        obj = ch->equipment[ETWO];
skills.c:        obj_to_room(unequip_char(ch, ETWO), ch->in_room);
skills.c:            ch->in_room->light--;
skills.c:    ct = room_in_city(ch->in_room);
skills.c:        || IS_SET(tar_ch->specials.nosave, NOSAVE_SUBDUE)
skills.c:        || (ct && IS_TRIBE(ch, city[ct].tribe) && IS_SET(tar_ch->specials.nosave, NOSAVE_ARREST))
skills.c:                if (!ch->in_room->direction[dir])
skills.c:                room = ch->in_room;
skills.c:                       && IS_SET(tar_ch->specials.nosave, NOSAVE_ARREST))
skills.c:                   || IS_SET(tar_ch->specials.nosave, NOSAVE_SUBDUE)) {
skills.c:          REMOVE_BIT(tar_ch->specials.act, CHAR_AFF_CHARM);
skills.c:        if (ch->on_obj)
skills.c:            remove_occupant(ch->on_obj, ch);
skills.c:        if (tar_ch->on_obj)
skills.c:            remove_occupant(tar_ch->on_obj, tar_ch);
skills.c:        if (tar_ch->specials.riding)
skills.c:            tar_ch->specials.riding = NULL;
skills.c:        if (IS_SET(tar_ch->specials.affected_by, CHAR_AFF_HIDE))
skills.c:            REMOVE_BIT(tar_ch->specials.affected_by, CHAR_AFF_HIDE);
skills.c:        ch->specials.subduing = tar_ch;
skills.c:        MUD_SET_BIT(tar_ch->specials.affected_by, CHAR_AFF_SUBDUED);
skills.c:        if (!IS_SET(tar_ch->specials.nosave, NOSAVE_SUBDUE)
skills.c:                 && IS_SET(tar_ch->specials.nosave, NOSAVE_ARREST)))
skills.c:            && (!tar_ch->desc))
skills.c:        && !IS_SET(tar_ch->specials.nosave, NOSAVE_SUBDUE)
skills.c:        && !(ct && IS_TRIBE(ch, city[ct].tribe) && IS_SET(tar_ch->specials.nosave, NOSAVE_ARREST)))
skills.c:        ch->specials.act_wait = 0;
skills.c:    if (ch->specials.riding) {
skills.c:    if (tar_ch->specials.riding) {
skills.c:    if (ch->specials.fighting && tar_ch == ch->specials.fighting)
skills.c:    if (ch->in_room != tar_ch->in_room) {
skills.c:    if (ch->skills[SKILL_BASH] || is_paralyzed(tar_ch)) {
skills.c:        chance = has_skill(ch, SKILL_BASH) ? ch->skills[SKILL_BASH]->learned : 0;
skills.c:        if (ch->equipment[ETWO]
skills.c:            && (ch->equipment[ETWO]->obj_flags.type == ITEM_ARMOR))
skills.c:        else if (ch->equipment[EP]
skills.c:            && (ch->equipment[EP]->obj_flags.type == ITEM_ARMOR))
skills.c:        else if (ch->equipment[ES]
skills.c:                 && (ch->equipment[ES]->obj_flags.type == ITEM_ARMOR))
skills.c:            dodge = number(1, tar_ch->skills[SKILL_BASH]->learned);
skills.c:    mount = ch->specials.riding;
skills.c:    if (tar_ch->specials.riding) {
skills.c:    if ((ch->specials.fighting && tar_ch == ch->specials.fighting)
skills.c:     || (tar_ch->specials.fighting && tar_ch->specials.fighting == ch)) {
skills.c:    if (ch->in_room != tar_ch->in_room) {
skills.c:    if (ch->skills[SKILL_CHARGE]) {
skills.c:        chance = ch->skills[SKILL_CHARGE]->learned;
skills.c:        if (tar_ch->skills[SKILL_CHARGE]) {
skills.c:            dodge = number(1, tar_ch->skills[SKILL_CHARGE]->learned);
skills.c:                ch->specials.riding = (CHAR_DATA *) 0;
skills.c:             * ch->skills[SKILL_CHARGE]->learned / 100;
skills.c:    if (ch->specials.riding) {
skills.c:            act("$n loses $s balance and falls off of you.", FALSE, ch, 0, ch->specials.riding,
skills.c:            ch->specials.riding = (CHAR_DATA *) 0;
skills.c:    mount = ch->specials.riding;
skills.c:    if (tar_ch->specials.riding) {
skills.c:    if (ch->specials.fighting && tar_ch != ch->specials.fighting) {
skills.c:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
skills.c:       if( rch != tar_ch && rch->specials.fighting == tar_ch ) {
skills.c:    if (tar_ch->specials.fighting != ch && (!has_skill(ch, SKILL_TRAMPLE) || num_fighting * 20 > ch->skills[SKILL_TRAMPLE]->learned)) {
skills.c:    if (ch->in_room != tar_ch->in_room) {
skills.c:    if (ch->skills[SKILL_TRAMPLE]) {
skills.c:        chance = ch->skills[SKILL_TRAMPLE]->learned;
skills.c:        if (tar_ch->skills[SKILL_TRAMPLE] 
skills.c:            dodge = number(1, tar_ch->skills[SKILL_TRAMPLE]->learned);
skills.c:                ch->specials.riding = (CHAR_DATA *) 0;
skills.c:            dam = (dam * ch->skills[SKILL_TRAMPLE]->learned / 100);
skills.c:    int skill = has_skill(ch, SKILL_RESCUE) ? ch->skills[SKILL_RESCUE]->learned : 0;
skills.c:    if (ch->specials.fighting == tar_ch || ch->specials.alt_fighting == tar_ch) {
skills.c:        for (tmp_ch = ch->in_room->people;
skills.c:             tmp_ch && tmp_ch->specials.fighting != tar_ch
skills.c:             && tmp_ch->specials.alt_fighting != tar_ch; tmp_ch = tmp_ch->next_in_room);
skills.c:        if (tmp_ch->specials.fighting != tar_ch && tmp_ch->specials.alt_fighting != tar_ch) {
skills.c:    if ((tar_ch->in_room) != (ch->in_room)) {
skills.c:    if (ch->specials.fighting && tar_ch == ch->specials.fighting)
skills.c:    if (ch->specials.riding) {
skills.c:    if (tar_ch->specials.riding) {
skills.c:        shield = tar_ch->equipment[shield_loc];
skills.c:          || tar_ch->specials.fighting == ch ) {
skills.c:    else if ((armor = tar_ch->equipment[loc]) != NULL)
skills.c:    if (ch->skills[SKILL_KICK] || !AWAKE(tar_ch) || is_paralyzed(tar_ch)) {
skills.c:            if (tar_ch->skills[SKILL_KICK])
skills.c:                dodge += number(1, tar_ch->skills[SKILL_KICK]->learned);
skills.c:        chance = has_skill(ch, SKILL_KICK) ? ch->skills[SKILL_KICK]->learned : 1;
skills.c:        if (tar_ch->skills[SKILL_KICK] && AWAKE(tar_ch)
skills.c:                if (ch->skills[SKILL_KICK]) {
skills.c:                    if (ch->skills[SKILL_KICK]->learned < 30)
skills.c:                    else if (ch->skills[SKILL_KICK]->learned < 40)
skills.c:                    else if (ch->skills[SKILL_KICK]->learned < 50)
skills.c:                    else if (ch->skills[SKILL_KICK]->learned < 60)
skills.c:                    else if (ch->skills[SKILL_KICK]->learned < 70)
skills.c:                    else if (ch->skills[SKILL_KICK]->learned < 81)
skills.c:                //         sprintf(mess, "Natural armor: %d", tar_ch->abilities.armor);
skills.c:                //         sprintf(mess, "Natural armor modifier: %d", (tar_ch->abilities.armor) * (2/3));
skills.c:                damage -= tar_ch->abilities.armor;
skills.c:                if ((damage < 1) && (tar_ch->abilities.armor > 0)) {
skills.c:                    if (!(ch->specials.fighting))
skills.c:                //              damage -= tar_ch->abilities.armor / 10;
skills.c:                        if (!(ch->specials.fighting))
skills.c:                        if (!(ch->specials.fighting))
skills.c:        if (has_skill(ch, SKILL_KICK) && ch->skills[SKILL_KICK]->learned <= 25)
skills.c:    ch->specials.act_wait = 0;
skills.c:    if (!ch->specials.fighting) {
skills.c:    if (ch->specials.riding) {
skills.c:    if (!ch->equipment[EP] || !ch->equipment[ES]) {
skills.c:    if ((tar_ch->in_room) != (ch->in_room)) {
skills.c:    if (tar_ch->specials.fighting != ch) {
skills.c:    if (ch->specials.fighting == tar_ch) {
skills.c:        if (ch->specials.alt_fighting) {
skills.c:            ch->specials.alt_fighting = 0;
skills.c:    if (ch->specials.alt_fighting == tar_ch) {
skills.c:    if (ch->specials.alt_fighting) {
skills.c:    if (ch->skills[SKILL_SPLIT_OPPONENTS]) {
skills.c:        if (tar_ch->skills[SKILL_SPLIT_OPPONENTS])
skills.c:            dodge += number(1, tar_ch->skills[SKILL_SPLIT_OPPONENTS]->learned);
skills.c:        chance = ch->skills[SKILL_SPLIT_OPPONENTS] ? ch->skills[SKILL_SPLIT_OPPONENTS]->learned : 1;
skills.c:            old_def = (int) ch->abilities.def;
skills.c:            ch->abilities.def -= 25;
skills.c:            ch->abilities.def = (sbyte) MAX(0, ch->abilities.def - 25);
skills.c:                ch->abilities.def = (sbyte) old_def;
skills.c:            ch->specials.alt_fighting = tar_ch;
skills.c:    if (ch->specials.riding)
skills.c:    if (ch->lifting)
skills.c:            obj = ch->equipment[j];
skills.c:        && IS_SET(tch->in_room->room_flags, RFL_POPULATED)) {
skills.c:    else if (!IS_SET(tch->in_room->room_flags, RFL_POPULATED)) {
skills.c:            if (number(1, tch->skills[SKILL_LISTEN]->learned) > number(1, percent)) {
skills.c:        if (ch->master != tch) {
skills.c:        percent -= tch->skills[PSI_SENSE_PRESENCE]->learned;
skills.c:                REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
skills.c:            roomlogf(ch->in_room, "1/500 sneak failure!  BAD LUCK");
skills.c:        roomlogf(ch->in_room, "sneak success");
skills.c:    roomlogf(ch->in_room, "percent: %d, roll: %d = %s %s them", percent, roll,
skills.c:        roomlogf(ch->in_room, "base_percent: %d, roll: %d = %s", base_percent, roll, base_percent <= roll ? "removed hide" : "remain hidden");
skills.c:        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE); // remove hide
skills.c:    if (ch->specials.riding) {
skills.c:            if (ch->equipment[j]
skills.c:                && (ch->equipment[j]->obj_flags.type == ITEM_ARMOR)
skills.c:                && (ch->equipment[j]->obj_flags.material == MATERIAL_METAL)) {
skills.c:                        OSTR(ch->equipment[j], short_descr));
skills.c:    if (ch->skills[SKILL_HIDE] && (roll < ch->skills[SKILL_HIDE]->learned))
skills.c:        success_chance = (ch->skills[SKILL_HIDE]->learned);
skills.c:        if (WILD_HIDER(ch) && !HIDE_WILD_AREA(ch->in_room)) {
skills.c:        } else if (CITY_HIDER(ch) && !HIDE_CITY_AREA(ch->in_room)) {
skills.c:            if (IS_SET(ch->in_room->room_flags, RFL_PLANT_SPARSE)) {
skills.c:            } else if (IS_SET(ch->in_room->room_flags, RFL_PLANT_HEAVY)) {
skills.c:            if (IS_SET(ch->in_room->room_flags, RFL_POPULATED)) {
skills.c:        REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
skills.c:        for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
skills.c:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
skills.c:    for (rch = character_list; rch; rch = rch->next) {
skills.c:        if (is_char_watching_char(rch, ch) && rch->in_room != ch->in_room) {
skills.c:    MUD_SET_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
skills.c:    if (!(ct = room_in_city(ch->in_room))
skills.c:        || IS_SET(ch->specials.act, city[ct].c_flag)
skills.c:    if (!IS_SET(ch->in_room->room_flags, RFL_POPULATED)
skills.c:     || room_visibility(ch->in_room) < 0
skills.c:     || (IS_SET(ch->in_room->room_flags, RFL_POPULATED)
skills.c:      && !IS_SET(ch->in_room->room_flags, RFL_INDOORS)
skills.c:        for (tch = ch->in_room->people; tch; tch = tch->next_in_room)
skills.c:            if (ch->in_room->direction[dir]
skills.c:                && (rm = ch->in_room->direction[dir]->to_room))
skills.c:                for (tch = rm->people; tch; tch = tch->next_in_room)
skills.c:    } else if(IS_SET(ch->specials.affected_by, CHAR_AFF_HIDE)) {
skills.c:            if (tch->in_room == ch->in_room)
skills.c:    skill = has_skill(ch, SKILL_SLEIGHT_OF_HAND) ? ch->skills[SKILL_SLEIGHT_OF_HAND]->learned : number(1, GET_AGL(ch));
skills.c:    if (IS_SET(ch->in_room->room_flags, RFL_POPULATED))
skills.c:    if (IS_SET(ch->in_room->room_flags, RFL_INDOORS))
skills.c:    skill = has_skill(ch, SKILL_STEAL) ? ch->skills[SKILL_STEAL]->learned : number(1, GET_AGL(ch));
skills.c:    if (IS_SET(ch->in_room->room_flags, RFL_POPULATED))
skills.c:    if (IS_SET(ch->in_room->room_flags, RFL_INDOORS))
skills.c:    if (ch->specials.riding) {
skills.c:        if ((obj = get_obj_in_list_vis(ch, obj_name, ch->in_room->contents))) {
skills.c:		    snprintf(buf, sizeof(buf), "%s gets %s from room r%d. (steal failure)\n\r", GET_NAME(ch), OSTR(obj, short_descr), ch->in_room->number);
skills.c:		    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
skills.c:					GET_NAME(ch), OSTR(obj, short_descr), ch->in_room->number);
skills.c:                    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
skills.c:                REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
skills.c:                    if ((ct = room_in_city(ch->in_room)) == CITY_NONE)
skills.c:    learned = ch->skills[SKILL_PICK_LOCK]
skills.c:      ? ch->skills[SKILL_PICK_LOCK]->learned : 0;
skills.c:		if (back->to_room == ch->in_room)
skills.c:                    if (back->to_room == ch->in_room)
skills.c:    obj = (get_obj_in_list_vis(ch, arg1, ch->is_carrying));
skills.c:        percent = (ch->skills[SKILL_TRAP]
skills.c:                   && ch->skills[SKILL_TRAP]->learned) ? ch->skills[SKILL_TRAP]->learned : number(1,
skills.c:            if (!number(0, 5) || !IS_SET(ch->skills.value[1], CONT_TRAP)) {
skills.c:    if (ch->in_room != tar_ch->in_room) {
skills.c:    obj = (get_obj_in_list_vis(ch, arg1, tar_ch->is_carrying));
skills.c:    if (ch->specials.fighting && tar_ch == ch->specials.fighting)
skills.c:    if (tar_ch->equipment[WEAR_HANDS])
skills.c:    if (!ch->skills[SKILL_DISARM])
skills.c:            (ch->skills[SKILL_DISARM]->learned)
skills.c:            && ((percent + 25) > ch->skills[SKILL_DISARM]->learned)) {
skills.c:        obj_to_room(unequip_char(tar_ch, pos), tar_ch->in_room);
skills.c:            if (ch->skills[SKILL_DISARM])
skills.c:    if (!ch->specials.fighting)
skills.c:    if (!tar_ch->specials.fighting)
skills.c:    if (tar_ch->equipment[WEAR_HANDS])
skills.c:    if (ch->skills[SKILL_DISARM])
skills.c:        percent += (ch->skills[SKILL_DISARM]->learned);
skills.c:    if (tar_ch->skills[SKILL_DISARM])
skills.c:        percent -= tar_ch->skills[SKILL_DISARM]->learned;
skills.c:    if (!ch->skills[SKILL_DISARM])
skills.c:                && (tar_ch->skills[SKILL_DISARM])
skills.c:                && ((percent + 25) < tar_ch->skills[SKILL_DISARM]->learned)) {
skills.c:                obj_to_room(unequip_char(tar_ch, pos), ch->in_room);
skills.c:            if (!ch->specials.fighting)
skills.c:            if (!tar_ch->specials.fighting)
skills.c:        if (ch->in_room->direction[dir]) {      /* Direction is possible */
skills.c:            } else if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_FIRE_WALL)) {
skills.c:                drop_room = ch->in_room->direction[dir]->to_room;
skills.c:            } else if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL)) {
skills.c:            } else if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_WIND_WALL)) {
skills.c:            } else if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_BLADE_BARRIER)) {
skills.c:                drop_room = ch->in_room->direction[dir]->to_room;
skills.c:            } else if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_THORN_WALL)) {
skills.c:                drop_room = ch->in_room->direction[dir]->to_room;
skills.c:            drop_room = tar_ch->in_room;
skills.c:        if (tar_ch->skills[SKILL_DISARM] && GET_MOVE(tar_ch) >= 10) {
skills.c:            if (((tar_ch->skills[SKILL_DISARM]->learned) - (percent)) > 25) {
skills.c:                if (ch->skills[SKILL_DISARM]) {
skills.c:                    old_skill = ch->skills[SKILL_DISARM]->learned;
skills.c:                    ch->skills[SKILL_DISARM]->learned = 5;
skills.c:                    ch->skills[SKILL_DISARM]->learned = old_skill;
skills.c:                if (!ch->specials.fighting)
skills.c:                if (!tar_ch->specials.fighting)
skills.c:            obj_to_room(unequip_char(ch, cpos), ch->in_room);
skills.c:            if (ch->skills[SKILL_DISARM])
skills.c:    if (!ch->specials.fighting)
skills.c:    if (!tar_ch->specials.fighting)
skills.c:    af.duration = (has_skill(ch, SKILL_LISTEN) ? ch->skills[SKILL_LISTEN]->learned / 10 + 1 : 1);
skills.c:            ch->specials.act_wait = 0;
skills.c:        if ((cont = get_obj_in_list_vis(ch, name, ch->carrying))) {
skills.c:            if ((ch->skills[SKILL_TRAP])
skills.c:                && (percent <= ch->skills[SKILL_TRAP]->learned)
skills.c:                if ((ch->skills[SKILL_TRAP])
skills.c:                    && (percent <= ch->skills[SKILL_TRAP]->learned)
skills.c:                    send_to_room(buf1, ch->in_room);
skills.c:                            if (back->to_room == ch->in_room) {
skills.c:        if ((cont = get_obj_in_list_vis(ch, name, ch->carrying))) {
skills.c:        if (!ch->skills[SKILL_TRAP]
skills.c:            || (percent > ch->skills[SKILL_TRAP]->learned)) {
skills.c:                    if (back->to_room == ch->in_room)
skills.c:    if (!IS_NPC(ch) || (ch->desc)) {
skills.c:        skill_level = ch->skills[SKILL_HUNT]
skills.c:            ? ch->skills[SKILL_HUNT]->learned : 10;
skills.c:        if (GET_RACE(ch) == RACE_DESERT_ELF && ch->in_room->sector_type != SECT_CITY)
skills.c:        if (ch->specials.riding) {
skills.c:                ch->specials.riding, TO_CHAR);
skills.c:        rm = ch->in_room;
skills.c:        message = find_ex_description("[HUNT_MESSAGE]", ch->in_room->ex_description, TRUE);
skills.c:                track_perc += (ch->skills[SKILL_HUNT]) ? ch->skills[SKILL_HUNT]->learned : 0;
skills.c:                    && (ch->in_room->sector_type != SECT_CITY))
skills.c:                    if (ch->skills[SKILL_HUNT])
skills.c:    from = ch->in_room;
skills.c:    to = tar_ch->in_room;
skills.c:    if (ch->specials.riding) {
skills.c:            ch->specials.riding, TO_CHAR);
skills.c:    if (ch->skills[SKILL_HUNT])
skills.c:        skill_level = MAX(ch->skills[SKILL_HUNT]->learned / 10, 5);
skills.c:    if (!ch->skills[SKILL_HUNT] || (percent > ch->skills[SKILL_HUNT]->learned)) {
skills.c:        if (ch->skills[SKILL_HUNT])
skills.c:    if (ch->in_room == to)
skills.c:    if (!ch->skills[SKILL_BREW]) {
skills.c:    if (!(first_comp = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
skills.c:    if (!(second_comp = get_obj_in_list_vis(ch, arg3, ch->carrying))) {
skills.c:        if (!(third_comp = get_obj_in_list_vis(ch, arg4, ch->carrying))) {
skills.c:            for (base_obj = ch->carrying; base_obj; base_obj = base_obj->next_content)
skills.c:        if (!ch->specials.to_process) {
skills.c:    if (!ch->skills[SKILL_BREW]) {
skills.c:    if (!(first_comp = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
skills.c:    if (!(second_comp = get_obj_in_list_vis(ch, arg3, ch->carrying))) {
skills.c:        if (!(third_comp = get_obj_in_list_vis(ch, arg4, ch->carrying))) {
skills.c:            for (base_obj = ch->carrying; base_obj; base_obj = base_obj->next_content)
skills.c:            for (base_obj = ch->carrying; base_obj; base_obj = base_obj->next_content)
skills.c:            for (base_obj = ch->carrying; base_obj; base_obj = base_obj->next_content)
skills.c:    if (!ch->skills[SKILL_POISON]) {
skills.c:    if (!(p_obj = ch->equipment[ES])) {
skills.c:            failed = (number(25, 125) > ch->skills[SKILL_POISON]->learned);
skills.c:            failed = (number(1, 100) > ch->skills[SKILL_POISON]->learned);
skills.c:    if (ch->specials.riding) {
skills.c:    if (ch->specials.fighting) {
skills.c:    tmp1 = ch->equipment[EP];
skills.c:    tmp2 = ch->equipment[ES];
skills.c:    tmp3 = ch->equipment[ETWO];
skills.c:    chance = (ch->skills[SKILL_SAP] ? ch->skills[SKILL_SAP]->learned : 1);
skills.c:          && !tar_ch->specials.fighting
skills.c:      && !tar_ch->specials.fighting
skills.c:        if (ch->skills[SKILL_SAP])
skills.c:            dam *= (1 + (ch->skills[SKILL_SAP]->learned / 10));
skills.c:    return (set_skill_taught_raw((ch->skills[skilno])));
skills.c:    return (remove_skill_taught_raw((ch->skills[skilno])));
skills.c:    return (is_skill_taught_raw((ch->skills[skilno])));
skills.c:  if (ch->skills[skill_number]) {
skills.c:    return (get_skill_percentage_raw((ch->skills[skilno])));
skills.c:    return (set_skill_percentage_raw((ch->skills[skilno]), perc));
skills.c:    return (set_skill_nogain_raw((ch->skills[skilno])));
skills.c:    return (remove_skill_nogain_raw((ch->skills[skilno])));
skills.c:    return (is_skill_nogain_raw((ch->skills[skilno])));
skills.c:    return (set_skill_hidden_raw((ch->skills[skilno])));
skills.c:    return (remove_skill_hidden_raw((ch->skills[skilno])));
skills.c:    return (is_skill_hidden_raw((ch->skills[skilno])));
smells.c:    pTmp = has_smell(ch->accustomed_smells, pSmell);
smells.c:    for (obj = ch->in_room->contents; obj; obj = obj->next_content) {
smells.c:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
smells.c:        if ((fSmell = has_smell(rch->smells, pSmell)) != NULL
smells.c:        for (obj = rch->carrying; obj; obj = obj->next_content)
smells.c:    if ((fSmell = has_smell(ch->in_room->smells, pSmell)) != NULL
smells.c:    for (pSmell = ch->smells; pSmell; pSmell = pSmell->next) {
smells.c:    for (obj = ch->carrying; obj; obj = obj->next_content)
smells.c:        if (ch->equipment[loc])
smells.c:            for (pSmell = ch->equipment[loc]->smells; pSmell; pSmell = pSmell->next) {
smells.c:    for (pSmell = ch->in_room->smells; pSmell; pSmell = pSmell->next) {
smells.c:    for (obj = ch->in_room->contents; obj; obj = obj->next_content) {
smells.c:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
smells.c:        for (pSmell = rch->smells; pSmell; pSmell = pSmell->next) {
smells.c:        for (obj = rch->carrying; obj; obj = obj->next_content)
smells.c:            if (rch->equipment[loc])
smells.c:                for (pSmell = rch->equipment[loc]->smells; pSmell; pSmell = pSmell->next) {
smells.c:    for (pSmell = ch->accustomed_smells; pSmell; pSmell = pSmell_next) {
smells.c:    smell_intensity_update(&ch->smells);
smells.c:    for (obj = ch->carrying; obj; obj = obj->next_content)
smells.c:        if (ch->equipment[loc] && ch->equipment[loc]->smells)
smells.c:            smell_intensity_update(&ch->equipment[loc]->smells);
smells.c:    smell_rub_off(&ch->accustomed_smells, ch->in_room->smells);
smells.c:    smell_rub_off(&ch->accustomed_smells, ch->smells);
smells.c:    for (obj = ch->carrying; obj; obj = obj->next_content)
smells.c:            smell_rub_off(&ch->accustomed_smells, obj->smells);
smells.c:        if (ch->equipment[loc] && ch->equipment[loc]->smells)
smells.c:            smell_rub_off(&ch->accustomed_smells, ch->equipment[loc]->smells);
smells.c:    smell_rub_off(&ch->smells, ch->in_room->smells);
smells.c:   smell_rub_off( &ch->smells, ch->smells ); */
smells.c:    for (obj = ch->carrying; obj; obj = obj->next_content)
smells.c:            smell_rub_off(&ch->smells, obj->smells);
smells.c:        if (ch->equipment[loc] && ch->equipment[loc]->smells)
smells.c:            smell_rub_off(&ch->smells, ch->equipment[loc]->smells);
smells.c:    for (obj = ch->carrying; obj; obj = obj->next_content) {
smells.c:        smell_rub_off(&ch->equipment[loc]->smells, ch->smells);
smells.c:        smell_rub_off(&ch->equipment[loc]->smells, ch->in_room->smells);
smells.c:        if (ch->equipment[loc]) {
smells.c:            smell_rub_off(&ch->equipment[loc]->smells, ch->smells);
smells.c:            smell_rub_off(&ch->equipment[loc]->smells, ch->in_room->smells);
smells.c:    for (rch = room->people; rch; rch = rch->next_in_room) {
smells.c:        smell_rub_off(&room->smells, rch->smells);
socket.c:                    sprintf(buf1, "%d", npc_index[ch->nr].vnum);
socket.c:                if (!ch->in_room 
socket.c:                 || has_special_on_cmd(ch->in_room->specials, "cave_emulator", -1)
socket.c:                 || get_room_extra_desc_value(ch->in_room, "[time_failure]", buffer, sizeof(buffer))
socket.c:                 || ch->in_room->sector_type == SECT_SOUTHERN_CAVERN
socket.c:                 || ch->in_room->sector_type == SECT_CAVERN
socket.c:                 || ch->in_room->sector_type == SECT_SEWER
socket.c:                 || ch->in_room->zone == 34
socket.c:                if (!ch->in_room 
socket.c:                 || has_special_on_cmd(ch->in_room->specials, "cave_emulator", -1)
socket.c:                 || get_room_extra_desc_value(ch->in_room, "[time_failure]", buffer, sizeof(buffer))
socket.c:                 || ch->in_room->sector_type == SECT_SOUTHERN_CAVERN
socket.c:                 || ch->in_room->sector_type == SECT_CAVERN
socket.c:                 || ch->in_room->sector_type == SECT_SEWER
socket.c:                 || ch->in_room->zone == 34
socket.c:                    sprintf(buf1, "%d", ch->specials.il);
socket.c:                if (!ch->specials.riding)       /* crashed it */
socket.c:                    sprintf(buf1, "riding: %s", PERS(ch, ch->specials.riding));
socket.c:                sprintf(buf1, "%s", ch->long_descr ? "[ldesc]" : "");
socket.c:                sprintf(buf1, "%s%s", ch->long_descr ? "ldesc : " : "",
socket.c:                        ch->long_descr ? ch->long_descr : "");
socket.c:                if (ch->long_descr)
socket.c:                    sprintf(buf1, "%d", ch->in_room ? ch->in_room->number : -1);
socket.c:                    if (!ch->specials.fighting) /* crashed it */
socket.c:                        sprintf(buf1, "fighting: %s", PERS(ch, ch->specials.fighting));
socket.c:                    if (ch->on_obj) {
socket.c:                        if (ch->on_obj->table)
socket.c:                             format_obj_to_char(ch->on_obj->table, ch, 1));
socket.c:                             format_obj_to_char(ch->on_obj, ch, 1));
socket.c:                    if (ch->on_obj) {
socket.c:                        if (ch->on_obj->table)
socket.c:                             format_obj_to_char(ch->on_obj->table, ch, 1));
socket.c:                             format_obj_to_char(ch->on_obj, ch, 1));
socket.c:                    if (ch->on_obj) {
socket.c:                        if (ch->on_obj->table)
socket.c:                             format_obj_to_char(ch->on_obj->table, ch, 1));
socket.c:                             format_obj_to_char(ch->on_obj, ch, 1));
socket.c:                    if (!ch->specials.fighting) /* crashed it */
socket.c:                        sprintf(buf1, "fighting: %s", PERS(ch, ch->specials.fighting));
socket.c:                    if (ch->specials.riding)
socket.c:                       sprintf(buf1, "riding: %s", PERS(ch, ch->specials.riding));
socket.c:                    else if (ch->on_obj) {
socket.c:                        OBJ_DATA *on = ch->on_obj;
socket.c:        ch_next = ch->next;
socket.c:        ch_next = ch->next;
socket.c:        ch_next = ch->next;
socket.c:        ch_next = ch->next;
socket.c:                    if (ch->player.prompt
socket.c:                        && strcmp("(null)", ch->player.prompt)) {
socket.c:                                eval_prompt(ch->player.prompt, ch));
socket.c:                    if (IS_SET(ch->specials.brief, BRIEF_PROMPT)) {
socket.c:                       if( ch->last_prompt == NULL
socket.c:                        || (ch->last_prompt != NULL
socket.c:                        && strcmp(tmp, ch->last_prompt))) { 
socket.c:                          if( ch->last_prompt != NULL ) free(ch->last_prompt);
socket.c:                          ch->last_prompt = strdup(tmp);
socket.c:    if (ch->desc && messg)
socket.c:        write_to_q(messg, &ch->desc->output);
socket.c:    send_to_nearby_rooms("You see a flash of light to the $D.\n\r", ch->in_room); 
socket.c:            if (ch->desc != i && !i->connected)
socket.c:                to_ch = to_ch->next_in_room;
socket.c:                    to_ch = to_ch->next_in_room;
socket.c:         && !IS_SET(to_ch->specials.brief, BRIEF_EMOTE)) {
socket.c:         && !IS_SET(to_ch->specials.brief, BRIEF_EMOTE)) {
socket.c:                to_ch = to_ch->next_in_room;
socket.c:            to_ch = to_ch->next_in_room;
socket.c:    else if (ch && (ch->in_room))
socket.c:        to = ch->in_room->people;
socket.c:    else if (vict_ch && vict_ch->in_room)
socket.c:        to = vict_ch->in_room->people;
socket.c:                    case 'h': i = PERS(to, ch->specials.subduing); break;
socket.c:                    case 'H': i = PERS(to, vict_ch->specials.subduing); break;
socket.c:                    case 'r': i = PERS(to, ch->specials.riding); break;
socket.c:                    case 'R': i = PERS(to, vict_ch->specials.riding); break;
socket.c:                            if (curr_room && curr_room == ch->in_room) {
socket.c:                                if (curr_room2 && ch->in_room && (curr_room2 == ch->in_room)) { /* 2 room away */
socket.c:                                    if (curr_room3 && ch->in_room && (curr_room3 == ch->in_room)) {
sp_parser.c:	  sprintf(edesc_title, "[ENCHANTER_%s_%s]", ch->account, ch->name)
sp_parser.c:	  sprintf(edesc_title, "[ENCHANTER_NPC_%d]", npc_index[ch->nr].vnum);
sp_parser.c:    if (ch->skills[spl]->rel_lev > 0)
sp_parser.c:        ch->skills[spl]->rel_lev--;
sp_parser.c:    if (ch->in_room && ch->in_room->sector_type == SECT_WATER_PLANE
sp_parser.c:     && !find_ex_description("[BREATHE_WATER]", ch->ex_description, TRUE)
sp_parser.c:                    free(ch->player.info[1]);
sp_parser.c:                    sprintf(buf, "%s has drowned to death in room %d.  Glug glug.", GET_NAME(ch), ch->in_room->number);
sp_parser.c:                    ch->player.info[1] = strdup(buf);
sp_parser.c:    for (af = ch->affected; (af && (alive == TRUE)); af = next_af_dude) {
sp_parser.c:            for (tmp_object = ch->carrying; tmp_object; tmp_object = tmp_object->next_content) {
sp_parser.c:                if (ch->equipment && ch->equipment[pos]) {
sp_parser.c:                    tmp_object = ch->equipment[pos];
sp_parser.c:                    MUD_SET_BIT(ch->specials.act, crimflag);
sp_parser.c:    for (victim = ch->followers; victim; victim = next_vic) {
sp_parser.c:    for (obj = ch->carrying; obj; obj = obj->next_content) {
sp_parser.c:    for (obj = ch->carrying; obj; obj = obj->next_content) {
sp_parser.c:    for (obj = ch->carrying; obj; obj = obj->next_content) {    /* loop searching for component */
sp_parser.c:            REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_BLIND);
sp_parser.c:                if (ch->equipment[i]
sp_parser.c:                    && isname(name, OSTR(ch->equipment[i], name))
sp_parser.c:                    tar_obj = ch->equipment[i];
sp_parser.c:                if (!ch->specials.subduing
sp_parser.c:                    || (ch->specials.subduing != get_char_room_vis(ch, name))) {
sp_parser.c:        if ((tar_char = ch->specials.contact))
sp_parser.c:        if ((tar_obj = get_obj_in_list_vis(ch, name, ch->in_room->contents)))
sp_parser.c:        if ((tar_obj = get_obj_in_list_vis(ch, name, ch->carrying)))
sp_parser.c:        if (ch->specials.fighting) {
sp_parser.c:        if ((tar_char = ch->specials.fighting))
sp_parser.c:        MUD_SET_BIT(ch->specials.affected_by, CHAR_AFF_BLIND);
sp_parser.c:        && (!ch->specials.to_process)) {
sp_parser.c:        if ((ch->long_descr) && !(
sp_parser.c:         (ch->skills[nr] ? ((ch->skills[nr]->learned * 7) / 100) : 0, ch, oldarg, 0, tar_char,
sp_parser.c:    if (!ch->skills[spl])
sp_parser.c:    if ((vdiff = (ch->skills[spl]->rel_lev + 1)) < 0)
sp_parser.c:        percent = ch->skills[spl]->learned;
sp_parser.c:      percent = MIN(percent, ch->skills[reach_sk]->learned);
sp_parser.c:    if ((vdiff = ch->skills[spl]->rel_lev) < 0)
sp_parser.c:    if (!(ct = room_in_city(ch->in_room)) || IS_SET(ch->specials.act, city[ct].c_flag)
sp_parser.c:    if (!IS_SET(ch->in_room->room_flags, RFL_POPULATED)) {
sp_parser.c:        for (tch = ch->in_room->people; tch; tch = tch->next_in_room)
sp_parser.c:            if (ch->in_room->direction[dir] && (rm = ch->in_room->direction[dir]->to_room))
sp_parser.c:                for (tch = rm->people; tch; tch = tch->next_in_room)
sp_parser.c:    if (ch->lifting) {
sp_parser.c:        sprintf(buf, "[Dropping %s first.]\n\r", format_obj_to_char(ch->lifting, ch, 1));
sp_parser.c:        if (!drop_lifting(ch, ch->lifting))
sp_parser.c:    if (ch->specials.subduing) {
sp_parser.c:        act("You're too busy holding $N to cast right now.", FALSE, ch, 0, ch->specials.subduing,
sp_parser.c:        if ((ch->equipment[ES]) && (!IS_SET(ch->equipment[ES]->obj_flags.extra_flags, OFL_CAST_OK)))
sp_parser.c:        if ((ch->equipment[EP]) && (!IS_SET(ch->equipment[EP]->obj_flags.extra_flags, OFL_CAST_OK)))
sp_parser.c:        if ((ch->equipment[ETWO])
sp_parser.c:            && (!IS_SET(ch->equipment[ETWO]->obj_flags.extra_flags, OFL_CAST_OK)))
sp_parser.c:        if (IS_SET(ch->specials.affected_by, CHAR_AFF_HIDE))
sp_parser.c:            REMOVE_BIT(ch->specials.affected_by, CHAR_AFF_HIDE);
sp_parser.c:        if (IS_SET(ch->in_room->room_flags, RFL_NO_MAGICK)) {
sp_parser.c:        if ((IS_SET(ch->in_room->room_flags, RFL_NO_ELEM_MAGICK))
sp_parser.c:        if (IS_SET(ch->in_room->room_flags, RFL_IMMORTAL_ROOM)) {
sp_parser.c:            room_in_city(ch->in_room) == CITY_TULUK &&
sp_parser.c:          for (CHAR_DATA *person = ch->in_room->people; person; person = person->next_in_room) {
sp_parser.c:              IS_SET(ch->in_room->room_flags, RFL_NO_PSIONICS) ||
sp_parser.c:            sprintf(caster_msg_to_tuluk_templars, "You sense magick use in %s.", ch->in_room->name);
sp_parser.c:                    MSTR(ch, short_descr), ch->in_room->name);
sp_parser.c:            MUD_SET_BIT(ch->specials.act, city[CITY_TULUK].c_flag);
sp_parser.c:            room_in_city(ch->in_room) == CITY_TULUK &&
sp_parser.c:            && ((ch->in_room->sector_type == SECT_FIRE_PLANE)
sp_parser.c:                || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)))
sp_parser.c:            && ((ch->in_room->sector_type == SECT_WATER_PLANE)
sp_parser.c:                || (ch->in_room->sector_type == SECT_SHADOW_PLANE)))
sp_parser.c:            && (ch->in_room->sector_type == SECT_EARTH_PLANE))
sp_parser.c:            && (ch->in_room->sector_type == SECT_AIR_PLANE))
sp_parser.c:            && (ch->in_room->sector_type == SECT_WATER_PLANE))
sp_parser.c:            && (ch->in_room->sector_type == SECT_FIRE_PLANE))
sp_parser.c:            && (ch->in_room->sector_type == SECT_AIR_PLANE))
sp_parser.c:            && (ch->in_room->sector_type == SECT_FIRE_PLANE))
sp_parser.c:            && (ch->in_room->sector_type == SECT_WATER_PLANE))
sp_parser.c:            && (ch->in_room->sector_type == SECT_EARTH_PLANE))
sp_parser.c:            && (ch->in_room->sector_type == SECT_LIGHTNING_PLANE))
sp_parser.c:            && (ch->in_room->sector_type == SECT_SHADOW_PLANE))
sp_parser.c:            && (ch->in_room->sector_type == SECT_NILAZ_PLANE))
sp_parser.c:                    else if ((tar_char = get_char_room(name, ch->in_room))) {
sp_parser.c:                    if ((tar_obj = get_obj_in_list_vis(ch, name, ch->carrying)))
sp_parser.c:                    if ((tar_obj = get_obj_in_list_vis(ch, name, ch->in_room->contents)))
sp_parser.c:                        if (ch->equipment[i] && stricmp(name, OSTR(ch->equipment[i], name)) == 0) {
sp_parser.c:                            tar_obj = ch->equipment[i];
sp_parser.c:                    if (ch->specials.fighting) {
sp_parser.c:                    if (ch->specials.fighting) {
sp_parser.c:                        tar_char = ch->specials.fighting;
sp_parser.c:                    if (ch->specials.contact) {
sp_parser.c:                        tar_char = ch->specials.contact;
sp_parser.c:            } else if (is_charmed(ch) && (ch->master == tar_char)) {
sp_parser.c:        if (!(tar_obj = get_obj_in_list_vis(ch, name, ch->carrying))) {
sp_parser.c:    if (!ch->specials.to_process) {
sp_parser.c:        char_room = ch->in_room;
sp_parser.c:        if (!(find_ex_description("[NO_CAST_MESSAGE]", ch->ex_description, TRUE))) {
sp_parser.c:        if (!ch->in_room) {
sp_parser.c:                if (!(is_templar_in_city(ch) && room_in_city(ch->in_room) == CITY_ALLANAK)) {
sp_parser.c:                        && ((ch->in_room->sector_type == SECT_FIRE_PLANE)
sp_parser.c:                            || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)))
sp_parser.c:                        && ((ch->in_room->sector_type == SECT_WATER_PLANE)
sp_parser.c:                            || (ch->in_room->sector_type == SECT_SHADOW_PLANE)))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_EARTH_PLANE))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_AIR_PLANE))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_WATER_PLANE))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_FIRE_PLANE))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_AIR_PLANE))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_FIRE_PLANE))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_WATER_PLANE))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_EARTH_PLANE))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_LIGHTNING_PLANE))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_SHADOW_PLANE))
sp_parser.c:                        && (ch->in_room->sector_type == SECT_NILAZ_PLANE))
sp_parser.c:                    && (power <= (ch->skills[spl]->rel_lev + 1))) {
sp_parser.c:                        && ch->skills[reach_sk]->learned < ch->skills[spl]->learned) {
sp_parser.c:            if (power > ch->skills[spl]->rel_lev) {
sp_parser.c:                percent = 10 * (power - ch->skills[spl]->rel_lev);
sp_parser.c:                    ch->skills[spl]->rel_lev++;
sp_parser.c:                    ch->skills[spl]->rel_lev = MIN(ch->skills[spl]->rel_lev, 2);
sp_parser.c:                    ch->skills[spl]->rel_lev = MIN(ch->skills[spl]->rel_lev, 6);
sp_parser.c:              if (room_in_city(ch->in_room) == CITY_ALLANAK) {
sp_parser.c:            if (!ch->in_room) {
sp_parser.c:            if (!(is_templar_in_city(ch) && room_in_city(ch->in_room) == CITY_ALLANAK)) {
sp_parser.c:                    && ((ch->in_room->sector_type == SECT_FIRE_PLANE)
sp_parser.c:                        || (ch->in_room->sector_type == SECT_LIGHTNING_PLANE)))
sp_parser.c:                    && ((ch->in_room->sector_type == SECT_WATER_PLANE)
sp_parser.c:                        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_EARTH_PLANE))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_AIR_PLANE))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_WATER_PLANE))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_FIRE_PLANE))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_AIR_PLANE))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_FIRE_PLANE))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_WATER_PLANE))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_EARTH_PLANE))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_LIGHTNING_PLANE))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_SHADOW_PLANE))
sp_parser.c:                    && (ch->in_room->sector_type == SECT_NILAZ_PLANE))
sp_parser.c:    eco = (float) ch->specials.eco;
sp_parser.c:        switch (ch->in_room->sector_type) {
sp_parser.c:        if (IS_SET(ch->in_room->room_flags, RFL_ASH))
sp_parser.c:        if (ch->in_room->zone == 73) {
sp_parser.c:        wn = find_weather_node(ch->in_room);
sp_parser.c:        } else if (!IS_SET(ch->in_room->room_flags, RFL_PLANT_HEAVY)
sp_parser.c:                   && !IS_SET(ch->in_room->room_flags, RFL_PLANT_SPARSE)) {
sp_parser.c:            if (IS_SET(ch->in_room->room_flags, RFL_ASH))
sp_parser.c:        gather_msg_self = find_ex_description("[GATHER_LAND_MSG_SELF]", ch->ex_description, TRUE);
sp_parser.c:        gather_msg_room = find_ex_description("[GATHER_LAND_MSG_ROOM]", ch->ex_description, TRUE);
sp_parser.c:        if (!IS_SET(ch->in_room->room_flags, RFL_ASH)) {
sp_parser.c:            MUD_SET_BIT(ch->in_room->room_flags, RFL_ASH);
sp_parser.c:        new_event(EVNT_REMOVE_ASH, (int) (mana * 6 * 60), 0, 0, 0, ch->in_room, 0);
sp_parser.c:            if (p->in_room && (p->in_room != ch->in_room)
sp_parser.c:                && (p->in_room->zone == ch->in_room->zone)
sp_parser.c:                && (-1 != choose_exit_name_for(p->in_room, ch->in_room, ch_comm, 5, 0))) {
sp_parser.c:            if (ch->specials.eco > 0)   // Preserver is defiling
sp_parser.c:                ch->specials.eco = MAX(0, ch->specials.eco - 25);
sp_parser.c:                ch->specials.eco = MAX(-100, ch->specials.eco - 1);
sp_parser.c:        gather_msg_self = find_ex_description("[GATHER_SELF_MSG_SELF]", ch->ex_description, TRUE);
sp_parser.c:        gather_msg_room = find_ex_description("[GATHER_SELF_MSG_ROOM]", ch->ex_description, TRUE);
sp_parser.c:    if (has_skill(ch, SKILL_GATHER) && !skill_success(ch, NULL, ch->skills[SKILL_GATHER]->learned)
sp_parser.c:    ct = room_in_city(ch->in_room);
sp_parser.c:            if (!IS_SET(ch->specials.act, city[ct].c_flag))
sp_parser.c:                MUD_SET_BIT(ch->specials.act, city[ct].c_flag);
sp_parser.c:    for (tmp = ch->in_room->people; tmp; tmp = tmp->next_in_room) {
sp_parser.c:                if (!IS_SET(ch->specials.act, city[ct].c_flag))
sp_parser.c:                    MUD_SET_BIT(ch->specials.act, city[ct].c_flag);
special.c:    if (!ch->desc)
special.c:    if (ch->player.tribe != npc->player.tribe) {
special.c:    temp_desc = find_ex_description("[DOOKIE]", ch->ex_description, TRUE);
special.c:        if (ch->points.obsidian < cost_num) {
special.c:        ch->points.obsidian -= cost_num;
special.c:                        npc_index[ch->nr].vnum);
special.c:    if (!(ch->in_room->direction[DIR_DOWN])) {
special.c:			ch->in_room->number);
special.c:    if (!(down_room = ch->in_room->direction[DIR_DOWN]->to_room))
special.c:    chance_noise += ch->player.weight + calc_carried_weight(ch);
special.c:    if ((ch->player.weight + calc_carried_weight(ch)) < 4)
special.c:    else if (ch->player.weight + calc_carried_weight(ch) < 10)
special.c:    else if (ch->player.weight + calc_carried_weight(ch) < 20)
special.c:    else if (ch->player.weight + calc_carried_weight(ch) > 20)
special.c:                ch->equipment[ES] == obj ? "held" : "carried");
special.c:    if (ch->equipment[ES] != obj) {
special.c:        if (!(hole = get_obj_in_list_vis(ch, arg1, ch->in_room->contents)))
special.c:        if (!(hole = get_obj_in_list_vis(ch, arg2, ch->in_room->contents)))
special.c:        errorlogf("Portable hole without an owner, room #%d.", ch->in_room->number);
special.c:        if (!(temp = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
special.c:    ch->player.start_city = start_loc[i].city_num;
special.c:        ch->specials.accent = default_accent(ch);
special.c:     || ch->specials.act_wait)
spells.c:            if (!(tar_obj = get_obj_in_list_vis(ch, buf, ch->in_room->contents))) {
spells.c:        i = ch->in_room->contents;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        tar_ch = ch->in_room->people;
spells.c:            temp = tar_ch->next_in_room;
spells.c:        if (!ch->in_room->direction[dir]) {
spells.c:        if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_BLADE_BARRIER)) {
spells.c:        MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_BLADE_BARRIER);
spells.c:        new_event(EVNT_REMOVE_BLADEBARRIER, duration, 0, 0, 0, ch->in_room, dir);
spells.c:                if (back->to_room == ch->in_room) {
spells.c:            if (ch->in_room->direction[dir]) {
spells.c:                if (!IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_BLADE_BARRIER)) {
spells.c:                    MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_BLADE_BARRIER);
spells.c:                    new_event(EVNT_REMOVE_BLADEBARRIER, duration, 0, 0, 0, ch->in_room, dir);
spells.c:                            if (back->to_room == ch->in_room) {
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:    if ((ch->in_room->sector_type == SECT_NILAZ_PLANE)
spells.c:        || (ch->in_room->sector_type == SECT_EARTH_PLANE)
spells.c:        || (ch->in_room->sector_type == SECT_SILT)
spells.c:        || (ch->in_room->sector_type == SECT_WATER_PLANE)) {
spells.c:        obj_to_room(tmp_obj, ch->in_room);
spells.c:        if (ch->in_room->sector_type == SECT_AIR)
spells.c:        else if ((ch->in_room->sector_type == SECT_CAVERN)
spells.c:                 || (ch->in_room->sector_type == SECT_SOUTHERN_CAVERN))
spells.c:        else if (ch->in_room->sector_type == SECT_DESERT)
spells.c:        else if (ch->in_room->sector_type == SECT_SALT_FLATS)
spells.c:        else if (ch->in_room->sector_type == SECT_THORNLANDS)
spells.c:        else if (ch->in_room->sector_type == SECT_ROAD)
spells.c:        else if (ch->in_room->sector_type == SECT_SEWER)
spells.c:        else if (ch->in_room->sector_type == SECT_GRASSLANDS)
spells.c:            sprintf(buf, "%d", npc_index[ch->nr].vnum);
spells.c:            set_obj_extra_desc_value(tmp_obj, "[ACCOUNT_info]", ch->account);
spells.c:        send_to_room("Mist fills the air for a moment.\n\r", ch->in_room);
spells.c:        i = ch->in_room->contents;
spells.c:      send_to_room("A dark mist fills the air for a moment.\n\r", ch->in_room);
spells.c:      i = ch->in_room->contents;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        i = ch->in_room->contents;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:            if (!(tar_obj = get_obj_in_list_vis(ch, buf, ch->in_room->contents))) {
spells.c:        i = ch->in_room->contents;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:            if (!ch->in_room->direction[dir]) {
spells.c:            if (IS_SET(ch->in_room->room_flags, RFL_SPL_ALARM)) {
spells.c:		remove_alarm_spell(ch->in_room);
spells.c:                             ch->in_room);
spells.c:            if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL)) {
spells.c:                REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL);
spells.c:                send_to_room(buf, ch->in_room);
spells.c:                    && (back->to_room == ch->in_room)) {
spells.c:            if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_FIRE_WALL)) {
spells.c:                REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_FIRE_WALL);
spells.c:                send_to_room(buf, ch->in_room);
spells.c:                    && (back->to_room == ch->in_room)) {
spells.c:            if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_WIND_WALL)) {
spells.c:                REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_WIND_WALL);
spells.c:                send_to_room(buf, ch->in_room);
spells.c:                    && (back->to_room == ch->in_room)) {
spells.c:            if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_THORN_WALL)) {
spells.c:                REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_THORN_WALL);
spells.c:                send_to_room(buf, ch->in_room);
spells.c:                    && (back->to_room == ch->in_room)) {
spells.c:            if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_BLADE_BARRIER)) {
spells.c:                REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_BLADE_BARRIER);
spells.c:                send_to_room(buf, ch->in_room);
spells.c:                    && (back->to_room == ch->in_room)) {
spells.c:        tar_ch = ch->in_room->people;
spells.c:            temp = tar_ch->next_in_room;
spells.c:        if (IS_SET(ch->in_room->room_flags, RFL_SPL_ALARM)) {
spells.c:            remove_alarm_spell(ch->in_room);
spells.c:                         ch->in_room);
spells.c:            if (ch->in_room->direction[dir]) {
spells.c:                if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL)) {
spells.c:                    REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL);
spells.c:                    send_to_room(buf, ch->in_room);
spells.c:                        && (back->to_room == ch->in_room)) {
spells.c:                if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_FIRE_WALL)) {
spells.c:                    REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_FIRE_WALL);
spells.c:                    send_to_room(buf, ch->in_room);
spells.c:                        && (back->to_room == ch->in_room)) {
spells.c:                if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_WIND_WALL)) {
spells.c:                    REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_WIND_WALL);
spells.c:                    send_to_room(buf, ch->in_room);
spells.c:                        && (back->to_room == ch->in_room)) {
spells.c:                if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_THORN_WALL)) {
spells.c:                    REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_THORN_WALL);
spells.c:                    send_to_room(buf, ch->in_room);
spells.c:                        && (back->to_room == ch->in_room)) {
spells.c:                if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_BLADE_BARRIER)) {
spells.c:                    REMOVE_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_BLADE_BARRIER);
spells.c:                    send_to_room(buf, ch->in_room);
spells.c:                        && (back->to_room == ch->in_room)) {
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        if (!(item = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        victim = ch->in_room->people;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        tar_ch = ch->in_room->people;
spells.c:            temp = tar_ch->next_in_room;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:                    ch->in_room->number);
spells.c:                sprintf(bug, "goto %d", ch->in_room->number);
spells.c:        i = ch->in_room->contents;
spells.c:        send_to_room("A brilliant glow suffuses the air momentarily.\n\r", ch->in_room);
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        if (ch->in_room->sector_type != SECT_NILAZ_PLANE) {
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        i = ch->in_room->contents;
spells.c:        send_to_room("Hero Sword room message.\n\r", ch->in_room);
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        victim = ch->in_room->people;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_obj = ch->in_room->contents; tar_obj; tar_obj = tar_obj->next_content)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_obj = ch->in_room->contents; tar_obj; tar_obj = tar_obj->next_content)
spells.c:        if (ch->in_room->sector_type == SECT_WATER_PLANE) {
spells.c:            tar_ch = ch->in_room->people;
spells.c:                temp = tar_ch->next_in_room;
spells.c:        tar_ch = ch->in_room->people;
spells.c:            temp = tar_ch->next_in_room;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        tmp = ch->in_room->people;
spells.c:        send_to_room("A brilliant glow suffuses the air momentarily.\n\r", ch->in_room);
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:    if (IS_SET(ch->in_room->room_flags, RFL_INDOORS)) {
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        i = ch->in_room->contents;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        send_to_room("A dark mist fills the air for a moment.\n\r", ch->in_room);
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        if (IS_SET(ch->in_room->room_flags, RFL_INDOORS)) {
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        i = ch->in_room->contents;
spells.c:        send_to_room("A dull, brown glow fills the area momentarily.\n\r", ch->in_room);
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        victim = ch->in_room->people;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        if (ch->in_room->sector_type <= SECT_CITY) {
spells.c:        tmp = ch->in_room->people;
spells.c:        if (ch->in_room->sector_type <= SECT_CITY) {
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        if (ch->in_room)
spells.c:            for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        tar_ch = ch->in_room->people;
spells.c:            temp = tar_ch->next_in_room;
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (follower = ch->followers; follower; follower = nextfol) {
spells.c:            if (ethereal_ch_compare(ch, tar_ch) && ch->in_room == tar_ch->in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        i = ch->in_room->contents;
spells.c:        send_to_room("A cold, eerie chill fills the area momentarily.\n\r", ch->in_room);
spells.c:        tar_ch = ch->in_room->people;
spells.c:            temp = tar_ch->next_in_room;
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        i = ch->in_room->contents;
spells.c:    if ((ch->in_room->sector_type == SECT_WATER_PLANE)
spells.c:        || (ch->in_room->sector_type == SECT_SHADOW_PLANE)
spells.c:        || (ch->in_room->sector_type == SECT_NILAZ_PLANE)) {
spells.c:        if (!ch->in_room->direction[dir]) {
spells.c:        if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_FIRE_WALL)) {
spells.c:        MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_FIRE_WALL);
spells.c:        new_event(EVNT_REMOVE_FIREWALL, duration, 0, 0, 0, ch->in_room, dir);
spells.c:                if (back->to_room == ch->in_room) {
spells.c:            if (ch->in_room->direction[dir]) {
spells.c:                if (!IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_FIRE_WALL)) {
spells.c:                    MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_FIRE_WALL);
spells.c:                    new_event(EVNT_REMOVE_FIREWALL, duration, 0, 0, 0, ch->in_room, dir);
spells.c:                            if (back->to_room == ch->in_room) {
spells.c:    if ((ch->in_room->sector_type == SECT_AIR_PLANE)
spells.c:        || (ch->in_room->sector_type == SECT_NILAZ_PLANE)) {
spells.c:        if (!ch->in_room->direction[dir]) {
spells.c:        if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL)) {
spells.c:        MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL);
spells.c:        new_event(EVNT_REMOVE_SANDWALL, duration, 0, 0, 0, ch->in_room, dir);
spells.c:                if (back->to_room == ch->in_room) {
spells.c:            if (ch->in_room->direction[dir]) {
spells.c:                if (!IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL)) {
spells.c:                    MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_SAND_WALL);
spells.c:                    new_event(EVNT_REMOVE_SANDWALL, duration, 0, 0, 0, ch->in_room, dir);
spells.c:                            if (back->to_room == ch->in_room) {
spells.c:    if ((ch->in_room->sector_type == SECT_FIRE_PLANE)
spells.c:        || (ch->in_room->sector_type == SECT_NILAZ_PLANE)) {
spells.c:        if (!ch->in_room->direction[dir]) {
spells.c:        if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_THORN_WALL)) {
spells.c:        MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_THORN_WALL);
spells.c:        new_event(EVNT_REMOVE_THORNWALL, duration, 0, 0, 0, ch->in_room, dir);
spells.c:                if (back->to_room == ch->in_room) {
spells.c:            if (ch->in_room->direction[dir]) {
spells.c:                if (!IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_THORN_WALL)) {
spells.c:                    MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_THORN_WALL);
spells.c:                    new_event(EVNT_REMOVE_THORNWALL, duration, 0, 0, 0, ch->in_room, dir);
spells.c:                            if (back->to_room == ch->in_room) {
spells.c:    if ((ch->in_room->sector_type == SECT_EARTH_PLANE)
spells.c:        || (ch->in_room->sector_type == SECT_NILAZ_PLANE)) {
spells.c:        if (!ch->in_room->direction[dir]) {
spells.c:        if (IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_WIND_WALL)) {
spells.c:        MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_WIND_WALL);
spells.c:        new_event(EVNT_REMOVE_WINDWALL, duration, 0, 0, 0, ch->in_room, dir);
spells.c:                if (back->to_room == ch->in_room) {
spells.c:            if (ch->in_room->direction[dir]) {
spells.c:                if (!IS_SET(ch->in_room->direction[dir]->exit_info, EX_SPL_WIND_WALL)) {
spells.c:                    MUD_SET_BIT(ch->in_room->direction[dir]->exit_info, EX_SPL_WIND_WALL);
spells.c:                    new_event(EVNT_REMOVE_WINDWALL, duration, 0, 0, 0, ch->in_room, dir);
spells.c:                            if (back->to_room == ch->in_room) {
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (tar_ch = ch->in_room->people; tar_ch; tar_ch = tar_ch->next_in_room)
spells.c:        for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
spells.c:        tar_ch = ch->in_room->people;
spells.c:            tar_ch = tar_ch->next_in_room;
spells.c:        tar_obj = ch->in_room->contents;
spells.c:        tar_ch = ch->in_room->people;
spells.c:            tar_ch = tar_ch->next_in_room;
spells.c:        tar_obj = ch->in_room->contents;
spice.c:    if (ch->skills[spice])
spice.c:        old_add = ch->skills[spice]->learned;
spice.c:    for (p = tar_ch->affected; p; p = p->next)
spice.c:    new_add = ch->skills[spice]->learned;
spice.c:            --ch->abilities.wis;
spice.c:            --ch->abilities.str;
spice.c:            --ch->abilities.agl;
spice.c:            ch->points.max_hit -= 4;;
spice.c:            --ch->abilities.end;
spice.c:    for (af = ch->affected; af; af = af->next)
spice.c:            !IS_NPC(ch) ? ch->account : "", !IS_NPC(ch) ? ") " : "", skill_name[spice],
spice.c:            ch->in_room->number);
spice.c:            real_time_passed((time(0) - ch->player.time.logon) + ch->player.time.played, 0);
spice.c:                || (ch->player.dead && !strcmp(ch->player.dead, "rebirth")))
spice.c:            && !IS_SET(ch->specials.act, CFL_NO_DEATH)) {
spice.c:            if (ch->player.info[1])
spice.c:                free(ch->player.info[1]);
spice.c:            ch->player.info[1] = strdup(buf);
spice.c:    if (!ch->skills[sk])
spice.c:    if (((t = time(0)) - ch->skills[sk]->last_gain) < (SECS_PER_REAL_MIN * 10))
spice.c:    ch->skills[sk]->learned += gain;
spice.c:    ch->skills[sk]->learned = MIN(ch->skills[sk]->learned, max_gain);
spice.c:    ch->skills[sk]->last_gain = t;
spice.c:    ch->skills[sk]->rel_lev = MAX(ch->skills[sk]->rel_lev, ch->skills[sk]->learned);
spice.c:    if (!ch->skills[sk])
spice.c:    wt = 2 * MAX(20, (get_char_size(ch) / 3) + (ch->skills[sk]->learned / 7));
spice.c:    if (((t = time(0)) - ch->skills[sk]->last_gain) < (SECS_PER_REAL_MIN * wt))
spice.c:    if (sk == TOL_ALCOHOL && GET_COND(ch, DRUNK) < ch->skills[sk]->learned)
spice.c:    if (ch->skills[sk]->learned < ch->skills[sk]->rel_lev)
spice.c:    ch->skills[sk]->learned += gain;
spice.c:    ch->skills[sk]->learned = MIN(ch->skills[sk]->learned, max_gain);
spice.c:    ch->skills[sk]->last_gain = t;
spice.c:    ch->skills[sk]->rel_lev = MAX(ch->skills[sk]->rel_lev, ch->skills[sk]->learned);
spice.c:    if (tar_ch->specials.eco >= 0)
spice.c:    if (tar_ch->specials.eco >= 0)
spice.c:        if (IS_SET(ch->in_room->room_flags, RFL_INDOORS))
spice.c:        if (IS_SET(ch->in_room->room_flags, RFL_INDOORS))
spice.c:        if (IS_SET(ch->in_room->room_flags, RFL_INDOORS))
spice.c:    tmp_af = ch->affected;
spice.c:    if ((!(spice = get_obj_in_list_vis(ch, arg1, ch->carrying)))
spice.c:        && (!(spice = get_obj_in_list_vis(ch, arg1, ch->in_room->contents)))
spice.c:        message = find_ex_description("[SCENT]", ch->in_room->ex_description, TRUE);
spice.c:        if (ch->skills[type])
spice.c:        for (tmp_ch = ch->in_room->people; tmp_ch; tmp_ch = tmp_ch->next)
spice.c:                && (tmp_ch->specials.fighting == ch || tmp_ch->specials.alt_fighting == ch)) {
spice.c:                old_def = (int) ch->abilities.def;
spice.c:                ch->abilities.def -= 25;
spice.c:                ch->abilities.def = (sbyte) MAX(0, ch->abilities.def - 25);
spice.c:                    ch->abilities.def = (sbyte) old_def;
spice.c:    if ((!ch->equipment[ES]) || (ch->equipment[ES]->obj_flags.type != ITEM_SPICE)) {
spice.c:        smoke = ch->equipment[ES];
spice.c:    if (!(p_obj = get_obj_in_list(ch, paper, ch->carrying))) {
spice.c:    if (!(sp_obj = get_obj_in_list(ch, spice, ch->carrying))) {
spice.c:    if ((!ch->equipment[ES]) || (ch->equipment[ES]->obj_flags.type != ITEM_SPICE)) {
spice.c:        brick = ch->equipment[ES];
spice.c:    pinch->obj_flags.cost = pcost;
spice.c:    if (!ch->skills[af->type]) {
spice.c:    --(ch->skills[af->type]->learned);
spice.c:    if (ch->skills[af->type]->learned <= 1) {
spice.c:    if (((ch->skills[af->type]->rel_lev - 74) <= (75 - ch->skills[af->type]->learned)))
spice.c:    if ((ch->skills[af->type]->learned % 10) == 9)
spice.c:            ++ch->abilities.wis;
spice.c:            ++ch->abilities.str;
spice.c:            ++ch->abilities.agl;
spice.c:            ch->points.max_hit += 4;;
spice.c:            ++ch->abilities.end;
spice.c:            /* if ((ch->skills[af->type]->learned % 20) == 9) */
spice.c:            if ((ch->skills[af->type]->learned % 20) == 19) {
spice.c:                ++ch->abilities.end;
spice.c:    if (IS_IMMORTAL(ch) && !IS_SET(ch->specials.act, CFL_UNIQUE))
spice.c:        if ((ch->skills[i]) && ((is_skill_taught(ch, i)) &&
spice.c:                                /* ((ch->skills[i]->taught) && */
spice.c:    if (IS_IMMORTAL(ch) && !IS_SET(ch->specials.act, CFL_UNIQUE))
spice.c:        if (ch->skills[i])
spice.c:                /* if (ch->skills[i]->taught) */
spice.c:                    power += ((ch->skills[i]->rel_lev - 74) - abs(ch->skills[i]->learned - 75));
spice.c:    if (!ch->skills[sk])
spice.c:    if (ch->skills[sk]->learned < ch->skills[sk]->rel_lev)
spice.c:    ch->skills[sk]->learned += gain;
spice.c:    ch->skills[sk]->learned = MIN(ch->skills[sk]->learned, 100);
spice.c:    if (ch->skills[sk]->learned > 75)
spice.c:    /* ch->skills[sk]->taught = 1; */
spice.c:    ch->skills[sk]->last_gain = time(0);
spice.c:    ch->skills[sk]->rel_lev = MAX(ch->skills[sk]->rel_lev, ch->skills[sk]->learned);
spice.c:    if (ch->affected)
spice.c:        for (aff_node = ch->affected; aff_node; aff_node = aff_node->next)
utility.c:    if (ch->on_obj && !IS_SET(ch->on_obj->obj_flags.value[1], FURN_SKIMMER)
utility.c:     && !IS_SET(ch->on_obj->obj_flags.value[1], FURN_WAGON))
utility.c:        remove_occupant(ch->on_obj, ch);
utility.c:       if (ch->specials.guarding)
utility.c:    ch->specials.position = pos;
utility.c:    if (pos == POSITION_FIGHTING && ch->specials.contact
utility.c:    if ((ch->equipment[ETWO]) || (ch->equipment[EP] && ch->equipment[ES]))
utility.c:    if (ch->equipment[WEAR_ON_BACK]) {
utility.c:        back_obj = ch->equipment[WEAR_ON_BACK];
utility.c:    if (ch->equipment[WEAR_ON_BACK]) {
utility.c:        back_obj = ch->equipment[WEAR_ON_BACK];
utility.c:    if (ch->equipment[WEAR_ON_BELT_1]) {
utility.c:        belt1_obj = ch->equipment[WEAR_ON_BELT_1];
utility.c:    if (ch->equipment[WEAR_ON_BELT_2]) {
utility.c:        belt2_obj = ch->equipment[WEAR_ON_BELT_2];
utility.c:    if (ch->equipment[EP])
utility.c:        ep_obj = ch->equipment[EP];
utility.c:    if (ch->equipment[ES])
utility.c:        es_obj = ch->equipment[ES];
utility.c:    if (ch->equipment[ETWO])
utility.c:        etwo_obj = ch->equipment[ETWO];
utility.c:            if (!ch->equipment[WEAR_ON_BACK] && CAN_WEAR(ep_obj, ITEM_WEAR_BACK)) {
utility.c:            if (!ch->equipment[WEAR_ON_BACK] && CAN_WEAR(es_obj, ITEM_WEAR_BACK)) {
utility.c:            if (!ch->equipment[WEAR_ON_BACK] && CAN_WEAR(etwo_obj, ITEM_WEAR_BACK)) {
utility.c:    if (ch->in_room && IS_SET(ch->in_room->room_flags, RFL_NO_PSIONICS))
utility.c:        if (!ch->skills[i])
utility.c:    for (crim = ch->in_room->people; crim; crim = crim->next_in_room)
utility.c:            if (ch->in_room->direction[ex] && ch->in_room->direction[ex]->to_room)
utility.c:                for (crim = ch->in_room->direction[ex]->to_room->people; crim;
utility.c:        ch->specials.speed = SPEED_RUNNING;
utility.c:        ch->specials.speed = SPEED_WALKING;
utility.c:                 npc_index[ch->nr].vnum);
utility.c:    if (!(ct = room_in_city(ch->in_room)))
utility.c:    if (npc_index[ch->nr].vnum == 50055)
utility.c:    if (npc_index[ch->nr].vnum == 50607)
utility.c:    if (npc_index[ch->nr].vnum == 50028)
utility.c:        if (ch->skills[i] && (skill[i].sk_class == CLASS_COMBAT))
utility.c:    if (ch->skills[real_poison - 19]) {
utility.c:        if (ch->skills[real_poison - 19]->learned > number(0, 101))
utility.c:                     GET_NAME(ch), ch->account,
utility.c:                     ch->in_room->number);}
utility.c:                     GET_NAME(ch), ch->account,
utility.c:                     ch->in_room->number);}
utility.c:                     GET_NAME(ch), ch->account,
utility.c:                     ch->in_room->number);}
utility.c:        for (temp = ch->in_room->people; temp; temp = temp->next)
utility.c:        if (ch->in_room->direction[direction]) {
utility.c:            if (!(to_room = ch->in_room->direction[direction]->to_room)) {
utility.c:    if ((ch->in_room->number >= 50660) && (ch->in_room->number <= 50668))
utility.c:        if (!ch->in_room->direction[dir]) {
utility.c:        if (!ch->in_room->direction[dir]) {
utility.c:    if (IS_SET(ch->specials.act, CFL_FROZEN))
utility.c:    if (ch->equipment[ETWO] && (ch->equipment[ETWO]->obj_flags.type != ITEM_WEAPON))
utility.c:    if ((ch->equipment[EP] && (ch->equipment[EP]->obj_flags.type != ITEM_WEAPON))
utility.c:        && (ch->equipment[ES] && (ch->equipment[ES]->obj_flags.type != ITEM_WEAPON)))
utility.c:  (!(ch->equipment[EP] && \
utility.c:  (ch->equipment[EP]->obj_flags.type != ITEM_WEAPON) && \
utility.c:  (!ch->equipment[ES] || \
utility.c:  (ch->equipment[ES]->obj_flags.type != ITEM_WEAPON)) && \
utility.c:  (!ch->equipment[ETWO] || \
utility.c:  (ch->equipment[ETWO]->obj_flags.type != ITEM_WEAPON))))
utility.c:                sprintf( buf, "%s (%s)", ch->name, ch->account );
utility.c:                det_mag_sdesc = find_ex_description("[DET_MAG_SDESC]", ch->ex_description, TRUE);
utility.c:                det_eth_sdesc = find_ex_description("[DET_ETH_SDESC]", ch->ex_description, TRUE);
utility.c:                det_invis_sdesc = find_ex_description("[DET_INVIS_SDESC]", ch->ex_description, TRUE);
utility.c:            if ((ch->equipment[WEAR_ABOUT]) != NULL) {
utility.c:               robe = ch->equipment[WEAR_ABOUT];
utility.c:            } else if ((ch->equipment[WEAR_NECK]) != NULL) {
utility.c:               robe = ch->equipment[WEAR_NECK];
utility.c:            } else if ((ch->equipment[WEAR_HEAD]) != NULL) {
utility.c:               robe = ch->equipment[WEAR_HEAD];
utility.c:            if ((hood = ch->equipment[WEAR_ABOUT]) != NULL 
utility.c:            else if ((hood = ch->equipment[WEAR_BODY]) != NULL 
utility.c:            else if ((hood = ch->equipment[WEAR_HEAD]) != NULL 
utility.c:            else if ((mask = ch->equipment[WEAR_HEAD]) != NULL
utility.c:            else if ((mask = ch->equipment[WEAR_FACE]) != NULL
utility.c:                && ch->skills[object->obj_flags.value[2]]->learned >= 40
utility.c:    if (((hood = ch->equipment[WEAR_ABOUT]) != NULL)
utility.c:    if (((hood = ch->equipment[WEAR_HEAD]) != NULL)
utility.c:    if (((hood = ch->equipment[WEAR_BODY]) != NULL)
utility.c:    if ((robe = ch->equipment[WEAR_ABOUT]) != NULL
utility.c:            strcat(buf, ch->player.extkwds);
utility.c:    if (((mask = ch->equipment[WEAR_HEAD]) != NULL)
utility.c:    if (ch->equipment[ES])
utility.c:    if (ch->equipment[EP])
utility.c:    if (ch->equipment[ETWO])
utility.c:    tmp = ch->player.weight + ch->player.height;
utility.c:    if (IS_SET(ch->specials.act, CFL_MOUNT))
utility.c:    if (IS_SET(ch->specials.act, CFL_MOUNT))
utility.c:    for (tch = rm->people; tch; tch = tch->next_in_room) {
utility.c:         && !IS_SET(tch->specials.quiet_level, quiet_type) 
utility.c:         && !IS_SET(tch->specials.quiet_level, QUIET_LOG)) 
utility.c:    player_age = mud_time_passed(ch->player.time.starting_time, time(0));
utility.c:    player_age.year += ch->player.time.starting_age;
utility.c:        orig_value = ch->abilities.str;
utility.c:        ch->abilities.str = lroundf((float)ch->abilities.str * new_mod / old_mod); 
utility.c:         //ch->abilities.str, orig_value, new_mod, old_mod);
utility.c:        orig_value = ch->abilities.end;
utility.c:        ch->abilities.end = lroundf((float)ch->abilities.end * new_mod / old_mod); 
utility.c:         //ch->abilities.end, orig_value, new_mod, old_mod);
utility.c:        orig_value = ch->abilities.agl;
utility.c:        ch->abilities.agl = lroundf((float)ch->abilities.agl * new_mod / old_mod); 
utility.c:         //ch->abilities.agl, orig_value, new_mod, old_mod);
utility.c:        orig_value = ch->abilities.wis;
utility.c:         ch->abilities.wis = lroundf((float)ch->abilities.wis * new_mod / old_mod); 
utility.c:         //ch->abilities.wis, orig_value, new_mod, old_mod);
utility.c:    ch->tmpabilities = ch->abilities;
utility.c:            (mud_time_passed(ch->player.time.starting_time, ch->player.time.logon).year +
utility.c:             ch->player.time.starting_age);
utility.c:       old_age = ch->player.time.starting_age;
utility.c:        old_str = ch->abilities.str;
utility.c:        old_end = ch->abilities.end;
utility.c:        old_agl = ch->abilities.agl;
utility.c:        old_wis = ch->abilities.wis;
utility.c:             ch->abilities.str, ch->abilities.agl, ch->abilities.wis,
utility.c:             ch->abilities.end);
utility.c:                qgamelogf( QUIET_REROLL, "%s (%s) %s", ch->name, ch->account,
utility.c:    struct time_data *ch_age = &ch->player.time;
utility.c:    struct time_data *ch_age = &ch->player.time;
utility.c:    return ch->tmpabilities.str;
utility.c:    ch->tmpabilities.str = val;
utility.c:    return ch->tmpabilities.agl;
utility.c:    ch->tmpabilities.agl = val;
utility.c:    return ch->tmpabilities.wis;
utility.c:    ch->tmpabilities.wis = val;
utility.c:    return ch->tmpabilities.end;
utility.c:    ch->tmpabilities.end = val;
utility.c:    return ch->tmpabilities.off;
utility.c:    ch->tmpabilities.off = val;
utility.c:    return ch->tmpabilities.def;
utility.c:    ch->tmpabilities.def = val;
utility.c:    return ch->tmpabilities.armor;
utility.c:    ch->tmpabilities.armor = val;
utility.c:    return ch->tmpabilities.damroll;
utility.c:    ch->tmpabilities.damroll = val;
utility.c:    for (CHAR_DATA *ch = rm->people; ch; ch = ch->next_in_room) {
utility.c:        CHAR_DATA *mt = ch->specials.riding;
utility.c:        CHAR_DATA *sub = ch->specials.subduing;
utility.c:            if (ch->lifting) {
utility.c:                        capitalize(format_obj_to_char(ch->lifting, ch, 1)));
utility.c:                drop_lifting(ch, ch->lifting);
utility.c:    if (!ch->in_room)
utility.c:    if (!IS_SET(ch->in_room->room_flags, RFL_FALLING))
utility.c:    if (ch->specials.riding)
utility.c:        ch = ch->specials.riding;
utility.c:        if (IS_SET(ch->specials.act, CFL_SILT_GUY)) {
utility.c:        } else if (ch->on_obj && ch->on_obj->obj_flags.type == ITEM_FURNITURE
utility.c:                   && IS_SET(ch->on_obj->obj_flags.value[1], FURN_SKIMMER)) {
utility.c:    page_string(ch->desc, buf, 1);
utility.c:    if (ch->specials.riding) {
utility.c:        sz = get_char_size(ch->specials.riding);
utility.c:                 MSTR(ch->specials.riding, short_descr));
utility.c:    if (ch->nr == 0) {          /* this is ok */
utility.c:    } else if (ch->nr < top_of_npc_t) {        /* I think less than or equal is ok *//* this is ok */
utility.c:                 "Found a character with real number %d, top_of_npc_t == %d", ch->nr, top_of_npc_t);
utility.c:        for (ch = tmp->people; ch; ch = ch->next_in_room)
utility.c:    for (ch = character_list; ch != 0; ch = ch->next) {
utility.c:            if (ch->equipment[i]) {
utility.c:                if (ch->equipment[i]->equipped_by != ch) {
utility.c:                    snprintf(message, sizeof(message), "(ch->equipment[i]->equipped_by != ch )");
utility.c:    return generate_keywords_from_string(ch->player.extkwds);
utility.c:        if (*word && !isname(word, buf) && stricmp(word, ch->name)) {
utility.c:    if (ch->player.extkwds != NULL)
utility.c:        free(ch->player.extkwds);
utility.c:    ch->player.extkwds = strdup(buf);
utility.c:  if (IS_SET(ch->specials.affected_by, CHAR_AFF_CHARM) &&
utility.c:      ch->master) {
utility.c:    if (IS_NPC(ch) && IS_SET(ch->specials.act, CFL_FROZEN))
utility.c:    if( ch->points.hit == newval )
utility.c:    ch->points.hit = newval;
utility.c:    set_hit(ch, ch->points.hit + amount);
utility.c:    if( ch->points.mana == newval )
utility.c:    ch->points.mana = newval;
utility.c:    set_mana(ch, ch->points.mana + amount);
utility.c:    if( ch->points.move == newval )
utility.c:    ch->points.move = newval;
utility.c:    set_move(ch, ch->points.move + amount);
utility.c:    if( ch->points.stun == newval )
utility.c:    ch->points.stun = newval;
utility.c:    set_stun(ch, ch->points.stun + amount);
utility.c:   if (ch->equipment[WEAR_ABOUT] != obj)
watch.c:    return ch->specials.watching.dir > -1
watch.c:     || ch->specials.watching.victim != NULL;
watch.c:    return ch->specials.watching.dir == dir;
watch.c:    return ch->specials.watching.dir > -1;
watch.c:    return ch->specials.watching.dir;
watch.c:    return ch->specials.watching.victim;
watch.c:    return ch->specials.watching.victim == victim;
watch.c:    return ch->specials.watching.victim != NULL;
watch.c:    if (!ch->in_room)
watch.c:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
watch.c:    if (ch->specials.watching.dir > -1) {
watch.c:        if (ch->specials.watching.dir == DIR_OUT) {
watch.c:            tmpob = find_wagon_for_room(ch->in_room);
watch.c:            cprintf(ch, "You stop watching the %s exit.\n\r", dirs[ch->specials.watching.dir]);
watch.c:    if (ch->specials.watching.victim) {
watch.c:        if (ch->specials.watching.victim->in_room
watch.c:            && ch->in_room == ch->specials.watching.victim->in_room) {
watch.c:            cprintf(ch, "You stop watching %s.\n\r", PERS(ch, ch->specials.watching.victim));
watch.c:    if (ch->specials.watching.dir == -1 && ch->specials.watching.victim == NULL && show_failure) {
watch.c:    ch->specials.watching.dir = -1;
watch.c:    ch->specials.watching.victim = NULL;
watch.c:    for (tch = character_list; tch; tch = tch->next) {
watch.c:        if (tch->specials.watching.victim == ch) {
watch.c:            tch->specials.watching.victim = NULL;
watch.c:    for (rch = watcher->in_room->people; rch; rch = rch->next_in_room) {
watch.c:    for (wch = character_list; wch; wch = wch->next) {
watch.c:    if (ch->specials.watching.dir > -1) {
watch.c:        if (ch->specials.watching.dir == DIR_OUT) {
watch.c:            obj = find_wagon_for_room(ch->in_room);
watch.c:                    viewer == ch ? "are" : "is", dirs[ch->specials.watching.dir]);
watch.c:    else if (ch->specials.watching.victim != NULL) {
watch.c:        victim = ch->specials.watching.victim;
watch.c:        if (CAN_SEE(ch, victim) && victim->in_room == ch->in_room) {
watch.c:        if (ch->specials.fighting != NULL && ch->specials.fighting != victim) {
watch.c:        if (ch->specials.guarding == victim) {
watch.c:    if (ch->specials.dir_guarding > -1 && ch->specials.dir_guarding == dir)
weather.c:    if (IS_SET(ch->in_room->room_flags, RFL_INDOORS))
weather.c:        if (IS_DARK(ch->in_room))
weather.c:        if (ch->in_room->light)
weather.c:    zone = ch->in_room->zone;
weather.c:    if (!ch->in_room)
weather.c:            if (wn->zone == ch->in_room->zone)
weather.c:        if (wn->zone == ch->in_room->zone)
weather.c:            create_node(ch->in_room->zone, 0, 60, 100, 5, 10, 7);
